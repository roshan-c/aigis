// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = import.meta.require;

// ../../node_modules/@discordjs/util/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    calculateShardId: () => calculateShardId,
    getUserAgentAppendix: () => getUserAgentAppendix,
    isEquatable: () => isEquatable,
    isJSONEncodable: () => isJSONEncodable,
    lazy: () => lazy,
    polyfillDispose: () => polyfillDispose,
    range: () => range,
    shouldUseGlobalFetchAndWebSocket: () => shouldUseGlobalFetchAndWebSocket,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  function lazy(cb) {
    let defaultValue;
    return () => defaultValue ??= cb();
  }
  __name(lazy, "lazy");
  function* range(range2) {
    let rangeEnd;
    let start = 0;
    let step = 1;
    if (typeof range2 === "number") {
      rangeEnd = range2;
    } else {
      start = range2.start;
      rangeEnd = range2.end;
      step = range2.step ?? 1;
    }
    for (let index = start;index < rangeEnd; index += step) {
      yield index;
    }
  }
  __name(range, "range");
  function calculateShardId(guildId, shardCount) {
    return Number(BigInt(guildId) >> 22n) % shardCount;
  }
  __name(calculateShardId, "calculateShardId");
  function shouldUseGlobalFetchAndWebSocket() {
    if (typeof globalThis.process === "undefined") {
      return "fetch" in globalThis && "WebSocket" in globalThis;
    }
    if ("versions" in globalThis.process) {
      return "deno" in globalThis.process.versions || "bun" in globalThis.process.versions;
    }
    return false;
  }
  __name(shouldUseGlobalFetchAndWebSocket, "shouldUseGlobalFetchAndWebSocket");
  function getUserAgentAppendix() {
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      return "Vercel-Edge-Functions";
    }
    if (typeof globalThis.R2 !== "undefined" && typeof globalThis.WebSocketPair !== "undefined") {
      return "Cloudflare-Workers";
    }
    if (typeof globalThis.Netlify !== "undefined") {
      return "Netlify-Edge-Functions";
    }
    if (typeof globalThis.process !== "object") {
      if (typeof globalThis.navigator === "object") {
        return globalThis.navigator.userAgent;
      }
      return "UnknownEnvironment";
    }
    if ("versions" in globalThis.process) {
      if ("deno" in globalThis.process.versions) {
        return `Deno/${globalThis.process.versions.deno}`;
      }
      if ("bun" in globalThis.process.versions) {
        return `Bun/${globalThis.process.versions.bun}`;
      }
      if ("node" in globalThis.process.versions) {
        return `Node.js/${globalThis.process.versions.node}`;
      }
    }
    return "UnknownEnvironment";
  }
  __name(getUserAgentAppendix, "getUserAgentAppendix");
  function polyfillDispose() {
    Symbol.dispose ??= Symbol("Symbol.dispose");
    Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
  }
  __name(polyfillDispose, "polyfillDispose");
  function isJSONEncodable(maybeEncodable) {
    return maybeEncodable !== null && typeof maybeEncodable === "object" && "toJSON" in maybeEncodable;
  }
  __name(isJSONEncodable, "isJSONEncodable");
  function isEquatable(maybeEquatable) {
    return maybeEquatable !== null && typeof maybeEquatable === "object" && "equals" in maybeEquatable;
  }
  __name(isEquatable, "isEquatable");
  var version = "1.1.1";
});

// ../../node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// ../../node_modules/discord-api-types/gateway/v10.js
var require_v10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VoiceChannelEffectSendAnimationType = exports.GatewayDispatchEvents = exports.GatewayIntentBits = exports.GatewayCloseCodes = exports.GatewayOpcodes = exports.GatewayVersion = undefined;
  exports.GatewayVersion = "10";
  var GatewayOpcodes;
  (function(GatewayOpcodes2) {
    GatewayOpcodes2[GatewayOpcodes2["Dispatch"] = 0] = "Dispatch";
    GatewayOpcodes2[GatewayOpcodes2["Heartbeat"] = 1] = "Heartbeat";
    GatewayOpcodes2[GatewayOpcodes2["Identify"] = 2] = "Identify";
    GatewayOpcodes2[GatewayOpcodes2["PresenceUpdate"] = 3] = "PresenceUpdate";
    GatewayOpcodes2[GatewayOpcodes2["VoiceStateUpdate"] = 4] = "VoiceStateUpdate";
    GatewayOpcodes2[GatewayOpcodes2["Resume"] = 6] = "Resume";
    GatewayOpcodes2[GatewayOpcodes2["Reconnect"] = 7] = "Reconnect";
    GatewayOpcodes2[GatewayOpcodes2["RequestGuildMembers"] = 8] = "RequestGuildMembers";
    GatewayOpcodes2[GatewayOpcodes2["InvalidSession"] = 9] = "InvalidSession";
    GatewayOpcodes2[GatewayOpcodes2["Hello"] = 10] = "Hello";
    GatewayOpcodes2[GatewayOpcodes2["HeartbeatAck"] = 11] = "HeartbeatAck";
    GatewayOpcodes2[GatewayOpcodes2["RequestSoundboardSounds"] = 31] = "RequestSoundboardSounds";
  })(GatewayOpcodes || (exports.GatewayOpcodes = GatewayOpcodes = {}));
  var GatewayCloseCodes;
  (function(GatewayCloseCodes2) {
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownError"] = 4000] = "UnknownError";
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownOpcode"] = 4001] = "UnknownOpcode";
    GatewayCloseCodes2[GatewayCloseCodes2["DecodeError"] = 4002] = "DecodeError";
    GatewayCloseCodes2[GatewayCloseCodes2["NotAuthenticated"] = 4003] = "NotAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["AuthenticationFailed"] = 4004] = "AuthenticationFailed";
    GatewayCloseCodes2[GatewayCloseCodes2["AlreadyAuthenticated"] = 4005] = "AlreadyAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidSeq"] = 4007] = "InvalidSeq";
    GatewayCloseCodes2[GatewayCloseCodes2["RateLimited"] = 4008] = "RateLimited";
    GatewayCloseCodes2[GatewayCloseCodes2["SessionTimedOut"] = 4009] = "SessionTimedOut";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidShard"] = 4010] = "InvalidShard";
    GatewayCloseCodes2[GatewayCloseCodes2["ShardingRequired"] = 4011] = "ShardingRequired";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidAPIVersion"] = 4012] = "InvalidAPIVersion";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidIntents"] = 4013] = "InvalidIntents";
    GatewayCloseCodes2[GatewayCloseCodes2["DisallowedIntents"] = 4014] = "DisallowedIntents";
  })(GatewayCloseCodes || (exports.GatewayCloseCodes = GatewayCloseCodes = {}));
  var GatewayIntentBits;
  (function(GatewayIntentBits2) {
    GatewayIntentBits2[GatewayIntentBits2["Guilds"] = 1] = "Guilds";
    GatewayIntentBits2[GatewayIntentBits2["GuildMembers"] = 2] = "GuildMembers";
    GatewayIntentBits2[GatewayIntentBits2["GuildModeration"] = 4] = "GuildModeration";
    GatewayIntentBits2[GatewayIntentBits2["GuildBans"] = 4] = "GuildBans";
    GatewayIntentBits2[GatewayIntentBits2["GuildExpressions"] = 8] = "GuildExpressions";
    GatewayIntentBits2[GatewayIntentBits2["GuildEmojisAndStickers"] = 8] = "GuildEmojisAndStickers";
    GatewayIntentBits2[GatewayIntentBits2["GuildIntegrations"] = 16] = "GuildIntegrations";
    GatewayIntentBits2[GatewayIntentBits2["GuildWebhooks"] = 32] = "GuildWebhooks";
    GatewayIntentBits2[GatewayIntentBits2["GuildInvites"] = 64] = "GuildInvites";
    GatewayIntentBits2[GatewayIntentBits2["GuildVoiceStates"] = 128] = "GuildVoiceStates";
    GatewayIntentBits2[GatewayIntentBits2["GuildPresences"] = 256] = "GuildPresences";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessages"] = 512] = "GuildMessages";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageReactions"] = 1024] = "GuildMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageTyping"] = 2048] = "GuildMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessages"] = 4096] = "DirectMessages";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageReactions"] = 8192] = "DirectMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageTyping"] = 16384] = "DirectMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["MessageContent"] = 32768] = "MessageContent";
    GatewayIntentBits2[GatewayIntentBits2["GuildScheduledEvents"] = 65536] = "GuildScheduledEvents";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationConfiguration"] = 1048576] = "AutoModerationConfiguration";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationExecution"] = 2097152] = "AutoModerationExecution";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessagePolls"] = 16777216] = "GuildMessagePolls";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessagePolls"] = 33554432] = "DirectMessagePolls";
  })(GatewayIntentBits || (exports.GatewayIntentBits = GatewayIntentBits = {}));
  var GatewayDispatchEvents;
  (function(GatewayDispatchEvents2) {
    GatewayDispatchEvents2["ApplicationCommandPermissionsUpdate"] = "APPLICATION_COMMAND_PERMISSIONS_UPDATE";
    GatewayDispatchEvents2["AutoModerationActionExecution"] = "AUTO_MODERATION_ACTION_EXECUTION";
    GatewayDispatchEvents2["AutoModerationRuleCreate"] = "AUTO_MODERATION_RULE_CREATE";
    GatewayDispatchEvents2["AutoModerationRuleDelete"] = "AUTO_MODERATION_RULE_DELETE";
    GatewayDispatchEvents2["AutoModerationRuleUpdate"] = "AUTO_MODERATION_RULE_UPDATE";
    GatewayDispatchEvents2["ChannelCreate"] = "CHANNEL_CREATE";
    GatewayDispatchEvents2["ChannelDelete"] = "CHANNEL_DELETE";
    GatewayDispatchEvents2["ChannelPinsUpdate"] = "CHANNEL_PINS_UPDATE";
    GatewayDispatchEvents2["ChannelUpdate"] = "CHANNEL_UPDATE";
    GatewayDispatchEvents2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    GatewayDispatchEvents2["EntitlementDelete"] = "ENTITLEMENT_DELETE";
    GatewayDispatchEvents2["EntitlementUpdate"] = "ENTITLEMENT_UPDATE";
    GatewayDispatchEvents2["GuildAuditLogEntryCreate"] = "GUILD_AUDIT_LOG_ENTRY_CREATE";
    GatewayDispatchEvents2["GuildBanAdd"] = "GUILD_BAN_ADD";
    GatewayDispatchEvents2["GuildBanRemove"] = "GUILD_BAN_REMOVE";
    GatewayDispatchEvents2["GuildCreate"] = "GUILD_CREATE";
    GatewayDispatchEvents2["GuildDelete"] = "GUILD_DELETE";
    GatewayDispatchEvents2["GuildEmojisUpdate"] = "GUILD_EMOJIS_UPDATE";
    GatewayDispatchEvents2["GuildIntegrationsUpdate"] = "GUILD_INTEGRATIONS_UPDATE";
    GatewayDispatchEvents2["GuildMemberAdd"] = "GUILD_MEMBER_ADD";
    GatewayDispatchEvents2["GuildMemberRemove"] = "GUILD_MEMBER_REMOVE";
    GatewayDispatchEvents2["GuildMembersChunk"] = "GUILD_MEMBERS_CHUNK";
    GatewayDispatchEvents2["GuildMemberUpdate"] = "GUILD_MEMBER_UPDATE";
    GatewayDispatchEvents2["GuildRoleCreate"] = "GUILD_ROLE_CREATE";
    GatewayDispatchEvents2["GuildRoleDelete"] = "GUILD_ROLE_DELETE";
    GatewayDispatchEvents2["GuildRoleUpdate"] = "GUILD_ROLE_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventCreate"] = "GUILD_SCHEDULED_EVENT_CREATE";
    GatewayDispatchEvents2["GuildScheduledEventDelete"] = "GUILD_SCHEDULED_EVENT_DELETE";
    GatewayDispatchEvents2["GuildScheduledEventUpdate"] = "GUILD_SCHEDULED_EVENT_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventUserAdd"] = "GUILD_SCHEDULED_EVENT_USER_ADD";
    GatewayDispatchEvents2["GuildScheduledEventUserRemove"] = "GUILD_SCHEDULED_EVENT_USER_REMOVE";
    GatewayDispatchEvents2["GuildSoundboardSoundCreate"] = "GUILD_SOUNDBOARD_SOUND_CREATE";
    GatewayDispatchEvents2["GuildSoundboardSoundDelete"] = "GUILD_SOUNDBOARD_SOUND_DELETE";
    GatewayDispatchEvents2["GuildSoundboardSoundsUpdate"] = "GUILD_SOUNDBOARD_SOUNDS_UPDATE";
    GatewayDispatchEvents2["GuildSoundboardSoundUpdate"] = "GUILD_SOUNDBOARD_SOUND_UPDATE";
    GatewayDispatchEvents2["SoundboardSounds"] = "SOUNDBOARD_SOUNDS";
    GatewayDispatchEvents2["GuildStickersUpdate"] = "GUILD_STICKERS_UPDATE";
    GatewayDispatchEvents2["GuildUpdate"] = "GUILD_UPDATE";
    GatewayDispatchEvents2["IntegrationCreate"] = "INTEGRATION_CREATE";
    GatewayDispatchEvents2["IntegrationDelete"] = "INTEGRATION_DELETE";
    GatewayDispatchEvents2["IntegrationUpdate"] = "INTEGRATION_UPDATE";
    GatewayDispatchEvents2["InteractionCreate"] = "INTERACTION_CREATE";
    GatewayDispatchEvents2["InviteCreate"] = "INVITE_CREATE";
    GatewayDispatchEvents2["InviteDelete"] = "INVITE_DELETE";
    GatewayDispatchEvents2["MessageCreate"] = "MESSAGE_CREATE";
    GatewayDispatchEvents2["MessageDelete"] = "MESSAGE_DELETE";
    GatewayDispatchEvents2["MessageDeleteBulk"] = "MESSAGE_DELETE_BULK";
    GatewayDispatchEvents2["MessagePollVoteAdd"] = "MESSAGE_POLL_VOTE_ADD";
    GatewayDispatchEvents2["MessagePollVoteRemove"] = "MESSAGE_POLL_VOTE_REMOVE";
    GatewayDispatchEvents2["MessageReactionAdd"] = "MESSAGE_REACTION_ADD";
    GatewayDispatchEvents2["MessageReactionRemove"] = "MESSAGE_REACTION_REMOVE";
    GatewayDispatchEvents2["MessageReactionRemoveAll"] = "MESSAGE_REACTION_REMOVE_ALL";
    GatewayDispatchEvents2["MessageReactionRemoveEmoji"] = "MESSAGE_REACTION_REMOVE_EMOJI";
    GatewayDispatchEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
    GatewayDispatchEvents2["PresenceUpdate"] = "PRESENCE_UPDATE";
    GatewayDispatchEvents2["RateLimited"] = "RATE_LIMITED";
    GatewayDispatchEvents2["Ready"] = "READY";
    GatewayDispatchEvents2["Resumed"] = "RESUMED";
    GatewayDispatchEvents2["StageInstanceCreate"] = "STAGE_INSTANCE_CREATE";
    GatewayDispatchEvents2["StageInstanceDelete"] = "STAGE_INSTANCE_DELETE";
    GatewayDispatchEvents2["StageInstanceUpdate"] = "STAGE_INSTANCE_UPDATE";
    GatewayDispatchEvents2["SubscriptionCreate"] = "SUBSCRIPTION_CREATE";
    GatewayDispatchEvents2["SubscriptionDelete"] = "SUBSCRIPTION_DELETE";
    GatewayDispatchEvents2["SubscriptionUpdate"] = "SUBSCRIPTION_UPDATE";
    GatewayDispatchEvents2["ThreadCreate"] = "THREAD_CREATE";
    GatewayDispatchEvents2["ThreadDelete"] = "THREAD_DELETE";
    GatewayDispatchEvents2["ThreadListSync"] = "THREAD_LIST_SYNC";
    GatewayDispatchEvents2["ThreadMembersUpdate"] = "THREAD_MEMBERS_UPDATE";
    GatewayDispatchEvents2["ThreadMemberUpdate"] = "THREAD_MEMBER_UPDATE";
    GatewayDispatchEvents2["ThreadUpdate"] = "THREAD_UPDATE";
    GatewayDispatchEvents2["TypingStart"] = "TYPING_START";
    GatewayDispatchEvents2["UserUpdate"] = "USER_UPDATE";
    GatewayDispatchEvents2["VoiceChannelEffectSend"] = "VOICE_CHANNEL_EFFECT_SEND";
    GatewayDispatchEvents2["VoiceServerUpdate"] = "VOICE_SERVER_UPDATE";
    GatewayDispatchEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
    GatewayDispatchEvents2["WebhooksUpdate"] = "WEBHOOKS_UPDATE";
  })(GatewayDispatchEvents || (exports.GatewayDispatchEvents = GatewayDispatchEvents = {}));
  var VoiceChannelEffectSendAnimationType;
  (function(VoiceChannelEffectSendAnimationType2) {
    VoiceChannelEffectSendAnimationType2[VoiceChannelEffectSendAnimationType2["Premium"] = 0] = "Premium";
    VoiceChannelEffectSendAnimationType2[VoiceChannelEffectSendAnimationType2["Basic"] = 1] = "Basic";
  })(VoiceChannelEffectSendAnimationType || (exports.VoiceChannelEffectSendAnimationType = VoiceChannelEffectSendAnimationType = {}));
});

// ../../node_modules/discord-api-types/globals.js
var require_globals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FormattingPatterns = undefined;
  exports.FormattingPatterns = {
    User: /<@(?<id>\d{17,20})>/,
    UserWithNickname: /<@!(?<id>\d{17,20})>/,
    UserWithOptionalNickname: /<@!?(?<id>\d{17,20})>/,
    Channel: /<#(?<id>\d{17,20})>/,
    Role: /<@&(?<id>\d{17,20})>/,
    SlashCommand: /<\/(?<fullName>(?<name>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32})(?: (?<subcommandOrGroup>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?(?: (?<subcommand>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?):(?<id>\d{17,20})>/u,
    Emoji: /<(?<animated>a)?:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    AnimatedEmoji: /<(?<animated>a):(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    StaticEmoji: /<:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    Timestamp: /<t:(?<timestamp>-?\d{1,13})(:(?<style>[DFRTdft]))?>/,
    DefaultStyledTimestamp: /<t:(?<timestamp>-?\d{1,13})>/,
    StyledTimestamp: /<t:(?<timestamp>-?\d{1,13}):(?<style>[DFRTdft])>/,
    GuildNavigation: /<id:(?<type>customize|browse|guide|linked-roles)>/,
    LinkedRole: /<id:linked-roles:(?<id>\d{17,20})>/
  };
  Object.freeze(exports.FormattingPatterns);
});

// ../../node_modules/discord-api-types/payloads/common.js
var require_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PermissionFlagsBits = undefined;
  exports.PermissionFlagsBits = {
    CreateInstantInvite: 1n << 0n,
    KickMembers: 1n << 1n,
    BanMembers: 1n << 2n,
    Administrator: 1n << 3n,
    ManageChannels: 1n << 4n,
    ManageGuild: 1n << 5n,
    AddReactions: 1n << 6n,
    ViewAuditLog: 1n << 7n,
    PrioritySpeaker: 1n << 8n,
    Stream: 1n << 9n,
    ViewChannel: 1n << 10n,
    SendMessages: 1n << 11n,
    SendTTSMessages: 1n << 12n,
    ManageMessages: 1n << 13n,
    EmbedLinks: 1n << 14n,
    AttachFiles: 1n << 15n,
    ReadMessageHistory: 1n << 16n,
    MentionEveryone: 1n << 17n,
    UseExternalEmojis: 1n << 18n,
    ViewGuildInsights: 1n << 19n,
    Connect: 1n << 20n,
    Speak: 1n << 21n,
    MuteMembers: 1n << 22n,
    DeafenMembers: 1n << 23n,
    MoveMembers: 1n << 24n,
    UseVAD: 1n << 25n,
    ChangeNickname: 1n << 26n,
    ManageNicknames: 1n << 27n,
    ManageRoles: 1n << 28n,
    ManageWebhooks: 1n << 29n,
    ManageEmojisAndStickers: 1n << 30n,
    ManageGuildExpressions: 1n << 30n,
    UseApplicationCommands: 1n << 31n,
    RequestToSpeak: 1n << 32n,
    ManageEvents: 1n << 33n,
    ManageThreads: 1n << 34n,
    CreatePublicThreads: 1n << 35n,
    CreatePrivateThreads: 1n << 36n,
    UseExternalStickers: 1n << 37n,
    SendMessagesInThreads: 1n << 38n,
    UseEmbeddedActivities: 1n << 39n,
    ModerateMembers: 1n << 40n,
    ViewCreatorMonetizationAnalytics: 1n << 41n,
    UseSoundboard: 1n << 42n,
    CreateGuildExpressions: 1n << 43n,
    CreateEvents: 1n << 44n,
    UseExternalSounds: 1n << 45n,
    SendVoiceMessages: 1n << 46n,
    SendPolls: 1n << 49n,
    UseExternalApps: 1n << 50n,
    PinMessages: 1n << 51n
  };
  Object.freeze(exports.PermissionFlagsBits);
});

// ../../node_modules/discord-api-types/payloads/v10/application.js
var require_application = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationWebhookEventStatus = exports.ApplicationRoleConnectionMetadataType = exports.ApplicationFlags = undefined;
  var ApplicationFlags;
  (function(ApplicationFlags2) {
    ApplicationFlags2[ApplicationFlags2["EmbeddedReleased"] = 2] = "EmbeddedReleased";
    ApplicationFlags2[ApplicationFlags2["ManagedEmoji"] = 4] = "ManagedEmoji";
    ApplicationFlags2[ApplicationFlags2["EmbeddedIAP"] = 8] = "EmbeddedIAP";
    ApplicationFlags2[ApplicationFlags2["GroupDMCreate"] = 16] = "GroupDMCreate";
    ApplicationFlags2[ApplicationFlags2["ApplicationAutoModerationRuleCreateBadge"] = 64] = "ApplicationAutoModerationRuleCreateBadge";
    ApplicationFlags2[ApplicationFlags2["RPCHasConnected"] = 2048] = "RPCHasConnected";
    ApplicationFlags2[ApplicationFlags2["GatewayPresence"] = 4096] = "GatewayPresence";
    ApplicationFlags2[ApplicationFlags2["GatewayPresenceLimited"] = 8192] = "GatewayPresenceLimited";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembers"] = 16384] = "GatewayGuildMembers";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembersLimited"] = 32768] = "GatewayGuildMembersLimited";
    ApplicationFlags2[ApplicationFlags2["VerificationPendingGuildLimit"] = 65536] = "VerificationPendingGuildLimit";
    ApplicationFlags2[ApplicationFlags2["Embedded"] = 131072] = "Embedded";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContent"] = 262144] = "GatewayMessageContent";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContentLimited"] = 524288] = "GatewayMessageContentLimited";
    ApplicationFlags2[ApplicationFlags2["EmbeddedFirstParty"] = 1048576] = "EmbeddedFirstParty";
    ApplicationFlags2[ApplicationFlags2["ApplicationCommandBadge"] = 8388608] = "ApplicationCommandBadge";
  })(ApplicationFlags || (exports.ApplicationFlags = ApplicationFlags = {}));
  var ApplicationRoleConnectionMetadataType;
  (function(ApplicationRoleConnectionMetadataType2) {
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerLessThanOrEqual"] = 1] = "IntegerLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerGreaterThanOrEqual"] = 2] = "IntegerGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerEqual"] = 3] = "IntegerEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerNotEqual"] = 4] = "IntegerNotEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeLessThanOrEqual"] = 5] = "DatetimeLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeGreaterThanOrEqual"] = 6] = "DatetimeGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanEqual"] = 7] = "BooleanEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanNotEqual"] = 8] = "BooleanNotEqual";
  })(ApplicationRoleConnectionMetadataType || (exports.ApplicationRoleConnectionMetadataType = ApplicationRoleConnectionMetadataType = {}));
  var ApplicationWebhookEventStatus;
  (function(ApplicationWebhookEventStatus2) {
    ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["Disabled"] = 1] = "Disabled";
    ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["Enabled"] = 2] = "Enabled";
    ApplicationWebhookEventStatus2[ApplicationWebhookEventStatus2["DisabledByDiscord"] = 3] = "DisabledByDiscord";
  })(ApplicationWebhookEventStatus || (exports.ApplicationWebhookEventStatus = ApplicationWebhookEventStatus = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/auditLog.js
var require_auditLog = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuditLogOptionsType = exports.AuditLogEvent = undefined;
  var AuditLogEvent;
  (function(AuditLogEvent2) {
    AuditLogEvent2[AuditLogEvent2["GuildUpdate"] = 1] = "GuildUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelCreate"] = 10] = "ChannelCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelUpdate"] = 11] = "ChannelUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelDelete"] = 12] = "ChannelDelete";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteCreate"] = 13] = "ChannelOverwriteCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteUpdate"] = 14] = "ChannelOverwriteUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteDelete"] = 15] = "ChannelOverwriteDelete";
    AuditLogEvent2[AuditLogEvent2["MemberKick"] = 20] = "MemberKick";
    AuditLogEvent2[AuditLogEvent2["MemberPrune"] = 21] = "MemberPrune";
    AuditLogEvent2[AuditLogEvent2["MemberBanAdd"] = 22] = "MemberBanAdd";
    AuditLogEvent2[AuditLogEvent2["MemberBanRemove"] = 23] = "MemberBanRemove";
    AuditLogEvent2[AuditLogEvent2["MemberUpdate"] = 24] = "MemberUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberRoleUpdate"] = 25] = "MemberRoleUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberMove"] = 26] = "MemberMove";
    AuditLogEvent2[AuditLogEvent2["MemberDisconnect"] = 27] = "MemberDisconnect";
    AuditLogEvent2[AuditLogEvent2["BotAdd"] = 28] = "BotAdd";
    AuditLogEvent2[AuditLogEvent2["RoleCreate"] = 30] = "RoleCreate";
    AuditLogEvent2[AuditLogEvent2["RoleUpdate"] = 31] = "RoleUpdate";
    AuditLogEvent2[AuditLogEvent2["RoleDelete"] = 32] = "RoleDelete";
    AuditLogEvent2[AuditLogEvent2["InviteCreate"] = 40] = "InviteCreate";
    AuditLogEvent2[AuditLogEvent2["InviteUpdate"] = 41] = "InviteUpdate";
    AuditLogEvent2[AuditLogEvent2["InviteDelete"] = 42] = "InviteDelete";
    AuditLogEvent2[AuditLogEvent2["WebhookCreate"] = 50] = "WebhookCreate";
    AuditLogEvent2[AuditLogEvent2["WebhookUpdate"] = 51] = "WebhookUpdate";
    AuditLogEvent2[AuditLogEvent2["WebhookDelete"] = 52] = "WebhookDelete";
    AuditLogEvent2[AuditLogEvent2["EmojiCreate"] = 60] = "EmojiCreate";
    AuditLogEvent2[AuditLogEvent2["EmojiUpdate"] = 61] = "EmojiUpdate";
    AuditLogEvent2[AuditLogEvent2["EmojiDelete"] = 62] = "EmojiDelete";
    AuditLogEvent2[AuditLogEvent2["MessageDelete"] = 72] = "MessageDelete";
    AuditLogEvent2[AuditLogEvent2["MessageBulkDelete"] = 73] = "MessageBulkDelete";
    AuditLogEvent2[AuditLogEvent2["MessagePin"] = 74] = "MessagePin";
    AuditLogEvent2[AuditLogEvent2["MessageUnpin"] = 75] = "MessageUnpin";
    AuditLogEvent2[AuditLogEvent2["IntegrationCreate"] = 80] = "IntegrationCreate";
    AuditLogEvent2[AuditLogEvent2["IntegrationUpdate"] = 81] = "IntegrationUpdate";
    AuditLogEvent2[AuditLogEvent2["IntegrationDelete"] = 82] = "IntegrationDelete";
    AuditLogEvent2[AuditLogEvent2["StageInstanceCreate"] = 83] = "StageInstanceCreate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceUpdate"] = 84] = "StageInstanceUpdate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceDelete"] = 85] = "StageInstanceDelete";
    AuditLogEvent2[AuditLogEvent2["StickerCreate"] = 90] = "StickerCreate";
    AuditLogEvent2[AuditLogEvent2["StickerUpdate"] = 91] = "StickerUpdate";
    AuditLogEvent2[AuditLogEvent2["StickerDelete"] = 92] = "StickerDelete";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventCreate"] = 100] = "GuildScheduledEventCreate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventUpdate"] = 101] = "GuildScheduledEventUpdate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventDelete"] = 102] = "GuildScheduledEventDelete";
    AuditLogEvent2[AuditLogEvent2["ThreadCreate"] = 110] = "ThreadCreate";
    AuditLogEvent2[AuditLogEvent2["ThreadUpdate"] = 111] = "ThreadUpdate";
    AuditLogEvent2[AuditLogEvent2["ThreadDelete"] = 112] = "ThreadDelete";
    AuditLogEvent2[AuditLogEvent2["ApplicationCommandPermissionUpdate"] = 121] = "ApplicationCommandPermissionUpdate";
    AuditLogEvent2[AuditLogEvent2["SoundboardSoundCreate"] = 130] = "SoundboardSoundCreate";
    AuditLogEvent2[AuditLogEvent2["SoundboardSoundUpdate"] = 131] = "SoundboardSoundUpdate";
    AuditLogEvent2[AuditLogEvent2["SoundboardSoundDelete"] = 132] = "SoundboardSoundDelete";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleCreate"] = 140] = "AutoModerationRuleCreate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleUpdate"] = 141] = "AutoModerationRuleUpdate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleDelete"] = 142] = "AutoModerationRuleDelete";
    AuditLogEvent2[AuditLogEvent2["AutoModerationBlockMessage"] = 143] = "AutoModerationBlockMessage";
    AuditLogEvent2[AuditLogEvent2["AutoModerationFlagToChannel"] = 144] = "AutoModerationFlagToChannel";
    AuditLogEvent2[AuditLogEvent2["AutoModerationUserCommunicationDisabled"] = 145] = "AutoModerationUserCommunicationDisabled";
    AuditLogEvent2[AuditLogEvent2["AutoModerationQuarantineUser"] = 146] = "AutoModerationQuarantineUser";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationRequestCreated"] = 150] = "CreatorMonetizationRequestCreated";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationTermsAccepted"] = 151] = "CreatorMonetizationTermsAccepted";
    AuditLogEvent2[AuditLogEvent2["OnboardingPromptCreate"] = 163] = "OnboardingPromptCreate";
    AuditLogEvent2[AuditLogEvent2["OnboardingPromptUpdate"] = 164] = "OnboardingPromptUpdate";
    AuditLogEvent2[AuditLogEvent2["OnboardingPromptDelete"] = 165] = "OnboardingPromptDelete";
    AuditLogEvent2[AuditLogEvent2["OnboardingCreate"] = 166] = "OnboardingCreate";
    AuditLogEvent2[AuditLogEvent2["OnboardingUpdate"] = 167] = "OnboardingUpdate";
    AuditLogEvent2[AuditLogEvent2["HomeSettingsCreate"] = 190] = "HomeSettingsCreate";
    AuditLogEvent2[AuditLogEvent2["HomeSettingsUpdate"] = 191] = "HomeSettingsUpdate";
  })(AuditLogEvent || (exports.AuditLogEvent = AuditLogEvent = {}));
  var AuditLogOptionsType;
  (function(AuditLogOptionsType2) {
    AuditLogOptionsType2["Role"] = "0";
    AuditLogOptionsType2["Member"] = "1";
  })(AuditLogOptionsType || (exports.AuditLogOptionsType = AuditLogOptionsType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/autoModeration.js
var require_autoModeration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutoModerationActionType = exports.AutoModerationRuleEventType = exports.AutoModerationRuleKeywordPresetType = exports.AutoModerationRuleTriggerType = undefined;
  var AutoModerationRuleTriggerType;
  (function(AutoModerationRuleTriggerType2) {
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Keyword"] = 1] = "Keyword";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Spam"] = 3] = "Spam";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["KeywordPreset"] = 4] = "KeywordPreset";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MentionSpam"] = 5] = "MentionSpam";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MemberProfile"] = 6] = "MemberProfile";
  })(AutoModerationRuleTriggerType || (exports.AutoModerationRuleTriggerType = AutoModerationRuleTriggerType = {}));
  var AutoModerationRuleKeywordPresetType;
  (function(AutoModerationRuleKeywordPresetType2) {
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Profanity"] = 1] = "Profanity";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["SexualContent"] = 2] = "SexualContent";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Slurs"] = 3] = "Slurs";
  })(AutoModerationRuleKeywordPresetType || (exports.AutoModerationRuleKeywordPresetType = AutoModerationRuleKeywordPresetType = {}));
  var AutoModerationRuleEventType;
  (function(AutoModerationRuleEventType2) {
    AutoModerationRuleEventType2[AutoModerationRuleEventType2["MessageSend"] = 1] = "MessageSend";
    AutoModerationRuleEventType2[AutoModerationRuleEventType2["MemberUpdate"] = 2] = "MemberUpdate";
  })(AutoModerationRuleEventType || (exports.AutoModerationRuleEventType = AutoModerationRuleEventType = {}));
  var AutoModerationActionType;
  (function(AutoModerationActionType2) {
    AutoModerationActionType2[AutoModerationActionType2["BlockMessage"] = 1] = "BlockMessage";
    AutoModerationActionType2[AutoModerationActionType2["SendAlertMessage"] = 2] = "SendAlertMessage";
    AutoModerationActionType2[AutoModerationActionType2["Timeout"] = 3] = "Timeout";
    AutoModerationActionType2[AutoModerationActionType2["BlockMemberInteraction"] = 4] = "BlockMemberInteraction";
  })(AutoModerationActionType || (exports.AutoModerationActionType = AutoModerationActionType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/channel.js
var require_channel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChannelFlags = exports.ThreadMemberFlags = exports.ThreadAutoArchiveDuration = exports.OverwriteType = exports.VideoQualityMode = exports.ChannelType = exports.ForumLayoutType = exports.SortOrderType = undefined;
  var SortOrderType;
  (function(SortOrderType2) {
    SortOrderType2[SortOrderType2["LatestActivity"] = 0] = "LatestActivity";
    SortOrderType2[SortOrderType2["CreationDate"] = 1] = "CreationDate";
  })(SortOrderType || (exports.SortOrderType = SortOrderType = {}));
  var ForumLayoutType;
  (function(ForumLayoutType2) {
    ForumLayoutType2[ForumLayoutType2["NotSet"] = 0] = "NotSet";
    ForumLayoutType2[ForumLayoutType2["ListView"] = 1] = "ListView";
    ForumLayoutType2[ForumLayoutType2["GalleryView"] = 2] = "GalleryView";
  })(ForumLayoutType || (exports.ForumLayoutType = ForumLayoutType = {}));
  var ChannelType;
  (function(ChannelType2) {
    ChannelType2[ChannelType2["GuildText"] = 0] = "GuildText";
    ChannelType2[ChannelType2["DM"] = 1] = "DM";
    ChannelType2[ChannelType2["GuildVoice"] = 2] = "GuildVoice";
    ChannelType2[ChannelType2["GroupDM"] = 3] = "GroupDM";
    ChannelType2[ChannelType2["GuildCategory"] = 4] = "GuildCategory";
    ChannelType2[ChannelType2["GuildAnnouncement"] = 5] = "GuildAnnouncement";
    ChannelType2[ChannelType2["AnnouncementThread"] = 10] = "AnnouncementThread";
    ChannelType2[ChannelType2["PublicThread"] = 11] = "PublicThread";
    ChannelType2[ChannelType2["PrivateThread"] = 12] = "PrivateThread";
    ChannelType2[ChannelType2["GuildStageVoice"] = 13] = "GuildStageVoice";
    ChannelType2[ChannelType2["GuildDirectory"] = 14] = "GuildDirectory";
    ChannelType2[ChannelType2["GuildForum"] = 15] = "GuildForum";
    ChannelType2[ChannelType2["GuildMedia"] = 16] = "GuildMedia";
    ChannelType2[ChannelType2["GuildNews"] = 5] = "GuildNews";
    ChannelType2[ChannelType2["GuildNewsThread"] = 10] = "GuildNewsThread";
    ChannelType2[ChannelType2["GuildPublicThread"] = 11] = "GuildPublicThread";
    ChannelType2[ChannelType2["GuildPrivateThread"] = 12] = "GuildPrivateThread";
  })(ChannelType || (exports.ChannelType = ChannelType = {}));
  var VideoQualityMode;
  (function(VideoQualityMode2) {
    VideoQualityMode2[VideoQualityMode2["Auto"] = 1] = "Auto";
    VideoQualityMode2[VideoQualityMode2["Full"] = 2] = "Full";
  })(VideoQualityMode || (exports.VideoQualityMode = VideoQualityMode = {}));
  var OverwriteType;
  (function(OverwriteType2) {
    OverwriteType2[OverwriteType2["Role"] = 0] = "Role";
    OverwriteType2[OverwriteType2["Member"] = 1] = "Member";
  })(OverwriteType || (exports.OverwriteType = OverwriteType = {}));
  var ThreadAutoArchiveDuration;
  (function(ThreadAutoArchiveDuration2) {
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneHour"] = 60] = "OneHour";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneDay"] = 1440] = "OneDay";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["ThreeDays"] = 4320] = "ThreeDays";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneWeek"] = 10080] = "OneWeek";
  })(ThreadAutoArchiveDuration || (exports.ThreadAutoArchiveDuration = ThreadAutoArchiveDuration = {}));
  var ThreadMemberFlags;
  (function(ThreadMemberFlags2) {
    ThreadMemberFlags2[ThreadMemberFlags2["HasInteracted"] = 1] = "HasInteracted";
    ThreadMemberFlags2[ThreadMemberFlags2["AllMessages"] = 2] = "AllMessages";
    ThreadMemberFlags2[ThreadMemberFlags2["OnlyMentions"] = 4] = "OnlyMentions";
    ThreadMemberFlags2[ThreadMemberFlags2["NoMessages"] = 8] = "NoMessages";
  })(ThreadMemberFlags || (exports.ThreadMemberFlags = ThreadMemberFlags = {}));
  var ChannelFlags;
  (function(ChannelFlags2) {
    ChannelFlags2[ChannelFlags2["GuildFeedRemoved"] = 1] = "GuildFeedRemoved";
    ChannelFlags2[ChannelFlags2["Pinned"] = 2] = "Pinned";
    ChannelFlags2[ChannelFlags2["ActiveChannelsRemoved"] = 4] = "ActiveChannelsRemoved";
    ChannelFlags2[ChannelFlags2["RequireTag"] = 16] = "RequireTag";
    ChannelFlags2[ChannelFlags2["IsSpam"] = 32] = "IsSpam";
    ChannelFlags2[ChannelFlags2["IsGuildResourceChannel"] = 128] = "IsGuildResourceChannel";
    ChannelFlags2[ChannelFlags2["ClydeAI"] = 256] = "ClydeAI";
    ChannelFlags2[ChannelFlags2["IsScheduledForDeletion"] = 512] = "IsScheduledForDeletion";
    ChannelFlags2[ChannelFlags2["HideMediaDownloadOptions"] = 32768] = "HideMediaDownloadOptions";
  })(ChannelFlags || (exports.ChannelFlags = ChannelFlags = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/gateway.js
var require_gateway = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ActivityFlags = exports.StatusDisplayType = exports.ActivityType = exports.ActivityPlatform = exports.PresenceUpdateStatus = undefined;
  var PresenceUpdateStatus;
  (function(PresenceUpdateStatus2) {
    PresenceUpdateStatus2["Online"] = "online";
    PresenceUpdateStatus2["DoNotDisturb"] = "dnd";
    PresenceUpdateStatus2["Idle"] = "idle";
    PresenceUpdateStatus2["Invisible"] = "invisible";
    PresenceUpdateStatus2["Offline"] = "offline";
  })(PresenceUpdateStatus || (exports.PresenceUpdateStatus = PresenceUpdateStatus = {}));
  var ActivityPlatform;
  (function(ActivityPlatform2) {
    ActivityPlatform2["Desktop"] = "desktop";
    ActivityPlatform2["Xbox"] = "xbox";
    ActivityPlatform2["Samsung"] = "samsung";
    ActivityPlatform2["IOS"] = "ios";
    ActivityPlatform2["Android"] = "android";
    ActivityPlatform2["Embedded"] = "embedded";
    ActivityPlatform2["PS4"] = "ps4";
    ActivityPlatform2["PS5"] = "ps5";
  })(ActivityPlatform || (exports.ActivityPlatform = ActivityPlatform = {}));
  var ActivityType;
  (function(ActivityType2) {
    ActivityType2[ActivityType2["Playing"] = 0] = "Playing";
    ActivityType2[ActivityType2["Streaming"] = 1] = "Streaming";
    ActivityType2[ActivityType2["Listening"] = 2] = "Listening";
    ActivityType2[ActivityType2["Watching"] = 3] = "Watching";
    ActivityType2[ActivityType2["Custom"] = 4] = "Custom";
    ActivityType2[ActivityType2["Competing"] = 5] = "Competing";
  })(ActivityType || (exports.ActivityType = ActivityType = {}));
  var StatusDisplayType;
  (function(StatusDisplayType2) {
    StatusDisplayType2[StatusDisplayType2["Name"] = 0] = "Name";
    StatusDisplayType2[StatusDisplayType2["State"] = 1] = "State";
    StatusDisplayType2[StatusDisplayType2["Details"] = 2] = "Details";
  })(StatusDisplayType || (exports.StatusDisplayType = StatusDisplayType = {}));
  var ActivityFlags;
  (function(ActivityFlags2) {
    ActivityFlags2[ActivityFlags2["Instance"] = 1] = "Instance";
    ActivityFlags2[ActivityFlags2["Join"] = 2] = "Join";
    ActivityFlags2[ActivityFlags2["Spectate"] = 4] = "Spectate";
    ActivityFlags2[ActivityFlags2["JoinRequest"] = 8] = "JoinRequest";
    ActivityFlags2[ActivityFlags2["Sync"] = 16] = "Sync";
    ActivityFlags2[ActivityFlags2["Play"] = 32] = "Play";
    ActivityFlags2[ActivityFlags2["PartyPrivacyFriends"] = 64] = "PartyPrivacyFriends";
    ActivityFlags2[ActivityFlags2["PartyPrivacyVoiceChannel"] = 128] = "PartyPrivacyVoiceChannel";
    ActivityFlags2[ActivityFlags2["Embedded"] = 256] = "Embedded";
  })(ActivityFlags || (exports.ActivityFlags = ActivityFlags = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/guild.js
var require_guild = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildOnboardingPromptType = exports.GuildOnboardingMode = exports.MembershipScreeningFieldType = exports.GuildWidgetStyle = exports.IntegrationExpireBehavior = exports.GuildMemberFlags = exports.GuildFeature = exports.GuildSystemChannelFlags = exports.GuildHubType = exports.GuildPremiumTier = exports.GuildVerificationLevel = exports.GuildNSFWLevel = exports.GuildMFALevel = exports.GuildExplicitContentFilter = exports.GuildDefaultMessageNotifications = undefined;
  var GuildDefaultMessageNotifications;
  (function(GuildDefaultMessageNotifications2) {
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["AllMessages"] = 0] = "AllMessages";
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["OnlyMentions"] = 1] = "OnlyMentions";
  })(GuildDefaultMessageNotifications || (exports.GuildDefaultMessageNotifications = GuildDefaultMessageNotifications = {}));
  var GuildExplicitContentFilter;
  (function(GuildExplicitContentFilter2) {
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["Disabled"] = 0] = "Disabled";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["MembersWithoutRoles"] = 1] = "MembersWithoutRoles";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["AllMembers"] = 2] = "AllMembers";
  })(GuildExplicitContentFilter || (exports.GuildExplicitContentFilter = GuildExplicitContentFilter = {}));
  var GuildMFALevel;
  (function(GuildMFALevel2) {
    GuildMFALevel2[GuildMFALevel2["None"] = 0] = "None";
    GuildMFALevel2[GuildMFALevel2["Elevated"] = 1] = "Elevated";
  })(GuildMFALevel || (exports.GuildMFALevel = GuildMFALevel = {}));
  var GuildNSFWLevel;
  (function(GuildNSFWLevel2) {
    GuildNSFWLevel2[GuildNSFWLevel2["Default"] = 0] = "Default";
    GuildNSFWLevel2[GuildNSFWLevel2["Explicit"] = 1] = "Explicit";
    GuildNSFWLevel2[GuildNSFWLevel2["Safe"] = 2] = "Safe";
    GuildNSFWLevel2[GuildNSFWLevel2["AgeRestricted"] = 3] = "AgeRestricted";
  })(GuildNSFWLevel || (exports.GuildNSFWLevel = GuildNSFWLevel = {}));
  var GuildVerificationLevel;
  (function(GuildVerificationLevel2) {
    GuildVerificationLevel2[GuildVerificationLevel2["None"] = 0] = "None";
    GuildVerificationLevel2[GuildVerificationLevel2["Low"] = 1] = "Low";
    GuildVerificationLevel2[GuildVerificationLevel2["Medium"] = 2] = "Medium";
    GuildVerificationLevel2[GuildVerificationLevel2["High"] = 3] = "High";
    GuildVerificationLevel2[GuildVerificationLevel2["VeryHigh"] = 4] = "VeryHigh";
  })(GuildVerificationLevel || (exports.GuildVerificationLevel = GuildVerificationLevel = {}));
  var GuildPremiumTier;
  (function(GuildPremiumTier2) {
    GuildPremiumTier2[GuildPremiumTier2["None"] = 0] = "None";
    GuildPremiumTier2[GuildPremiumTier2["Tier1"] = 1] = "Tier1";
    GuildPremiumTier2[GuildPremiumTier2["Tier2"] = 2] = "Tier2";
    GuildPremiumTier2[GuildPremiumTier2["Tier3"] = 3] = "Tier3";
  })(GuildPremiumTier || (exports.GuildPremiumTier = GuildPremiumTier = {}));
  var GuildHubType;
  (function(GuildHubType2) {
    GuildHubType2[GuildHubType2["Default"] = 0] = "Default";
    GuildHubType2[GuildHubType2["HighSchool"] = 1] = "HighSchool";
    GuildHubType2[GuildHubType2["College"] = 2] = "College";
  })(GuildHubType || (exports.GuildHubType = GuildHubType = {}));
  var GuildSystemChannelFlags;
  (function(GuildSystemChannelFlags2) {
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotifications"] = 1] = "SuppressJoinNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressPremiumSubscriptions"] = 2] = "SuppressPremiumSubscriptions";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressGuildReminderNotifications"] = 4] = "SuppressGuildReminderNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotificationReplies"] = 8] = "SuppressJoinNotificationReplies";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotifications"] = 16] = "SuppressRoleSubscriptionPurchaseNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotificationReplies"] = 32] = "SuppressRoleSubscriptionPurchaseNotificationReplies";
  })(GuildSystemChannelFlags || (exports.GuildSystemChannelFlags = GuildSystemChannelFlags = {}));
  var GuildFeature;
  (function(GuildFeature2) {
    GuildFeature2["AnimatedBanner"] = "ANIMATED_BANNER";
    GuildFeature2["AnimatedIcon"] = "ANIMATED_ICON";
    GuildFeature2["ApplicationCommandPermissionsV2"] = "APPLICATION_COMMAND_PERMISSIONS_V2";
    GuildFeature2["AutoModeration"] = "AUTO_MODERATION";
    GuildFeature2["Banner"] = "BANNER";
    GuildFeature2["Community"] = "COMMUNITY";
    GuildFeature2["CreatorMonetizableProvisional"] = "CREATOR_MONETIZABLE_PROVISIONAL";
    GuildFeature2["CreatorStorePage"] = "CREATOR_STORE_PAGE";
    GuildFeature2["DeveloperSupportServer"] = "DEVELOPER_SUPPORT_SERVER";
    GuildFeature2["Discoverable"] = "DISCOVERABLE";
    GuildFeature2["Featurable"] = "FEATURABLE";
    GuildFeature2["HasDirectoryEntry"] = "HAS_DIRECTORY_ENTRY";
    GuildFeature2["Hub"] = "HUB";
    GuildFeature2["InvitesDisabled"] = "INVITES_DISABLED";
    GuildFeature2["InviteSplash"] = "INVITE_SPLASH";
    GuildFeature2["LinkedToHub"] = "LINKED_TO_HUB";
    GuildFeature2["MemberVerificationGateEnabled"] = "MEMBER_VERIFICATION_GATE_ENABLED";
    GuildFeature2["MoreSoundboard"] = "MORE_SOUNDBOARD";
    GuildFeature2["MonetizationEnabled"] = "MONETIZATION_ENABLED";
    GuildFeature2["MoreStickers"] = "MORE_STICKERS";
    GuildFeature2["News"] = "NEWS";
    GuildFeature2["Partnered"] = "PARTNERED";
    GuildFeature2["PreviewEnabled"] = "PREVIEW_ENABLED";
    GuildFeature2["PrivateThreads"] = "PRIVATE_THREADS";
    GuildFeature2["RaidAlertsDisabled"] = "RAID_ALERTS_DISABLED";
    GuildFeature2["RelayEnabled"] = "RELAY_ENABLED";
    GuildFeature2["RoleIcons"] = "ROLE_ICONS";
    GuildFeature2["RoleSubscriptionsAvailableForPurchase"] = "ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE";
    GuildFeature2["RoleSubscriptionsEnabled"] = "ROLE_SUBSCRIPTIONS_ENABLED";
    GuildFeature2["Soundboard"] = "SOUNDBOARD";
    GuildFeature2["TicketedEventsEnabled"] = "TICKETED_EVENTS_ENABLED";
    GuildFeature2["VanityURL"] = "VANITY_URL";
    GuildFeature2["Verified"] = "VERIFIED";
    GuildFeature2["VIPRegions"] = "VIP_REGIONS";
    GuildFeature2["WelcomeScreenEnabled"] = "WELCOME_SCREEN_ENABLED";
    GuildFeature2["GuildTags"] = "GUILD_TAGS";
    GuildFeature2["EnhancedRoleColors"] = "ENHANCED_ROLE_COLORS";
    GuildFeature2["GuestsEnabled"] = "GUESTS_ENABLED";
  })(GuildFeature || (exports.GuildFeature = GuildFeature = {}));
  var GuildMemberFlags;
  (function(GuildMemberFlags2) {
    GuildMemberFlags2[GuildMemberFlags2["DidRejoin"] = 1] = "DidRejoin";
    GuildMemberFlags2[GuildMemberFlags2["CompletedOnboarding"] = 2] = "CompletedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["BypassesVerification"] = 4] = "BypassesVerification";
    GuildMemberFlags2[GuildMemberFlags2["StartedOnboarding"] = 8] = "StartedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["IsGuest"] = 16] = "IsGuest";
    GuildMemberFlags2[GuildMemberFlags2["StartedHomeActions"] = 32] = "StartedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["CompletedHomeActions"] = 64] = "CompletedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedUsernameOrGuildNickname"] = 128] = "AutomodQuarantinedUsernameOrGuildNickname";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedBio"] = 256] = "AutomodQuarantinedBio";
    GuildMemberFlags2[GuildMemberFlags2["DmSettingsUpsellAcknowledged"] = 512] = "DmSettingsUpsellAcknowledged";
    GuildMemberFlags2[GuildMemberFlags2["AutoModQuarantinedGuildTag"] = 1024] = "AutoModQuarantinedGuildTag";
  })(GuildMemberFlags || (exports.GuildMemberFlags = GuildMemberFlags = {}));
  var IntegrationExpireBehavior;
  (function(IntegrationExpireBehavior2) {
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["RemoveRole"] = 0] = "RemoveRole";
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["Kick"] = 1] = "Kick";
  })(IntegrationExpireBehavior || (exports.IntegrationExpireBehavior = IntegrationExpireBehavior = {}));
  var GuildWidgetStyle;
  (function(GuildWidgetStyle2) {
    GuildWidgetStyle2["Shield"] = "shield";
    GuildWidgetStyle2["Banner1"] = "banner1";
    GuildWidgetStyle2["Banner2"] = "banner2";
    GuildWidgetStyle2["Banner3"] = "banner3";
    GuildWidgetStyle2["Banner4"] = "banner4";
  })(GuildWidgetStyle || (exports.GuildWidgetStyle = GuildWidgetStyle = {}));
  var MembershipScreeningFieldType;
  (function(MembershipScreeningFieldType2) {
    MembershipScreeningFieldType2["Terms"] = "TERMS";
  })(MembershipScreeningFieldType || (exports.MembershipScreeningFieldType = MembershipScreeningFieldType = {}));
  var GuildOnboardingMode;
  (function(GuildOnboardingMode2) {
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingDefault"] = 0] = "OnboardingDefault";
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingAdvanced"] = 1] = "OnboardingAdvanced";
  })(GuildOnboardingMode || (exports.GuildOnboardingMode = GuildOnboardingMode = {}));
  var GuildOnboardingPromptType;
  (function(GuildOnboardingPromptType2) {
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["MultipleChoice"] = 0] = "MultipleChoice";
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["Dropdown"] = 1] = "Dropdown";
  })(GuildOnboardingPromptType || (exports.GuildOnboardingPromptType = GuildOnboardingPromptType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js
var require_guildScheduledEvent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildScheduledEventPrivacyLevel = exports.GuildScheduledEventStatus = exports.GuildScheduledEventEntityType = exports.GuildScheduledEventRecurrenceRuleMonth = exports.GuildScheduledEventRecurrenceRuleWeekday = exports.GuildScheduledEventRecurrenceRuleFrequency = undefined;
  var GuildScheduledEventRecurrenceRuleFrequency;
  (function(GuildScheduledEventRecurrenceRuleFrequency2) {
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Yearly"] = 0] = "Yearly";
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Monthly"] = 1] = "Monthly";
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Weekly"] = 2] = "Weekly";
    GuildScheduledEventRecurrenceRuleFrequency2[GuildScheduledEventRecurrenceRuleFrequency2["Daily"] = 3] = "Daily";
  })(GuildScheduledEventRecurrenceRuleFrequency || (exports.GuildScheduledEventRecurrenceRuleFrequency = GuildScheduledEventRecurrenceRuleFrequency = {}));
  var GuildScheduledEventRecurrenceRuleWeekday;
  (function(GuildScheduledEventRecurrenceRuleWeekday2) {
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Monday"] = 0] = "Monday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Tuesday"] = 1] = "Tuesday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Wednesday"] = 2] = "Wednesday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Thursday"] = 3] = "Thursday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Friday"] = 4] = "Friday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Saturday"] = 5] = "Saturday";
    GuildScheduledEventRecurrenceRuleWeekday2[GuildScheduledEventRecurrenceRuleWeekday2["Sunday"] = 6] = "Sunday";
  })(GuildScheduledEventRecurrenceRuleWeekday || (exports.GuildScheduledEventRecurrenceRuleWeekday = GuildScheduledEventRecurrenceRuleWeekday = {}));
  var GuildScheduledEventRecurrenceRuleMonth;
  (function(GuildScheduledEventRecurrenceRuleMonth2) {
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["January"] = 1] = "January";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["February"] = 2] = "February";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["March"] = 3] = "March";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["April"] = 4] = "April";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["May"] = 5] = "May";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["June"] = 6] = "June";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["July"] = 7] = "July";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["August"] = 8] = "August";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["September"] = 9] = "September";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["October"] = 10] = "October";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["November"] = 11] = "November";
    GuildScheduledEventRecurrenceRuleMonth2[GuildScheduledEventRecurrenceRuleMonth2["December"] = 12] = "December";
  })(GuildScheduledEventRecurrenceRuleMonth || (exports.GuildScheduledEventRecurrenceRuleMonth = GuildScheduledEventRecurrenceRuleMonth = {}));
  var GuildScheduledEventEntityType;
  (function(GuildScheduledEventEntityType2) {
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["StageInstance"] = 1] = "StageInstance";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["Voice"] = 2] = "Voice";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["External"] = 3] = "External";
  })(GuildScheduledEventEntityType || (exports.GuildScheduledEventEntityType = GuildScheduledEventEntityType = {}));
  var GuildScheduledEventStatus;
  (function(GuildScheduledEventStatus2) {
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Scheduled"] = 1] = "Scheduled";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Active"] = 2] = "Active";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Completed"] = 3] = "Completed";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Canceled"] = 4] = "Canceled";
  })(GuildScheduledEventStatus || (exports.GuildScheduledEventStatus = GuildScheduledEventStatus = {}));
  var GuildScheduledEventPrivacyLevel;
  (function(GuildScheduledEventPrivacyLevel2) {
    GuildScheduledEventPrivacyLevel2[GuildScheduledEventPrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(GuildScheduledEventPrivacyLevel || (exports.GuildScheduledEventPrivacyLevel = GuildScheduledEventPrivacyLevel = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js
var require_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationCommandOptionType = undefined;
  var ApplicationCommandOptionType;
  (function(ApplicationCommandOptionType2) {
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Subcommand"] = 1] = "Subcommand";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["SubcommandGroup"] = 2] = "SubcommandGroup";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["String"] = 3] = "String";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Integer"] = 4] = "Integer";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Boolean"] = 5] = "Boolean";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["User"] = 6] = "User";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Channel"] = 7] = "Channel";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Role"] = 8] = "Role";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Mentionable"] = 9] = "Mentionable";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Number"] = 10] = "Number";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Attachment"] = 11] = "Attachment";
  })(ApplicationCommandOptionType || (exports.ApplicationCommandOptionType = ApplicationCommandOptionType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js
var require_chatInput = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_shared(), exports);
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js
var require_permissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.APIApplicationCommandPermissionsConstant = exports.ApplicationCommandPermissionType = undefined;
  var ApplicationCommandPermissionType;
  (function(ApplicationCommandPermissionType2) {
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Role"] = 1] = "Role";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["User"] = 2] = "User";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Channel"] = 3] = "Channel";
  })(ApplicationCommandPermissionType || (exports.ApplicationCommandPermissionType = ApplicationCommandPermissionType = {}));
  exports.APIApplicationCommandPermissionsConstant = {
    Everyone: (guildId) => String(guildId),
    AllChannels: (guildId) => String(BigInt(guildId) - 1n)
  };
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js
var require_applicationCommands = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntryPointCommandHandlerType = exports.InteractionContextType = exports.ApplicationIntegrationType = exports.ApplicationCommandType = undefined;
  __exportStar(require_chatInput(), exports);
  __exportStar(require_permissions(), exports);
  var ApplicationCommandType;
  (function(ApplicationCommandType2) {
    ApplicationCommandType2[ApplicationCommandType2["ChatInput"] = 1] = "ChatInput";
    ApplicationCommandType2[ApplicationCommandType2["User"] = 2] = "User";
    ApplicationCommandType2[ApplicationCommandType2["Message"] = 3] = "Message";
    ApplicationCommandType2[ApplicationCommandType2["PrimaryEntryPoint"] = 4] = "PrimaryEntryPoint";
  })(ApplicationCommandType || (exports.ApplicationCommandType = ApplicationCommandType = {}));
  var ApplicationIntegrationType;
  (function(ApplicationIntegrationType2) {
    ApplicationIntegrationType2[ApplicationIntegrationType2["GuildInstall"] = 0] = "GuildInstall";
    ApplicationIntegrationType2[ApplicationIntegrationType2["UserInstall"] = 1] = "UserInstall";
  })(ApplicationIntegrationType || (exports.ApplicationIntegrationType = ApplicationIntegrationType = {}));
  var InteractionContextType;
  (function(InteractionContextType2) {
    InteractionContextType2[InteractionContextType2["Guild"] = 0] = "Guild";
    InteractionContextType2[InteractionContextType2["BotDM"] = 1] = "BotDM";
    InteractionContextType2[InteractionContextType2["PrivateChannel"] = 2] = "PrivateChannel";
  })(InteractionContextType || (exports.InteractionContextType = InteractionContextType = {}));
  var EntryPointCommandHandlerType;
  (function(EntryPointCommandHandlerType2) {
    EntryPointCommandHandlerType2[EntryPointCommandHandlerType2["AppHandler"] = 1] = "AppHandler";
    EntryPointCommandHandlerType2[EntryPointCommandHandlerType2["DiscordLaunchActivity"] = 2] = "DiscordLaunchActivity";
  })(EntryPointCommandHandlerType || (exports.EntryPointCommandHandlerType = EntryPointCommandHandlerType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/responses.js
var require_responses = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InteractionResponseType = exports.InteractionType = undefined;
  var InteractionType;
  (function(InteractionType2) {
    InteractionType2[InteractionType2["Ping"] = 1] = "Ping";
    InteractionType2[InteractionType2["ApplicationCommand"] = 2] = "ApplicationCommand";
    InteractionType2[InteractionType2["MessageComponent"] = 3] = "MessageComponent";
    InteractionType2[InteractionType2["ApplicationCommandAutocomplete"] = 4] = "ApplicationCommandAutocomplete";
    InteractionType2[InteractionType2["ModalSubmit"] = 5] = "ModalSubmit";
  })(InteractionType || (exports.InteractionType = InteractionType = {}));
  var InteractionResponseType;
  (function(InteractionResponseType2) {
    InteractionResponseType2[InteractionResponseType2["Pong"] = 1] = "Pong";
    InteractionResponseType2[InteractionResponseType2["ChannelMessageWithSource"] = 4] = "ChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredChannelMessageWithSource"] = 5] = "DeferredChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredMessageUpdate"] = 6] = "DeferredMessageUpdate";
    InteractionResponseType2[InteractionResponseType2["UpdateMessage"] = 7] = "UpdateMessage";
    InteractionResponseType2[InteractionResponseType2["ApplicationCommandAutocompleteResult"] = 8] = "ApplicationCommandAutocompleteResult";
    InteractionResponseType2[InteractionResponseType2["Modal"] = 9] = "Modal";
    InteractionResponseType2[InteractionResponseType2["PremiumRequired"] = 10] = "PremiumRequired";
    InteractionResponseType2[InteractionResponseType2["LaunchActivity"] = 12] = "LaunchActivity";
  })(InteractionResponseType || (exports.InteractionResponseType = InteractionResponseType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/interactions.js
var require_interactions = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_applicationCommands(), exports);
  __exportStar(require_responses(), exports);
});

// ../../node_modules/discord-api-types/payloads/v10/invite.js
var require_invite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InviteTargetType = exports.InviteType = exports.InviteFlags = undefined;
  var InviteFlags;
  (function(InviteFlags2) {
    InviteFlags2[InviteFlags2["IsGuestInvite"] = 1] = "IsGuestInvite";
  })(InviteFlags || (exports.InviteFlags = InviteFlags = {}));
  var InviteType;
  (function(InviteType2) {
    InviteType2[InviteType2["Guild"] = 0] = "Guild";
    InviteType2[InviteType2["GroupDM"] = 1] = "GroupDM";
    InviteType2[InviteType2["Friend"] = 2] = "Friend";
  })(InviteType || (exports.InviteType = InviteType = {}));
  var InviteTargetType;
  (function(InviteTargetType2) {
    InviteTargetType2[InviteTargetType2["Stream"] = 1] = "Stream";
    InviteTargetType2[InviteTargetType2["EmbeddedApplication"] = 2] = "EmbeddedApplication";
  })(InviteTargetType || (exports.InviteTargetType = InviteTargetType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/message.js
var require_message = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SeparatorSpacingSize = exports.UnfurledMediaItemLoadingState = exports.SelectMenuDefaultValueType = exports.TextInputStyle = exports.ButtonStyle = exports.ComponentType = exports.AllowedMentionsTypes = exports.AttachmentFlags = exports.EmbedType = exports.MessageFlags = exports.MessageReferenceType = exports.MessageActivityType = exports.MessageType = undefined;
  var MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["Default"] = 0] = "Default";
    MessageType2[MessageType2["RecipientAdd"] = 1] = "RecipientAdd";
    MessageType2[MessageType2["RecipientRemove"] = 2] = "RecipientRemove";
    MessageType2[MessageType2["Call"] = 3] = "Call";
    MessageType2[MessageType2["ChannelNameChange"] = 4] = "ChannelNameChange";
    MessageType2[MessageType2["ChannelIconChange"] = 5] = "ChannelIconChange";
    MessageType2[MessageType2["ChannelPinnedMessage"] = 6] = "ChannelPinnedMessage";
    MessageType2[MessageType2["UserJoin"] = 7] = "UserJoin";
    MessageType2[MessageType2["GuildBoost"] = 8] = "GuildBoost";
    MessageType2[MessageType2["GuildBoostTier1"] = 9] = "GuildBoostTier1";
    MessageType2[MessageType2["GuildBoostTier2"] = 10] = "GuildBoostTier2";
    MessageType2[MessageType2["GuildBoostTier3"] = 11] = "GuildBoostTier3";
    MessageType2[MessageType2["ChannelFollowAdd"] = 12] = "ChannelFollowAdd";
    MessageType2[MessageType2["GuildDiscoveryDisqualified"] = 14] = "GuildDiscoveryDisqualified";
    MessageType2[MessageType2["GuildDiscoveryRequalified"] = 15] = "GuildDiscoveryRequalified";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodInitialWarning"] = 16] = "GuildDiscoveryGracePeriodInitialWarning";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodFinalWarning"] = 17] = "GuildDiscoveryGracePeriodFinalWarning";
    MessageType2[MessageType2["ThreadCreated"] = 18] = "ThreadCreated";
    MessageType2[MessageType2["Reply"] = 19] = "Reply";
    MessageType2[MessageType2["ChatInputCommand"] = 20] = "ChatInputCommand";
    MessageType2[MessageType2["ThreadStarterMessage"] = 21] = "ThreadStarterMessage";
    MessageType2[MessageType2["GuildInviteReminder"] = 22] = "GuildInviteReminder";
    MessageType2[MessageType2["ContextMenuCommand"] = 23] = "ContextMenuCommand";
    MessageType2[MessageType2["AutoModerationAction"] = 24] = "AutoModerationAction";
    MessageType2[MessageType2["RoleSubscriptionPurchase"] = 25] = "RoleSubscriptionPurchase";
    MessageType2[MessageType2["InteractionPremiumUpsell"] = 26] = "InteractionPremiumUpsell";
    MessageType2[MessageType2["StageStart"] = 27] = "StageStart";
    MessageType2[MessageType2["StageEnd"] = 28] = "StageEnd";
    MessageType2[MessageType2["StageSpeaker"] = 29] = "StageSpeaker";
    MessageType2[MessageType2["StageRaiseHand"] = 30] = "StageRaiseHand";
    MessageType2[MessageType2["StageTopic"] = 31] = "StageTopic";
    MessageType2[MessageType2["GuildApplicationPremiumSubscription"] = 32] = "GuildApplicationPremiumSubscription";
    MessageType2[MessageType2["GuildIncidentAlertModeEnabled"] = 36] = "GuildIncidentAlertModeEnabled";
    MessageType2[MessageType2["GuildIncidentAlertModeDisabled"] = 37] = "GuildIncidentAlertModeDisabled";
    MessageType2[MessageType2["GuildIncidentReportRaid"] = 38] = "GuildIncidentReportRaid";
    MessageType2[MessageType2["GuildIncidentReportFalseAlarm"] = 39] = "GuildIncidentReportFalseAlarm";
    MessageType2[MessageType2["PurchaseNotification"] = 44] = "PurchaseNotification";
    MessageType2[MessageType2["PollResult"] = 46] = "PollResult";
  })(MessageType || (exports.MessageType = MessageType = {}));
  var MessageActivityType;
  (function(MessageActivityType2) {
    MessageActivityType2[MessageActivityType2["Join"] = 1] = "Join";
    MessageActivityType2[MessageActivityType2["Spectate"] = 2] = "Spectate";
    MessageActivityType2[MessageActivityType2["Listen"] = 3] = "Listen";
    MessageActivityType2[MessageActivityType2["JoinRequest"] = 5] = "JoinRequest";
  })(MessageActivityType || (exports.MessageActivityType = MessageActivityType = {}));
  var MessageReferenceType;
  (function(MessageReferenceType2) {
    MessageReferenceType2[MessageReferenceType2["Default"] = 0] = "Default";
    MessageReferenceType2[MessageReferenceType2["Forward"] = 1] = "Forward";
  })(MessageReferenceType || (exports.MessageReferenceType = MessageReferenceType = {}));
  var MessageFlags;
  (function(MessageFlags2) {
    MessageFlags2[MessageFlags2["Crossposted"] = 1] = "Crossposted";
    MessageFlags2[MessageFlags2["IsCrosspost"] = 2] = "IsCrosspost";
    MessageFlags2[MessageFlags2["SuppressEmbeds"] = 4] = "SuppressEmbeds";
    MessageFlags2[MessageFlags2["SourceMessageDeleted"] = 8] = "SourceMessageDeleted";
    MessageFlags2[MessageFlags2["Urgent"] = 16] = "Urgent";
    MessageFlags2[MessageFlags2["HasThread"] = 32] = "HasThread";
    MessageFlags2[MessageFlags2["Ephemeral"] = 64] = "Ephemeral";
    MessageFlags2[MessageFlags2["Loading"] = 128] = "Loading";
    MessageFlags2[MessageFlags2["FailedToMentionSomeRolesInThread"] = 256] = "FailedToMentionSomeRolesInThread";
    MessageFlags2[MessageFlags2["ShouldShowLinkNotDiscordWarning"] = 1024] = "ShouldShowLinkNotDiscordWarning";
    MessageFlags2[MessageFlags2["SuppressNotifications"] = 4096] = "SuppressNotifications";
    MessageFlags2[MessageFlags2["IsVoiceMessage"] = 8192] = "IsVoiceMessage";
    MessageFlags2[MessageFlags2["HasSnapshot"] = 16384] = "HasSnapshot";
    MessageFlags2[MessageFlags2["IsComponentsV2"] = 32768] = "IsComponentsV2";
  })(MessageFlags || (exports.MessageFlags = MessageFlags = {}));
  var EmbedType;
  (function(EmbedType2) {
    EmbedType2["Rich"] = "rich";
    EmbedType2["Image"] = "image";
    EmbedType2["Video"] = "video";
    EmbedType2["GIFV"] = "gifv";
    EmbedType2["Article"] = "article";
    EmbedType2["Link"] = "link";
    EmbedType2["AutoModerationMessage"] = "auto_moderation_message";
    EmbedType2["PollResult"] = "poll_result";
  })(EmbedType || (exports.EmbedType = EmbedType = {}));
  var AttachmentFlags;
  (function(AttachmentFlags2) {
    AttachmentFlags2[AttachmentFlags2["IsRemix"] = 4] = "IsRemix";
  })(AttachmentFlags || (exports.AttachmentFlags = AttachmentFlags = {}));
  var AllowedMentionsTypes;
  (function(AllowedMentionsTypes2) {
    AllowedMentionsTypes2["Everyone"] = "everyone";
    AllowedMentionsTypes2["Role"] = "roles";
    AllowedMentionsTypes2["User"] = "users";
  })(AllowedMentionsTypes || (exports.AllowedMentionsTypes = AllowedMentionsTypes = {}));
  var ComponentType;
  (function(ComponentType2) {
    ComponentType2[ComponentType2["ActionRow"] = 1] = "ActionRow";
    ComponentType2[ComponentType2["Button"] = 2] = "Button";
    ComponentType2[ComponentType2["StringSelect"] = 3] = "StringSelect";
    ComponentType2[ComponentType2["TextInput"] = 4] = "TextInput";
    ComponentType2[ComponentType2["UserSelect"] = 5] = "UserSelect";
    ComponentType2[ComponentType2["RoleSelect"] = 6] = "RoleSelect";
    ComponentType2[ComponentType2["MentionableSelect"] = 7] = "MentionableSelect";
    ComponentType2[ComponentType2["ChannelSelect"] = 8] = "ChannelSelect";
    ComponentType2[ComponentType2["Section"] = 9] = "Section";
    ComponentType2[ComponentType2["TextDisplay"] = 10] = "TextDisplay";
    ComponentType2[ComponentType2["Thumbnail"] = 11] = "Thumbnail";
    ComponentType2[ComponentType2["MediaGallery"] = 12] = "MediaGallery";
    ComponentType2[ComponentType2["File"] = 13] = "File";
    ComponentType2[ComponentType2["Separator"] = 14] = "Separator";
    ComponentType2[ComponentType2["ContentInventoryEntry"] = 16] = "ContentInventoryEntry";
    ComponentType2[ComponentType2["Container"] = 17] = "Container";
    ComponentType2[ComponentType2["Label"] = 18] = "Label";
    ComponentType2[ComponentType2["SelectMenu"] = 3] = "SelectMenu";
  })(ComponentType || (exports.ComponentType = ComponentType = {}));
  var ButtonStyle;
  (function(ButtonStyle2) {
    ButtonStyle2[ButtonStyle2["Primary"] = 1] = "Primary";
    ButtonStyle2[ButtonStyle2["Secondary"] = 2] = "Secondary";
    ButtonStyle2[ButtonStyle2["Success"] = 3] = "Success";
    ButtonStyle2[ButtonStyle2["Danger"] = 4] = "Danger";
    ButtonStyle2[ButtonStyle2["Link"] = 5] = "Link";
    ButtonStyle2[ButtonStyle2["Premium"] = 6] = "Premium";
  })(ButtonStyle || (exports.ButtonStyle = ButtonStyle = {}));
  var TextInputStyle;
  (function(TextInputStyle2) {
    TextInputStyle2[TextInputStyle2["Short"] = 1] = "Short";
    TextInputStyle2[TextInputStyle2["Paragraph"] = 2] = "Paragraph";
  })(TextInputStyle || (exports.TextInputStyle = TextInputStyle = {}));
  var SelectMenuDefaultValueType;
  (function(SelectMenuDefaultValueType2) {
    SelectMenuDefaultValueType2["Channel"] = "channel";
    SelectMenuDefaultValueType2["Role"] = "role";
    SelectMenuDefaultValueType2["User"] = "user";
  })(SelectMenuDefaultValueType || (exports.SelectMenuDefaultValueType = SelectMenuDefaultValueType = {}));
  var UnfurledMediaItemLoadingState;
  (function(UnfurledMediaItemLoadingState2) {
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["Unknown"] = 0] = "Unknown";
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["Loading"] = 1] = "Loading";
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["LoadedSuccess"] = 2] = "LoadedSuccess";
    UnfurledMediaItemLoadingState2[UnfurledMediaItemLoadingState2["LoadedNotFound"] = 3] = "LoadedNotFound";
  })(UnfurledMediaItemLoadingState || (exports.UnfurledMediaItemLoadingState = UnfurledMediaItemLoadingState = {}));
  var SeparatorSpacingSize;
  (function(SeparatorSpacingSize2) {
    SeparatorSpacingSize2[SeparatorSpacingSize2["Small"] = 1] = "Small";
    SeparatorSpacingSize2[SeparatorSpacingSize2["Large"] = 2] = "Large";
  })(SeparatorSpacingSize || (exports.SeparatorSpacingSize = SeparatorSpacingSize = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/monetization.js
var require_monetization = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SubscriptionStatus = exports.SKUType = exports.SKUFlags = exports.EntitlementType = undefined;
  var EntitlementType;
  (function(EntitlementType2) {
    EntitlementType2[EntitlementType2["Purchase"] = 1] = "Purchase";
    EntitlementType2[EntitlementType2["PremiumSubscription"] = 2] = "PremiumSubscription";
    EntitlementType2[EntitlementType2["DeveloperGift"] = 3] = "DeveloperGift";
    EntitlementType2[EntitlementType2["TestModePurchase"] = 4] = "TestModePurchase";
    EntitlementType2[EntitlementType2["FreePurchase"] = 5] = "FreePurchase";
    EntitlementType2[EntitlementType2["UserGift"] = 6] = "UserGift";
    EntitlementType2[EntitlementType2["PremiumPurchase"] = 7] = "PremiumPurchase";
    EntitlementType2[EntitlementType2["ApplicationSubscription"] = 8] = "ApplicationSubscription";
  })(EntitlementType || (exports.EntitlementType = EntitlementType = {}));
  var SKUFlags;
  (function(SKUFlags2) {
    SKUFlags2[SKUFlags2["Available"] = 4] = "Available";
    SKUFlags2[SKUFlags2["GuildSubscription"] = 128] = "GuildSubscription";
    SKUFlags2[SKUFlags2["UserSubscription"] = 256] = "UserSubscription";
  })(SKUFlags || (exports.SKUFlags = SKUFlags = {}));
  var SKUType;
  (function(SKUType2) {
    SKUType2[SKUType2["Durable"] = 2] = "Durable";
    SKUType2[SKUType2["Consumable"] = 3] = "Consumable";
    SKUType2[SKUType2["Subscription"] = 5] = "Subscription";
    SKUType2[SKUType2["SubscriptionGroup"] = 6] = "SubscriptionGroup";
  })(SKUType || (exports.SKUType = SKUType = {}));
  var SubscriptionStatus;
  (function(SubscriptionStatus2) {
    SubscriptionStatus2[SubscriptionStatus2["Active"] = 0] = "Active";
    SubscriptionStatus2[SubscriptionStatus2["Ending"] = 1] = "Ending";
    SubscriptionStatus2[SubscriptionStatus2["Inactive"] = 2] = "Inactive";
  })(SubscriptionStatus || (exports.SubscriptionStatus = SubscriptionStatus = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/oauth2.js
var require_oauth2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Scopes = undefined;
  var OAuth2Scopes;
  (function(OAuth2Scopes2) {
    OAuth2Scopes2["Bot"] = "bot";
    OAuth2Scopes2["Connections"] = "connections";
    OAuth2Scopes2["DMChannelsRead"] = "dm_channels.read";
    OAuth2Scopes2["Email"] = "email";
    OAuth2Scopes2["Identify"] = "identify";
    OAuth2Scopes2["Guilds"] = "guilds";
    OAuth2Scopes2["GuildsJoin"] = "guilds.join";
    OAuth2Scopes2["GuildsMembersRead"] = "guilds.members.read";
    OAuth2Scopes2["GroupDMJoins"] = "gdm.join";
    OAuth2Scopes2["MessagesRead"] = "messages.read";
    OAuth2Scopes2["RoleConnectionsWrite"] = "role_connections.write";
    OAuth2Scopes2["RPC"] = "rpc";
    OAuth2Scopes2["RPCActivitiesWrite"] = "rpc.activities.write";
    OAuth2Scopes2["RPCVoiceRead"] = "rpc.voice.read";
    OAuth2Scopes2["RPCVoiceWrite"] = "rpc.voice.write";
    OAuth2Scopes2["RPCNotificationsRead"] = "rpc.notifications.read";
    OAuth2Scopes2["WebhookIncoming"] = "webhook.incoming";
    OAuth2Scopes2["Voice"] = "voice";
    OAuth2Scopes2["ApplicationsBuildsUpload"] = "applications.builds.upload";
    OAuth2Scopes2["ApplicationsBuildsRead"] = "applications.builds.read";
    OAuth2Scopes2["ApplicationsStoreUpdate"] = "applications.store.update";
    OAuth2Scopes2["ApplicationsEntitlements"] = "applications.entitlements";
    OAuth2Scopes2["RelationshipsRead"] = "relationships.read";
    OAuth2Scopes2["ActivitiesRead"] = "activities.read";
    OAuth2Scopes2["ActivitiesWrite"] = "activities.write";
    OAuth2Scopes2["ApplicationsCommands"] = "applications.commands";
    OAuth2Scopes2["ApplicationsCommandsUpdate"] = "applications.commands.update";
    OAuth2Scopes2["ApplicationCommandsPermissionsUpdate"] = "applications.commands.permissions.update";
  })(OAuth2Scopes || (exports.OAuth2Scopes = OAuth2Scopes = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/permissions.js
var require_permissions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RoleFlags = undefined;
  var RoleFlags;
  (function(RoleFlags2) {
    RoleFlags2[RoleFlags2["InPrompt"] = 1] = "InPrompt";
  })(RoleFlags || (exports.RoleFlags = RoleFlags = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/poll.js
var require_poll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollLayoutType = undefined;
  var PollLayoutType;
  (function(PollLayoutType2) {
    PollLayoutType2[PollLayoutType2["Default"] = 1] = "Default";
  })(PollLayoutType || (exports.PollLayoutType = PollLayoutType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/stageInstance.js
var require_stageInstance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StageInstancePrivacyLevel = undefined;
  var StageInstancePrivacyLevel;
  (function(StageInstancePrivacyLevel2) {
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["Public"] = 1] = "Public";
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(StageInstancePrivacyLevel || (exports.StageInstancePrivacyLevel = StageInstancePrivacyLevel = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/sticker.js
var require_sticker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StickerFormatType = exports.StickerType = undefined;
  var StickerType;
  (function(StickerType2) {
    StickerType2[StickerType2["Standard"] = 1] = "Standard";
    StickerType2[StickerType2["Guild"] = 2] = "Guild";
  })(StickerType || (exports.StickerType = StickerType = {}));
  var StickerFormatType;
  (function(StickerFormatType2) {
    StickerFormatType2[StickerFormatType2["PNG"] = 1] = "PNG";
    StickerFormatType2[StickerFormatType2["APNG"] = 2] = "APNG";
    StickerFormatType2[StickerFormatType2["Lottie"] = 3] = "Lottie";
    StickerFormatType2[StickerFormatType2["GIF"] = 4] = "GIF";
  })(StickerFormatType || (exports.StickerFormatType = StickerFormatType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/teams.js
var require_teams = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TeamMemberRole = exports.TeamMemberMembershipState = undefined;
  var TeamMemberMembershipState;
  (function(TeamMemberMembershipState2) {
    TeamMemberMembershipState2[TeamMemberMembershipState2["Invited"] = 1] = "Invited";
    TeamMemberMembershipState2[TeamMemberMembershipState2["Accepted"] = 2] = "Accepted";
  })(TeamMemberMembershipState || (exports.TeamMemberMembershipState = TeamMemberMembershipState = {}));
  var TeamMemberRole;
  (function(TeamMemberRole2) {
    TeamMemberRole2["Admin"] = "admin";
    TeamMemberRole2["Developer"] = "developer";
    TeamMemberRole2["ReadOnly"] = "read_only";
  })(TeamMemberRole || (exports.TeamMemberRole = TeamMemberRole = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/user.js
var require_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NameplatePalette = exports.ConnectionVisibility = exports.ConnectionService = exports.UserPremiumType = exports.UserFlags = undefined;
  var UserFlags;
  (function(UserFlags2) {
    UserFlags2[UserFlags2["Staff"] = 1] = "Staff";
    UserFlags2[UserFlags2["Partner"] = 2] = "Partner";
    UserFlags2[UserFlags2["Hypesquad"] = 4] = "Hypesquad";
    UserFlags2[UserFlags2["BugHunterLevel1"] = 8] = "BugHunterLevel1";
    UserFlags2[UserFlags2["MFASMS"] = 16] = "MFASMS";
    UserFlags2[UserFlags2["PremiumPromoDismissed"] = 32] = "PremiumPromoDismissed";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse1"] = 64] = "HypeSquadOnlineHouse1";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse2"] = 128] = "HypeSquadOnlineHouse2";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse3"] = 256] = "HypeSquadOnlineHouse3";
    UserFlags2[UserFlags2["PremiumEarlySupporter"] = 512] = "PremiumEarlySupporter";
    UserFlags2[UserFlags2["TeamPseudoUser"] = 1024] = "TeamPseudoUser";
    UserFlags2[UserFlags2["HasUnreadUrgentMessages"] = 8192] = "HasUnreadUrgentMessages";
    UserFlags2[UserFlags2["BugHunterLevel2"] = 16384] = "BugHunterLevel2";
    UserFlags2[UserFlags2["VerifiedBot"] = 65536] = "VerifiedBot";
    UserFlags2[UserFlags2["VerifiedDeveloper"] = 131072] = "VerifiedDeveloper";
    UserFlags2[UserFlags2["CertifiedModerator"] = 262144] = "CertifiedModerator";
    UserFlags2[UserFlags2["BotHTTPInteractions"] = 524288] = "BotHTTPInteractions";
    UserFlags2[UserFlags2["Spammer"] = 1048576] = "Spammer";
    UserFlags2[UserFlags2["DisablePremium"] = 2097152] = "DisablePremium";
    UserFlags2[UserFlags2["ActiveDeveloper"] = 4194304] = "ActiveDeveloper";
    UserFlags2[UserFlags2["Quarantined"] = 17592186044416] = "Quarantined";
    UserFlags2[UserFlags2["Collaborator"] = 1125899906842624] = "Collaborator";
    UserFlags2[UserFlags2["RestrictedCollaborator"] = 2251799813685248] = "RestrictedCollaborator";
  })(UserFlags || (exports.UserFlags = UserFlags = {}));
  var UserPremiumType;
  (function(UserPremiumType2) {
    UserPremiumType2[UserPremiumType2["None"] = 0] = "None";
    UserPremiumType2[UserPremiumType2["NitroClassic"] = 1] = "NitroClassic";
    UserPremiumType2[UserPremiumType2["Nitro"] = 2] = "Nitro";
    UserPremiumType2[UserPremiumType2["NitroBasic"] = 3] = "NitroBasic";
  })(UserPremiumType || (exports.UserPremiumType = UserPremiumType = {}));
  var ConnectionService;
  (function(ConnectionService2) {
    ConnectionService2["AmazonMusic"] = "amazon-music";
    ConnectionService2["BattleNet"] = "battlenet";
    ConnectionService2["Bluesky"] = "bluesky";
    ConnectionService2["BungieNet"] = "bungie";
    ConnectionService2["Crunchyroll"] = "crunchyroll";
    ConnectionService2["Domain"] = "domain";
    ConnectionService2["eBay"] = "ebay";
    ConnectionService2["EpicGames"] = "epicgames";
    ConnectionService2["Facebook"] = "facebook";
    ConnectionService2["GitHub"] = "github";
    ConnectionService2["Instagram"] = "instagram";
    ConnectionService2["LeagueOfLegends"] = "leagueoflegends";
    ConnectionService2["Mastodon"] = "mastodon";
    ConnectionService2["PayPal"] = "paypal";
    ConnectionService2["PlayStationNetwork"] = "playstation";
    ConnectionService2["Reddit"] = "reddit";
    ConnectionService2["RiotGames"] = "riotgames";
    ConnectionService2["Roblox"] = "roblox";
    ConnectionService2["Spotify"] = "spotify";
    ConnectionService2["Skype"] = "skype";
    ConnectionService2["Steam"] = "steam";
    ConnectionService2["TikTok"] = "tiktok";
    ConnectionService2["Twitch"] = "twitch";
    ConnectionService2["X"] = "twitter";
    ConnectionService2["Twitter"] = "twitter";
    ConnectionService2["Xbox"] = "xbox";
    ConnectionService2["YouTube"] = "youtube";
  })(ConnectionService || (exports.ConnectionService = ConnectionService = {}));
  var ConnectionVisibility;
  (function(ConnectionVisibility2) {
    ConnectionVisibility2[ConnectionVisibility2["None"] = 0] = "None";
    ConnectionVisibility2[ConnectionVisibility2["Everyone"] = 1] = "Everyone";
  })(ConnectionVisibility || (exports.ConnectionVisibility = ConnectionVisibility = {}));
  var NameplatePalette;
  (function(NameplatePalette2) {
    NameplatePalette2["Berry"] = "berry";
    NameplatePalette2["BubbleGum"] = "bubble_gum";
    NameplatePalette2["Clover"] = "clover";
    NameplatePalette2["Cobalt"] = "cobalt";
    NameplatePalette2["Crimson"] = "crimson";
    NameplatePalette2["Forest"] = "forest";
    NameplatePalette2["Lemon"] = "lemon";
    NameplatePalette2["Sky"] = "sky";
    NameplatePalette2["Teal"] = "teal";
    NameplatePalette2["Violet"] = "violet";
    NameplatePalette2["White"] = "white";
  })(NameplatePalette || (exports.NameplatePalette = NameplatePalette = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/webhook.js
var require_webhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebhookType = exports.ApplicationWebhookEventType = exports.ApplicationWebhookType = undefined;
  var ApplicationWebhookType;
  (function(ApplicationWebhookType2) {
    ApplicationWebhookType2[ApplicationWebhookType2["Ping"] = 0] = "Ping";
    ApplicationWebhookType2[ApplicationWebhookType2["Event"] = 1] = "Event";
  })(ApplicationWebhookType || (exports.ApplicationWebhookType = ApplicationWebhookType = {}));
  var ApplicationWebhookEventType;
  (function(ApplicationWebhookEventType2) {
    ApplicationWebhookEventType2["ApplicationAuthorized"] = "APPLICATION_AUTHORIZED";
    ApplicationWebhookEventType2["ApplicationDeauthorized"] = "APPLICATION_DEAUTHORIZED";
    ApplicationWebhookEventType2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    ApplicationWebhookEventType2["QuestUserEnrollment"] = "QUEST_USER_ENROLLMENT";
  })(ApplicationWebhookEventType || (exports.ApplicationWebhookEventType = ApplicationWebhookEventType = {}));
  var WebhookType;
  (function(WebhookType2) {
    WebhookType2[WebhookType2["Incoming"] = 1] = "Incoming";
    WebhookType2[WebhookType2["ChannelFollower"] = 2] = "ChannelFollower";
    WebhookType2[WebhookType2["Application"] = 3] = "Application";
  })(WebhookType || (exports.WebhookType = WebhookType = {}));
});

// ../../node_modules/discord-api-types/payloads/v10/index.js
var require_v102 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_common(), exports);
  __exportStar(require_application(), exports);
  __exportStar(require_auditLog(), exports);
  __exportStar(require_autoModeration(), exports);
  __exportStar(require_channel(), exports);
  __exportStar(require_gateway(), exports);
  __exportStar(require_guild(), exports);
  __exportStar(require_guildScheduledEvent(), exports);
  __exportStar(require_interactions(), exports);
  __exportStar(require_invite(), exports);
  __exportStar(require_message(), exports);
  __exportStar(require_monetization(), exports);
  __exportStar(require_oauth2(), exports);
  __exportStar(require_permissions2(), exports);
  __exportStar(require_poll(), exports);
  __exportStar(require_stageInstance(), exports);
  __exportStar(require_sticker(), exports);
  __exportStar(require_teams(), exports);
  __exportStar(require_user(), exports);
  __exportStar(require_webhook(), exports);
});

// ../../node_modules/discord-api-types/utils/internals.js
var require_internals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.urlSafeCharacters = undefined;
  var pattern = /^[\d%A-Za-z-_]+$/g;
  exports.urlSafeCharacters = {
    test(input) {
      const result = pattern.test(input);
      pattern.lastIndex = 0;
      return result;
    }
  };
});

// ../../node_modules/discord-api-types/rest/common.js
var require_common2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Locale = exports.RESTJSONErrorCodes = undefined;
  var RESTJSONErrorCodes;
  (function(RESTJSONErrorCodes2) {
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GeneralError"] = 0] = "GeneralError";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAccount"] = 10001] = "UnknownAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplication"] = 10002] = "UnknownApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownChannel"] = 10003] = "UnknownChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuild"] = 10004] = "UnknownGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownIntegration"] = 10005] = "UnknownIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInvite"] = 10006] = "UnknownInvite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMember"] = 10007] = "UnknownMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMessage"] = 10008] = "UnknownMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPermissionOverwrite"] = 10009] = "UnknownPermissionOverwrite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownProvider"] = 10010] = "UnknownProvider";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRole"] = 10011] = "UnknownRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownToken"] = 10012] = "UnknownToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownUser"] = 10013] = "UnknownUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEmoji"] = 10014] = "UnknownEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhook"] = 10015] = "UnknownWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhookService"] = 10016] = "UnknownWebhookService";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSession"] = 10020] = "UnknownSession";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAsset"] = 10021] = "UnknownAsset";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBan"] = 10026] = "UnknownBan";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSKU"] = 10027] = "UnknownSKU";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreListing"] = 10028] = "UnknownStoreListing";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEntitlement"] = 10029] = "UnknownEntitlement";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBuild"] = 10030] = "UnknownBuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownLobby"] = 10031] = "UnknownLobby";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBranch"] = 10032] = "UnknownBranch";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreDirectoryLayout"] = 10033] = "UnknownStoreDirectoryLayout";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRedistributable"] = 10036] = "UnknownRedistributable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGiftCode"] = 10038] = "UnknownGiftCode";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStream"] = 10049] = "UnknownStream";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPremiumServerSubscribeCooldown"] = 10050] = "UnknownPremiumServerSubscribeCooldown";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildTemplate"] = 10057] = "UnknownGuildTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownDiscoverableServerCategory"] = 10059] = "UnknownDiscoverableServerCategory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSticker"] = 10060] = "UnknownSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStickerPack"] = 10061] = "UnknownStickerPack";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInteraction"] = 10062] = "UnknownInteraction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommand"] = 10063] = "UnknownApplicationCommand";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownVoiceState"] = 10065] = "UnknownVoiceState";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommandPermissions"] = 10066] = "UnknownApplicationCommandPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStageInstance"] = 10067] = "UnknownStageInstance";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildMemberVerificationForm"] = 10068] = "UnknownGuildMemberVerificationForm";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildWelcomeScreen"] = 10069] = "UnknownGuildWelcomeScreen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEvent"] = 10070] = "UnknownGuildScheduledEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEventUser"] = 10071] = "UnknownGuildScheduledEventUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownTag"] = 10087] = "UnknownTag";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSound"] = 10097] = "UnknownSound";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BotsCannotUseThisEndpoint"] = 20001] = "BotsCannotUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyBotsCanUseThisEndpoint"] = 20002] = "OnlyBotsCanUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ExplicitContentCannotBeSentToTheDesiredRecipient"] = 20009] = "ExplicitContentCannotBeSentToTheDesiredRecipient";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NotAuthorizedToPerformThisActionOnThisApplication"] = 20012] = "NotAuthorizedToPerformThisActionOnThisApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ActionCannotBePerformedDueToSlowmodeRateLimit"] = 20016] = "ActionCannotBePerformedDueToSlowmodeRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheMazeIsntMeantForYou"] = 20017] = "TheMazeIsntMeantForYou";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyTheOwnerOfThisAccountCanPerformThisAction"] = 20018] = "OnlyTheOwnerOfThisAccountCanPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnnouncementEditLimitExceeded"] = 20022] = "AnnouncementEditLimitExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnderMinimumAge"] = 20024] = "UnderMinimumAge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelSendRateLimit"] = 20028] = "ChannelSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerSendRateLimit"] = 20029] = "ServerSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords"] = 20031] = "StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildPremiumSubscriptionLevelTooLow"] = 20035] = "GuildPremiumSubscriptionLevelTooLow";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildsReached"] = 30001] = "MaximumNumberOfGuildsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfFriendsReached"] = 30002] = "MaximumNumberOfFriendsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinsReachedForTheChannel"] = 30003] = "MaximumNumberOfPinsReachedForTheChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfRecipientsReached"] = 30004] = "MaximumNumberOfRecipientsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildRolesReached"] = 30005] = "MaximumNumberOfGuildRolesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksReached"] = 30007] = "MaximumNumberOfWebhooksReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEmojisReached"] = 30008] = "MaximumNumberOfEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfReactionsReached"] = 30010] = "MaximumNumberOfReactionsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGroupDMsReached"] = 30011] = "MaximumNumberOfGroupDMsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildChannelsReached"] = 30013] = "MaximumNumberOfGuildChannelsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAttachmentsInAMessageReached"] = 30015] = "MaximumNumberOfAttachmentsInAMessageReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfInvitesReached"] = 30016] = "MaximumNumberOfInvitesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAnimatedEmojisReached"] = 30018] = "MaximumNumberOfAnimatedEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerMembersReached"] = 30019] = "MaximumNumberOfServerMembersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerCategoriesReached"] = 30030] = "MaximumNumberOfServerCategoriesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildAlreadyHasTemplate"] = 30031] = "GuildAlreadyHasTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfApplicationCommandsReached"] = 30032] = "MaximumNumberOfApplicationCommandsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumThreadParticipantsReached"] = 30033] = "MaximumThreadParticipantsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumDailyApplicationCommandCreatesReached"] = 30034] = "MaximumDailyApplicationCommandCreatesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfNonGuildMemberBansHasBeenExceeded"] = 30035] = "MaximumNumberOfNonGuildMemberBansHasBeenExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfBanFetchesHasBeenReached"] = 30037] = "MaximumNumberOfBanFetchesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfUncompletedGuildScheduledEventsReached"] = 30038] = "MaximumNumberOfUncompletedGuildScheduledEventsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfStickersReached"] = 30039] = "MaximumNumberOfStickersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPruneRequestsHasBeenReached"] = 30040] = "MaximumNumberOfPruneRequestsHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached"] = 30042] = "MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfSoundboardSoundsReached"] = 30045] = "MaximumNumberOfSoundboardSoundsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEditsToMessagesOlderThanOneHourReached"] = 30046] = "MaximumNumberOfEditsToMessagesOlderThanOneHourReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinnedThreadsInForumHasBeenReached"] = 30047] = "MaximumNumberOfPinnedThreadsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfTagsInForumHasBeenReached"] = 30048] = "MaximumNumberOfTagsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BitrateIsTooHighForChannelOfThisType"] = 30052] = "BitrateIsTooHighForChannelOfThisType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPremiumEmojisReached"] = 30056] = "MaximumNumberOfPremiumEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksPerGuildReached"] = 30058] = "MaximumNumberOfWebhooksPerGuildReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfChannelPermissionOverwritesReached"] = 30060] = "MaximumNumberOfChannelPermissionOverwritesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheChannelsForThisGuildAreTooLarge"] = 30061] = "TheChannelsForThisGuildAreTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["Unauthorized"] = 40001] = "Unauthorized";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VerifyYourAccount"] = 40002] = "VerifyYourAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OpeningDirectMessagesTooFast"] = 40003] = "OpeningDirectMessagesTooFast";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["SendMessagesHasBeenTemporarilyDisabled"] = 40004] = "SendMessagesHasBeenTemporarilyDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestEntityTooLarge"] = 40005] = "RequestEntityTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FeatureTemporarilyDisabledServerSide"] = 40006] = "FeatureTemporarilyDisabledServerSide";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserBannedFromThisGuild"] = 40007] = "UserBannedFromThisGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ConnectionHasBeenRevoked"] = 40012] = "ConnectionHasBeenRevoked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyConsumableSKUsCanBeConsumed"] = 40018] = "OnlyConsumableSKUsCanBeConsumed";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCanOnlyDeleteSandboxEntitlements"] = 40019] = "YouCanOnlyDeleteSandboxEntitlements";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TargetUserIsNotConnectedToVoice"] = 40032] = "TargetUserIsNotConnectedToVoice";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisMessageWasAlreadyCrossposted"] = 40033] = "ThisMessageWasAlreadyCrossposted";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationCommandWithThatNameAlreadyExists"] = 40041] = "ApplicationCommandWithThatNameAlreadyExists";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationInteractionFailedToSend"] = 40043] = "ApplicationInteractionFailedToSend";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAMessageInAForumChannel"] = 40058] = "CannotSendAMessageInAForumChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InteractionHasAlreadyBeenAcknowledged"] = 40060] = "InteractionHasAlreadyBeenAcknowledged";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagNamesMustBeUnique"] = 40061] = "TagNamesMustBeUnique";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServiceResourceIsBeingRateLimited"] = 40062] = "ServiceResourceIsBeingRateLimited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThereAreNoTagsAvailableThatCanBeSetByNonModerators"] = 40066] = "ThereAreNoTagsAvailableThatCanBeSetByNonModerators";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagRequiredToCreateAForumPostInThisChannel"] = 40067] = "TagRequiredToCreateAForumPostInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnEntitlementHasAlreadyBeenGrantedForThisResource"] = 40074] = "AnEntitlementHasAlreadyBeenGrantedForThisResource";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisInteractionHasHitTheMaximumNumberOfFollowUpMessages"] = 40094] = "ThisInteractionHasHitTheMaximumNumberOfFollowUpMessages";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CloudflareIsBlockingYourRequest"] = 40333] = "CloudflareIsBlockingYourRequest";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingAccess"] = 50001] = "MissingAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAccountType"] = 50002] = "InvalidAccountType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnDMChannel"] = 50003] = "CannotExecuteActionOnDMChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildWidgetDisabled"] = 50004] = "GuildWidgetDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditMessageAuthoredByAnotherUser"] = 50005] = "CannotEditMessageAuthoredByAnotherUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAnEmptyMessage"] = 50006] = "CannotSendAnEmptyMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesToThisUser"] = 50007] = "CannotSendMessagesToThisUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesInNonTextChannel"] = 50008] = "CannotSendMessagesInNonTextChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelVerificationLevelTooHighForYouToGainAccess"] = 50009] = "ChannelVerificationLevelTooHighForYouToGainAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationDoesNotHaveBot"] = 50010] = "OAuth2ApplicationDoesNotHaveBot";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationLimitReached"] = 50011] = "OAuth2ApplicationLimitReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2State"] = 50012] = "InvalidOAuth2State";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingPermissions"] = 50013] = "MissingPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidToken"] = 50014] = "InvalidToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoteWasTooLong"] = 50015] = "NoteWasTooLong";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedTooFewOrTooManyMessagesToDelete"] = 50016] = "ProvidedTooFewOrTooManyMessagesToDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMFALevel"] = 50017] = "InvalidMFALevel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageCanOnlyBePinnedInTheChannelItWasSentIn"] = 50019] = "MessageCanOnlyBePinnedInTheChannelItWasSentIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteCodeInvalidOrTaken"] = 50020] = "InviteCodeInvalidOrTaken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnSystemMessage"] = 50021] = "CannotExecuteActionOnSystemMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnThisChannelType"] = 50024] = "CannotExecuteActionOnThisChannelType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2AccessToken"] = 50025] = "InvalidOAuth2AccessToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingRequiredOAuth2Scope"] = 50026] = "MissingRequiredOAuth2Scope";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidWebhookToken"] = 50027] = "InvalidWebhookToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRole"] = 50028] = "InvalidRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRecipients"] = 50033] = "InvalidRecipients";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OneOfTheMessagesProvidedWasTooOldForBulkDelete"] = 50034] = "OneOfTheMessagesProvidedWasTooOldForBulkDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFormBodyOrContentType"] = 50035] = "InvalidFormBodyOrContentType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteAcceptedToGuildWithoutTheBotBeingIn"] = 50036] = "InviteAcceptedToGuildWithoutTheBotBeingIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActivityAction"] = 50039] = "InvalidActivityAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAPIVersion"] = 50041] = "InvalidAPIVersion";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FileUploadedExceedsMaximumSize"] = 50045] = "FileUploadedExceedsMaximumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFileUploaded"] = 50046] = "InvalidFileUploaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSelfRedeemThisGift"] = 50054] = "CannotSelfRedeemThisGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidGuild"] = 50055] = "InvalidGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidSKU"] = 50057] = "InvalidSKU";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRequestOrigin"] = 50067] = "InvalidRequestOrigin";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMessageType"] = 50068] = "InvalidMessageType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PaymentSourceRequiredToRedeemGift"] = 50070] = "PaymentSourceRequiredToRedeemGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotModifyASystemWebhook"] = 50073] = "CannotModifyASystemWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteChannelRequiredForCommunityGuilds"] = 50074] = "CannotDeleteChannelRequiredForCommunityGuilds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditStickersWithinMessage"] = 50080] = "CannotEditStickersWithinMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidStickerSent"] = 50081] = "InvalidStickerSent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActionOnArchivedThread"] = 50083] = "InvalidActionOnArchivedThread";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidThreadNotificationSettings"] = 50084] = "InvalidThreadNotificationSettings";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ParameterEarlierThanCreation"] = 50085] = "ParameterEarlierThanCreation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CommunityServerChannelsMustBeTextChannels"] = 50086] = "CommunityServerChannelsMustBeTextChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor"] = 50091] = "TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNotAvailableInYourLocation"] = 50095] = "ServerNotAvailableInYourLocation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMonetizationEnabledToPerformThisAction"] = 50097] = "ServerNeedsMonetizationEnabledToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMoreBoostsToPerformThisAction"] = 50101] = "ServerNeedsMoreBoostsToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestBodyContainsInvalidJSON"] = 50109] = "RequestBodyContainsInvalidJSON";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileIsInvalid"] = 50110] = "ProvidedFileIsInvalid";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileTypeIsInvalid"] = 50123] = "ProvidedFileTypeIsInvalid";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileDurationExceedsMaximumLength"] = 50124] = "ProvidedFileDurationExceedsMaximumLength";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnerCannotBePendingMember"] = 50131] = "OwnerCannotBePendingMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnershipCannotBeMovedToABotUser"] = 50132] = "OwnershipCannotBeMovedToABotUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToResizeAssetBelowTheMinimumSize"] = 50138] = "FailedToResizeAssetBelowTheMinimumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji"] = 50144] = "CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotConvertBetweenPremiumEmojiAndNormalEmoji"] = 50145] = "CannotConvertBetweenPremiumEmojiAndNormalEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedFileNotFound"] = 50146] = "UploadedFileNotFound";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["SpecifiedEmojiIsInvalid"] = 50151] = "SpecifiedEmojiIsInvalid";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesDoNotSupportAdditionalContent"] = 50159] = "VoiceMessagesDoNotSupportAdditionalContent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveASingleAudioAttachment"] = 50160] = "VoiceMessagesMustHaveASingleAudioAttachment";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveSupportingMetadata"] = 50161] = "VoiceMessagesMustHaveSupportingMetadata";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesCannotBeEdited"] = 50162] = "VoiceMessagesCannotBeEdited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteGuildSubscriptionIntegration"] = 50163] = "CannotDeleteGuildSubscriptionIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCannotSendVoiceMessagesInThisChannel"] = 50173] = "YouCannotSendVoiceMessagesInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheUserAccountMustFirstBeVerified"] = 50178] = "TheUserAccountMustFirstBeVerified";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedFileDoesNotHaveAValidDuration"] = 50192] = "ProvidedFileDoesNotHaveAValidDuration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouDoNotHavePermissionToSendThisSticker"] = 50600] = "YouDoNotHavePermissionToSendThisSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TwoFactorAuthenticationIsRequired"] = 60003] = "TwoFactorAuthenticationIsRequired";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoUsersWithDiscordTagExist"] = 80004] = "NoUsersWithDiscordTagExist";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ReactionWasBlocked"] = 90001] = "ReactionWasBlocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserCannotUseBurstReactions"] = 90002] = "UserCannotUseBurstReactions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationNotYetAvailable"] = 110001] = "ApplicationNotYetAvailable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["APIResourceOverloaded"] = 130000] = "APIResourceOverloaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheStageIsAlreadyOpen"] = 150006] = "TheStageIsAlreadyOpen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotReplyWithoutPermissionToReadMessageHistory"] = 160002] = "CannotReplyWithoutPermissionToReadMessageHistory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadAlreadyCreatedForMessage"] = 160004] = "ThreadAlreadyCreatedForMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadLocked"] = 160005] = "ThreadLocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveThreads"] = 160006] = "MaximumActiveThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveAnnouncementThreads"] = 160007] = "MaximumActiveAnnouncementThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidJSONForUploadedLottieFile"] = 170001] = "InvalidJSONForUploadedLottieFile";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedLottiesCannotContainRasterizedImages"] = 170002] = "UploadedLottiesCannotContainRasterizedImages";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerMaximumFramerateExceeded"] = 170003] = "StickerMaximumFramerateExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFrameCountExceedsMaximumOf1000Frames"] = 170004] = "StickerFrameCountExceedsMaximumOf1000Frames";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["LottieAnimationMaximumDimensionsExceeded"] = 170005] = "LottieAnimationMaximumDimensionsExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFramerateIsTooSmallOrTooLarge"] = 170006] = "StickerFramerateIsTooSmallOrTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerAnimationDurationExceedsMaximumOf5Seconds"] = 170007] = "StickerAnimationDurationExceedsMaximumOf5Seconds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateAFinishedEvent"] = 180000] = "CannotUpdateAFinishedEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToCreateStageNeededForStageEvent"] = 180002] = "FailedToCreateStageNeededForStageEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageWasBlockedByAutomaticModeration"] = 200000] = "MessageWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TitleWasBlockedByAutomaticModeration"] = 200001] = "TitleWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId"] = 220001] = "WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId"] = 220002] = "WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksCanOnlyCreateThreadsInForumChannels"] = 220003] = "WebhooksCanOnlyCreateThreadsInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhookServicesCannotBeUsedInForumChannels"] = 220004] = "WebhookServicesCannotBeUsedInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageBlockedByHarmfulLinksFilter"] = 240000] = "MessageBlockedByHarmfulLinksFilter";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEnableOnboardingRequirementsAreNotMet"] = 350000] = "CannotEnableOnboardingRequirementsAreNotMet";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateOnboardingWhileBelowRequirements"] = 350001] = "CannotUpdateOnboardingWhileBelowRequirements";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["AccessToFileUploadsHasBeenLimitedForThisGuild"] = 400001] = "AccessToFileUploadsHasBeenLimitedForThisGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToBanUsers"] = 500000] = "FailedToBanUsers";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PollVotingBlocked"] = 520000] = "PollVotingBlocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PollExpired"] = 520001] = "PollExpired";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidChannelTypeForPollCreation"] = 520002] = "InvalidChannelTypeForPollCreation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditAPollMessage"] = 520003] = "CannotEditAPollMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUseAnEmojiIncludedWithThePoll"] = 520004] = "CannotUseAnEmojiIncludedWithThePoll";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExpireANonPollMessage"] = 520006] = "CannotExpireANonPollMessage";
  })(RESTJSONErrorCodes || (exports.RESTJSONErrorCodes = RESTJSONErrorCodes = {}));
  var Locale;
  (function(Locale2) {
    Locale2["Indonesian"] = "id";
    Locale2["EnglishUS"] = "en-US";
    Locale2["EnglishGB"] = "en-GB";
    Locale2["Bulgarian"] = "bg";
    Locale2["ChineseCN"] = "zh-CN";
    Locale2["ChineseTW"] = "zh-TW";
    Locale2["Croatian"] = "hr";
    Locale2["Czech"] = "cs";
    Locale2["Danish"] = "da";
    Locale2["Dutch"] = "nl";
    Locale2["Finnish"] = "fi";
    Locale2["French"] = "fr";
    Locale2["German"] = "de";
    Locale2["Greek"] = "el";
    Locale2["Hindi"] = "hi";
    Locale2["Hungarian"] = "hu";
    Locale2["Italian"] = "it";
    Locale2["Japanese"] = "ja";
    Locale2["Korean"] = "ko";
    Locale2["Lithuanian"] = "lt";
    Locale2["Norwegian"] = "no";
    Locale2["Polish"] = "pl";
    Locale2["PortugueseBR"] = "pt-BR";
    Locale2["Romanian"] = "ro";
    Locale2["Russian"] = "ru";
    Locale2["SpanishES"] = "es-ES";
    Locale2["SpanishLATAM"] = "es-419";
    Locale2["Swedish"] = "sv-SE";
    Locale2["Thai"] = "th";
    Locale2["Turkish"] = "tr";
    Locale2["Ukrainian"] = "uk";
    Locale2["Vietnamese"] = "vi";
  })(Locale || (exports.Locale = Locale = {}));
});

// ../../node_modules/discord-api-types/rest/v10/channel.js
var require_channel2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReactionType = undefined;
  var ReactionType;
  (function(ReactionType2) {
    ReactionType2[ReactionType2["Normal"] = 0] = "Normal";
    ReactionType2[ReactionType2["Super"] = 1] = "Super";
  })(ReactionType || (exports.ReactionType = ReactionType = {}));
});

// ../../node_modules/discord-api-types/rest/v10/monetization.js
var require_monetization2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntitlementOwnerType = undefined;
  var EntitlementOwnerType;
  (function(EntitlementOwnerType2) {
    EntitlementOwnerType2[EntitlementOwnerType2["Guild"] = 1] = "Guild";
    EntitlementOwnerType2[EntitlementOwnerType2["User"] = 2] = "User";
  })(EntitlementOwnerType || (exports.EntitlementOwnerType = EntitlementOwnerType = {}));
});

// ../../node_modules/discord-api-types/rest/v10/index.js
var require_v103 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Routes = exports.RouteBases = exports.CDNRoutes = exports.ImageFormat = exports.StickerPackApplicationId = exports.Routes = exports.APIVersion = undefined;
  var internals_1 = require_internals();
  __exportStar(require_common2(), exports);
  __exportStar(require_channel2(), exports);
  __exportStar(require_monetization2(), exports);
  exports.APIVersion = "10";
  exports.Routes = {
    applicationRoleConnectionMetadata(applicationId) {
      return `/applications/${applicationId}/role-connections/metadata`;
    },
    guildAutoModerationRules(guildId) {
      return `/guilds/${guildId}/auto-moderation/rules`;
    },
    guildAutoModerationRule(guildId, ruleId) {
      return `/guilds/${guildId}/auto-moderation/rules/${ruleId}`;
    },
    guildAuditLog(guildId) {
      return `/guilds/${guildId}/audit-logs`;
    },
    channel(channelId) {
      return `/channels/${channelId}`;
    },
    channelMessages(channelId) {
      return `/channels/${channelId}/messages`;
    },
    channelMessage(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}`;
    },
    channelMessageCrosspost(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/crosspost`;
    },
    channelMessageOwnReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/@me`;
    },
    channelMessageUserReaction(channelId, messageId, emoji, userId) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/${userId}`;
    },
    channelMessageReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}`;
    },
    channelMessageAllReactions(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/reactions`;
    },
    channelBulkDelete(channelId) {
      return `/channels/${channelId}/messages/bulk-delete`;
    },
    channelPermission(channelId, overwriteId) {
      return `/channels/${channelId}/permissions/${overwriteId}`;
    },
    channelInvites(channelId) {
      return `/channels/${channelId}/invites`;
    },
    channelFollowers(channelId) {
      return `/channels/${channelId}/followers`;
    },
    channelTyping(channelId) {
      return `/channels/${channelId}/typing`;
    },
    channelMessagesPins(channelId) {
      return `/channels/${channelId}/messages/pins`;
    },
    channelMessagesPin(channelId, messageId) {
      return `/channels/${channelId}/messages/pins/${messageId}`;
    },
    channelPins(channelId) {
      return `/channels/${channelId}/pins`;
    },
    channelPin(channelId, messageId) {
      return `/channels/${channelId}/pins/${messageId}`;
    },
    channelRecipient(channelId, userId) {
      return `/channels/${channelId}/recipients/${userId}`;
    },
    guildEmojis(guildId) {
      return `/guilds/${guildId}/emojis`;
    },
    guildEmoji(guildId, emojiId) {
      return `/guilds/${guildId}/emojis/${emojiId}`;
    },
    guilds() {
      return "/guilds";
    },
    guild(guildId) {
      return `/guilds/${guildId}`;
    },
    guildPreview(guildId) {
      return `/guilds/${guildId}/preview`;
    },
    guildChannels(guildId) {
      return `/guilds/${guildId}/channels`;
    },
    guildMember(guildId, userId = "@me") {
      return `/guilds/${guildId}/members/${userId}`;
    },
    guildMembers(guildId) {
      return `/guilds/${guildId}/members`;
    },
    guildMembersSearch(guildId) {
      return `/guilds/${guildId}/members/search`;
    },
    guildCurrentMemberNickname(guildId) {
      return `/guilds/${guildId}/members/@me/nick`;
    },
    guildMemberRole(guildId, memberId, roleId) {
      return `/guilds/${guildId}/members/${memberId}/roles/${roleId}`;
    },
    guildMFA(guildId) {
      return `/guilds/${guildId}/mfa`;
    },
    guildBans(guildId) {
      return `/guilds/${guildId}/bans`;
    },
    guildBan(guildId, userId) {
      return `/guilds/${guildId}/bans/${userId}`;
    },
    guildRoles(guildId) {
      return `/guilds/${guildId}/roles`;
    },
    guildRole(guildId, roleId) {
      return `/guilds/${guildId}/roles/${roleId}`;
    },
    guildPrune(guildId) {
      return `/guilds/${guildId}/prune`;
    },
    guildVoiceRegions(guildId) {
      return `/guilds/${guildId}/regions`;
    },
    guildInvites(guildId) {
      return `/guilds/${guildId}/invites`;
    },
    guildIntegrations(guildId) {
      return `/guilds/${guildId}/integrations`;
    },
    guildIntegration(guildId, integrationId) {
      return `/guilds/${guildId}/integrations/${integrationId}`;
    },
    guildWidgetSettings(guildId) {
      return `/guilds/${guildId}/widget`;
    },
    guildWidgetJSON(guildId) {
      return `/guilds/${guildId}/widget.json`;
    },
    guildVanityUrl(guildId) {
      return `/guilds/${guildId}/vanity-url`;
    },
    guildWidgetImage(guildId) {
      return `/guilds/${guildId}/widget.png`;
    },
    invite(code) {
      return `/invites/${code}`;
    },
    template(code) {
      return `/guilds/templates/${code}`;
    },
    guildTemplates(guildId) {
      return `/guilds/${guildId}/templates`;
    },
    guildTemplate(guildId, code) {
      return `/guilds/${guildId}/templates/${code}`;
    },
    pollAnswerVoters(channelId, messageId, answerId) {
      return `/channels/${channelId}/polls/${messageId}/answers/${answerId}`;
    },
    expirePoll(channelId, messageId) {
      return `/channels/${channelId}/polls/${messageId}/expire`;
    },
    threads(parentId, messageId) {
      const parts = ["", "channels", parentId];
      if (messageId)
        parts.push("messages", messageId);
      parts.push("threads");
      return parts.join("/");
    },
    guildActiveThreads(guildId) {
      return `/guilds/${guildId}/threads/active`;
    },
    channelThreads(channelId, archivedStatus) {
      return `/channels/${channelId}/threads/archived/${archivedStatus}`;
    },
    channelJoinedArchivedThreads(channelId) {
      return `/channels/${channelId}/users/@me/threads/archived/private`;
    },
    threadMembers(threadId, userId) {
      const parts = ["", "channels", threadId, "thread-members"];
      if (userId)
        parts.push(userId);
      return parts.join("/");
    },
    user(userId = "@me") {
      return `/users/${userId}`;
    },
    userApplicationRoleConnection(applicationId) {
      return `/users/@me/applications/${applicationId}/role-connection`;
    },
    userGuilds() {
      return `/users/@me/guilds`;
    },
    userGuildMember(guildId) {
      return `/users/@me/guilds/${guildId}/member`;
    },
    userGuild(guildId) {
      return `/users/@me/guilds/${guildId}`;
    },
    userChannels() {
      return `/users/@me/channels`;
    },
    userConnections() {
      return `/users/@me/connections`;
    },
    voiceRegions() {
      return `/voice/regions`;
    },
    channelWebhooks(channelId) {
      return `/channels/${channelId}/webhooks`;
    },
    guildWebhooks(guildId) {
      return `/guilds/${guildId}/webhooks`;
    },
    webhook(webhookId, webhookToken) {
      const parts = ["", "webhooks", webhookId];
      if (webhookToken)
        parts.push(webhookToken);
      return parts.join("/");
    },
    webhookMessage(webhookId, webhookToken, messageId = "@original") {
      return `/webhooks/${webhookId}/${webhookToken}/messages/${messageId}`;
    },
    webhookPlatform(webhookId, webhookToken, platform) {
      return `/webhooks/${webhookId}/${webhookToken}/${platform}`;
    },
    gateway() {
      return `/gateway`;
    },
    gatewayBot() {
      return `/gateway/bot`;
    },
    oauth2CurrentApplication() {
      return `/oauth2/applications/@me`;
    },
    oauth2CurrentAuthorization() {
      return `/oauth2/@me`;
    },
    oauth2Authorization() {
      return `/oauth2/authorize`;
    },
    oauth2TokenExchange() {
      return `/oauth2/token`;
    },
    oauth2TokenRevocation() {
      return `/oauth2/token/revoke`;
    },
    applicationCommands(applicationId) {
      return `/applications/${applicationId}/commands`;
    },
    applicationCommand(applicationId, commandId) {
      return `/applications/${applicationId}/commands/${commandId}`;
    },
    applicationGuildCommands(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands`;
    },
    applicationGuildCommand(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}`;
    },
    interactionCallback(interactionId, interactionToken) {
      return `/interactions/${interactionId}/${interactionToken}/callback`;
    },
    guildMemberVerification(guildId) {
      return `/guilds/${guildId}/member-verification`;
    },
    guildVoiceState(guildId, userId = "@me") {
      return `/guilds/${guildId}/voice-states/${userId}`;
    },
    guildApplicationCommandsPermissions(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/permissions`;
    },
    applicationCommandPermissions(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}/permissions`;
    },
    guildWelcomeScreen(guildId) {
      return `/guilds/${guildId}/welcome-screen`;
    },
    stageInstances() {
      return `/stage-instances`;
    },
    stageInstance(channelId) {
      return `/stage-instances/${channelId}`;
    },
    sticker(stickerId) {
      return `/stickers/${stickerId}`;
    },
    stickerPacks() {
      return "/sticker-packs";
    },
    stickerPack(packId) {
      return `/sticker-packs/${packId}`;
    },
    nitroStickerPacks() {
      return "/sticker-packs";
    },
    guildStickers(guildId) {
      return `/guilds/${guildId}/stickers`;
    },
    guildSticker(guildId, stickerId) {
      return `/guilds/${guildId}/stickers/${stickerId}`;
    },
    guildScheduledEvents(guildId) {
      return `/guilds/${guildId}/scheduled-events`;
    },
    guildScheduledEvent(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}`;
    },
    guildScheduledEventUsers(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}/users`;
    },
    guildOnboarding(guildId) {
      return `/guilds/${guildId}/onboarding`;
    },
    guildIncidentActions(guildId) {
      return `/guilds/${guildId}/incident-actions`;
    },
    currentApplication() {
      return "/applications/@me";
    },
    entitlements(applicationId) {
      return `/applications/${applicationId}/entitlements`;
    },
    entitlement(applicationId, entitlementId) {
      return `/applications/${applicationId}/entitlements/${entitlementId}`;
    },
    skus(applicationId) {
      return `/applications/${applicationId}/skus`;
    },
    guildBulkBan(guildId) {
      return `/guilds/${guildId}/bulk-ban`;
    },
    consumeEntitlement(applicationId, entitlementId) {
      return `/applications/${applicationId}/entitlements/${entitlementId}/consume`;
    },
    applicationEmojis(applicationId) {
      return `/applications/${applicationId}/emojis`;
    },
    applicationEmoji(applicationId, emojiId) {
      return `/applications/${applicationId}/emojis/${emojiId}`;
    },
    skuSubscriptions(skuId) {
      return `/skus/${skuId}/subscriptions`;
    },
    skuSubscription(skuId, subscriptionId) {
      return `/skus/${skuId}/subscriptions/${subscriptionId}`;
    },
    sendSoundboardSound(channelId) {
      return `/channels/${channelId}/send-soundboard-sound`;
    },
    soundboardDefaultSounds() {
      return "/soundboard-default-sounds";
    },
    guildSoundboardSounds(guildId) {
      return `/guilds/${guildId}/soundboard-sounds`;
    },
    guildSoundboardSound(guildId, soundId) {
      return `/guilds/${guildId}/soundboard-sounds/${soundId}`;
    }
  };
  for (const [key, fn] of Object.entries(exports.Routes)) {
    exports.Routes[key] = (...args) => {
      const escaped = args.map((arg) => {
        if (arg) {
          if (internals_1.urlSafeCharacters.test(String(arg))) {
            return arg;
          }
          return encodeURIComponent(arg);
        }
        return arg;
      });
      return fn.call(null, ...escaped);
    };
  }
  Object.freeze(exports.Routes);
  exports.StickerPackApplicationId = "710982414301790216";
  var ImageFormat;
  (function(ImageFormat2) {
    ImageFormat2["JPEG"] = "jpeg";
    ImageFormat2["PNG"] = "png";
    ImageFormat2["WebP"] = "webp";
    ImageFormat2["GIF"] = "gif";
    ImageFormat2["Lottie"] = "json";
  })(ImageFormat || (exports.ImageFormat = ImageFormat = {}));
  exports.CDNRoutes = {
    emoji(emojiId, format) {
      return `/emojis/${emojiId}.${format}`;
    },
    guildIcon(guildId, guildIcon, format) {
      return `/icons/${guildId}/${guildIcon}.${format}`;
    },
    guildSplash(guildId, guildSplash, format) {
      return `/splashes/${guildId}/${guildSplash}.${format}`;
    },
    guildDiscoverySplash(guildId, guildDiscoverySplash, format) {
      return `/discovery-splashes/${guildId}/${guildDiscoverySplash}.${format}`;
    },
    guildBanner(guildId, guildBanner, format) {
      return `/banners/${guildId}/${guildBanner}.${format}`;
    },
    userBanner(userId, userBanner, format) {
      return `/banners/${userId}/${userBanner}.${format}`;
    },
    defaultUserAvatar(index) {
      return `/embed/avatars/${index}.png`;
    },
    userAvatar(userId, userAvatar, format) {
      return `/avatars/${userId}/${userAvatar}.${format}`;
    },
    guildMemberAvatar(guildId, userId, memberAvatar, format) {
      return `/guilds/${guildId}/users/${userId}/avatars/${memberAvatar}.${format}`;
    },
    userAvatarDecoration(userId, userAvatarDecoration) {
      return `/avatar-decorations/${userId}/${userAvatarDecoration}.png`;
    },
    avatarDecoration(avatarDecorationDataAsset) {
      return `/avatar-decoration-presets/${avatarDecorationDataAsset}.png`;
    },
    applicationIcon(applicationId, applicationIcon, format) {
      return `/app-icons/${applicationId}/${applicationIcon}.${format}`;
    },
    applicationCover(applicationId, applicationCoverImage, format) {
      return `/app-icons/${applicationId}/${applicationCoverImage}.${format}`;
    },
    applicationAsset(applicationId, applicationAssetId, format) {
      return `/app-assets/${applicationId}/${applicationAssetId}.${format}`;
    },
    achievementIcon(applicationId, achievementId, achievementIconHash, format) {
      return `/app-assets/${applicationId}/achievements/${achievementId}/icons/${achievementIconHash}.${format}`;
    },
    stickerPackBanner(stickerPackBannerAssetId, format) {
      return `/app-assets/${exports.StickerPackApplicationId}/store/${stickerPackBannerAssetId}.${format}`;
    },
    storePageAsset(applicationId, assetId, format = ImageFormat.PNG) {
      return `/app-assets/${applicationId}/store/${assetId}.${format}`;
    },
    teamIcon(teamId, teamIcon, format) {
      return `/team-icons/${teamId}/${teamIcon}.${format}`;
    },
    sticker(stickerId, format) {
      return `/stickers/${stickerId}.${format}`;
    },
    roleIcon(roleId, roleIcon, format) {
      return `/role-icons/${roleId}/${roleIcon}.${format}`;
    },
    guildScheduledEventCover(guildScheduledEventId, guildScheduledEventCoverImage, format) {
      return `/guild-events/${guildScheduledEventId}/${guildScheduledEventCoverImage}.${format}`;
    },
    guildMemberBanner(guildId, userId, guildMemberBanner, format) {
      return `/guilds/${guildId}/users/${userId}/banners/${guildMemberBanner}.${format}`;
    },
    soundboardSound(soundId) {
      return `/soundboard-sounds/${soundId}`;
    },
    guildTagBadge(guildId, guildTagBadge, format) {
      return `/guild-tag-badges/${guildId}/${guildTagBadge}.${format}`;
    }
  };
  for (const [key, fn] of Object.entries(exports.CDNRoutes)) {
    exports.CDNRoutes[key] = (...args) => {
      const escaped = args.map((arg) => {
        if (arg) {
          if (internals_1.urlSafeCharacters.test(String(arg))) {
            return arg;
          }
          return encodeURIComponent(arg);
        }
        return arg;
      });
      return fn.call(null, ...escaped);
    };
  }
  Object.freeze(exports.CDNRoutes);
  exports.RouteBases = {
    api: `https://discord.com/api/v${exports.APIVersion}`,
    cdn: "https://cdn.discordapp.com",
    media: "https://media.discordapp.net",
    invite: "https://discord.gg",
    template: "https://discord.new",
    gift: "https://discord.gift",
    scheduledEvent: "https://discord.com/events"
  };
  Object.freeze(exports.RouteBases);
  exports.OAuth2Routes = {
    authorizationURL: `${exports.RouteBases.api}${exports.Routes.oauth2Authorization()}`,
    tokenURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenExchange()}`,
    tokenRevocationURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenRevocation()}`
  };
  Object.freeze(exports.OAuth2Routes);
});

// ../../node_modules/discord-api-types/rpc/common.js
var require_common3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RPCCloseEventCodes = exports.RPCErrorCodes = exports.RelationshipType = exports.VoiceConnectionStates = exports.RPCVoiceShortcutKeyComboKeyType = exports.RPCVoiceSettingsModeType = exports.RPCDeviceType = undefined;
  var RPCDeviceType;
  (function(RPCDeviceType2) {
    RPCDeviceType2["AudioInput"] = "audioinput";
    RPCDeviceType2["AudioOutput"] = "audiooutput";
    RPCDeviceType2["VideoInput"] = "videoinput";
  })(RPCDeviceType || (exports.RPCDeviceType = RPCDeviceType = {}));
  var RPCVoiceSettingsModeType;
  (function(RPCVoiceSettingsModeType2) {
    RPCVoiceSettingsModeType2["PushToTalk"] = "PUSH_TO_TALK";
    RPCVoiceSettingsModeType2["VoiceActivity"] = "VOICE_ACTIVITY";
  })(RPCVoiceSettingsModeType || (exports.RPCVoiceSettingsModeType = RPCVoiceSettingsModeType = {}));
  var RPCVoiceShortcutKeyComboKeyType;
  (function(RPCVoiceShortcutKeyComboKeyType2) {
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["KeyboardKey"] = 0] = "KeyboardKey";
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["MouseButton"] = 1] = "MouseButton";
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["KeyboardModifierKey"] = 2] = "KeyboardModifierKey";
    RPCVoiceShortcutKeyComboKeyType2[RPCVoiceShortcutKeyComboKeyType2["GamepadButton"] = 3] = "GamepadButton";
  })(RPCVoiceShortcutKeyComboKeyType || (exports.RPCVoiceShortcutKeyComboKeyType = RPCVoiceShortcutKeyComboKeyType = {}));
  var VoiceConnectionStates;
  (function(VoiceConnectionStates2) {
    VoiceConnectionStates2["Disconnected"] = "DISCONNECTED";
    VoiceConnectionStates2["AwaitingEndpoint"] = "AWAITING_ENDPOINT";
    VoiceConnectionStates2["Authenticating"] = "AUTHENTICATING";
    VoiceConnectionStates2["Connecting"] = "CONNECTING";
    VoiceConnectionStates2["Connected"] = "CONNECTED";
    VoiceConnectionStates2["VoiceDisconnected"] = "VOICE_DISCONNECTED";
    VoiceConnectionStates2["VoiceConnecting"] = "VOICE_CONNECTING";
    VoiceConnectionStates2["VoiceConnected"] = "VOICE_CONNECTED";
    VoiceConnectionStates2["NoRoute"] = "NO_ROUTE";
    VoiceConnectionStates2["IceChecking"] = "ICE_CHECKING";
  })(VoiceConnectionStates || (exports.VoiceConnectionStates = VoiceConnectionStates = {}));
  var RelationshipType;
  (function(RelationshipType2) {
    RelationshipType2[RelationshipType2["None"] = 0] = "None";
    RelationshipType2[RelationshipType2["Friend"] = 1] = "Friend";
    RelationshipType2[RelationshipType2["Blocked"] = 2] = "Blocked";
    RelationshipType2[RelationshipType2["PendingIncoming"] = 3] = "PendingIncoming";
    RelationshipType2[RelationshipType2["PendingOutgoing"] = 4] = "PendingOutgoing";
    RelationshipType2[RelationshipType2["Implicit"] = 5] = "Implicit";
  })(RelationshipType || (exports.RelationshipType = RelationshipType = {}));
  var RPCErrorCodes;
  (function(RPCErrorCodes2) {
    RPCErrorCodes2[RPCErrorCodes2["UnknownError"] = 1000] = "UnknownError";
    RPCErrorCodes2[RPCErrorCodes2["ServiceUnavailable"] = 1001] = "ServiceUnavailable";
    RPCErrorCodes2[RPCErrorCodes2["TransactionAborted"] = 1002] = "TransactionAborted";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPayload"] = 4000] = "InvalidPayload";
    RPCErrorCodes2[RPCErrorCodes2["InvalidCommand"] = 4002] = "InvalidCommand";
    RPCErrorCodes2[RPCErrorCodes2["InvalidGuild"] = 4003] = "InvalidGuild";
    RPCErrorCodes2[RPCErrorCodes2["InvalidEvent"] = 4004] = "InvalidEvent";
    RPCErrorCodes2[RPCErrorCodes2["InvalidChannel"] = 4005] = "InvalidChannel";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPermissions"] = 4006] = "InvalidPermissions";
    RPCErrorCodes2[RPCErrorCodes2["InvalidClientId"] = 4007] = "InvalidClientId";
    RPCErrorCodes2[RPCErrorCodes2["InvalidOrigin"] = 4008] = "InvalidOrigin";
    RPCErrorCodes2[RPCErrorCodes2["InvalidToken"] = 4009] = "InvalidToken";
    RPCErrorCodes2[RPCErrorCodes2["InvalidUser"] = 4010] = "InvalidUser";
    RPCErrorCodes2[RPCErrorCodes2["InvalidInvite"] = 4011] = "InvalidInvite";
    RPCErrorCodes2[RPCErrorCodes2["InvalidActivityJoinRequest"] = 4012] = "InvalidActivityJoinRequest";
    RPCErrorCodes2[RPCErrorCodes2["InvalidEntitlement"] = 4013] = "InvalidEntitlement";
    RPCErrorCodes2[RPCErrorCodes2["InvalidGiftCode"] = 4014] = "InvalidGiftCode";
    RPCErrorCodes2[RPCErrorCodes2["OAuth2Error"] = 5000] = "OAuth2Error";
    RPCErrorCodes2[RPCErrorCodes2["SelectChannelTimedOut"] = 5001] = "SelectChannelTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["GetGuildTimedOut"] = 5002] = "GetGuildTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["SelectVoiceForceRequired"] = 5003] = "SelectVoiceForceRequired";
    RPCErrorCodes2[RPCErrorCodes2["CaptureShortcutAlreadyListening"] = 5004] = "CaptureShortcutAlreadyListening";
    RPCErrorCodes2[RPCErrorCodes2["InvalidActivitySecret"] = 5005] = "InvalidActivitySecret";
    RPCErrorCodes2[RPCErrorCodes2["NoEligibleActivity"] = 5006] = "NoEligibleActivity";
    RPCErrorCodes2[RPCErrorCodes2["PurchaseCanceled"] = 5007] = "PurchaseCanceled";
    RPCErrorCodes2[RPCErrorCodes2["PurchaseError"] = 5008] = "PurchaseError";
    RPCErrorCodes2[RPCErrorCodes2["UnauthorizedForAchievement"] = 5009] = "UnauthorizedForAchievement";
    RPCErrorCodes2[RPCErrorCodes2["RateLimited"] = 5010] = "RateLimited";
  })(RPCErrorCodes || (exports.RPCErrorCodes = RPCErrorCodes = {}));
  var RPCCloseEventCodes;
  (function(RPCCloseEventCodes2) {
    RPCCloseEventCodes2[RPCCloseEventCodes2["CloseNormal"] = 1000] = "CloseNormal";
    RPCCloseEventCodes2[RPCCloseEventCodes2["CloseUnsupported"] = 1003] = "CloseUnsupported";
    RPCCloseEventCodes2[RPCCloseEventCodes2["CloseAbnormal"] = 1006] = "CloseAbnormal";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidClientId"] = 4000] = "InvalidClientId";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidOrigin"] = 4001] = "InvalidOrigin";
    RPCCloseEventCodes2[RPCCloseEventCodes2["RateLimited"] = 4002] = "RateLimited";
    RPCCloseEventCodes2[RPCCloseEventCodes2["TokenRevoked"] = 4003] = "TokenRevoked";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidVersion"] = 4004] = "InvalidVersion";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidEncoding"] = 4005] = "InvalidEncoding";
  })(RPCCloseEventCodes || (exports.RPCCloseEventCodes = RPCCloseEventCodes = {}));
});

// ../../node_modules/discord-api-types/rpc/v10.js
var require_v104 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RPCEvents = exports.RPCCommands = exports.RPCVersion = undefined;
  __exportStar(require_common3(), exports);
  exports.RPCVersion = "1";
  var RPCCommands;
  (function(RPCCommands2) {
    RPCCommands2["AcceptActivityInvite"] = "ACCEPT_ACTIVITY_INVITE";
    RPCCommands2["ActivityInviteUser"] = "ACTIVITY_INVITE_USER";
    RPCCommands2["Authenticate"] = "AUTHENTICATE";
    RPCCommands2["Authorize"] = "AUTHORIZE";
    RPCCommands2["BraintreePopupBridgeCallback"] = "BRAINTREE_POPUP_BRIDGE_CALLBACK";
    RPCCommands2["BrowserHandoff"] = "BROWSER_HANDOFF";
    RPCCommands2["CloseActivityJoinRequest"] = "CLOSE_ACTIVITY_JOIN_REQUEST";
    RPCCommands2["ConnectionsCallback"] = "CONNECTIONS_CALLBACK";
    RPCCommands2["CreateChannelInvite"] = "CREATE_CHANNEL_INVITE";
    RPCCommands2["DeepLink"] = "DEEP_LINK";
    RPCCommands2["Dispatch"] = "DISPATCH";
    RPCCommands2["GetApplicationTicket"] = "GET_APPLICATION_TICKET";
    RPCCommands2["GetChannel"] = "GET_CHANNEL";
    RPCCommands2["GetChannels"] = "GET_CHANNELS";
    RPCCommands2["GetEntitlementTicket"] = "GET_ENTITLEMENT_TICKET";
    RPCCommands2["GetEntitlements"] = "GET_ENTITLEMENTS";
    RPCCommands2["GetGuild"] = "GET_GUILD";
    RPCCommands2["GetGuilds"] = "GET_GUILDS";
    RPCCommands2["GetImage"] = "GET_IMAGE";
    RPCCommands2["GetNetworkingConfig"] = "GET_NETWORKING_CONFIG";
    RPCCommands2["GetRelationships"] = "GET_RELATIONSHIPS";
    RPCCommands2["GetSelectedVoiceChannel"] = "GET_SELECTED_VOICE_CHANNEL";
    RPCCommands2["GetSkus"] = "GET_SKUS";
    RPCCommands2["GetUser"] = "GET_USER";
    RPCCommands2["GetVoiceSettings"] = "GET_VOICE_SETTINGS";
    RPCCommands2["GiftCodeBrowser"] = "GIFT_CODE_BROWSER";
    RPCCommands2["GuildTemplateBrowser"] = "GUILD_TEMPLATE_BROWSER";
    RPCCommands2["InviteBrowser"] = "INVITE_BROWSER";
    RPCCommands2["NetworkingCreateToken"] = "NETWORKING_CREATE_TOKEN";
    RPCCommands2["NetworkingPeerMetrics"] = "NETWORKING_PEER_METRICS";
    RPCCommands2["NetworkingSystemMetrics"] = "NETWORKING_SYSTEM_METRICS";
    RPCCommands2["OpenOverlayActivityInvite"] = "OPEN_OVERLAY_ACTIVITY_INVITE";
    RPCCommands2["OpenOverlayGuildInvite"] = "OPEN_OVERLAY_GUILD_INVITE";
    RPCCommands2["OpenOverlayVoiceSettings"] = "OPEN_OVERLAY_VOICE_SETTINGS";
    RPCCommands2["Overlay"] = "OVERLAY";
    RPCCommands2["SelectTextChannel"] = "SELECT_TEXT_CHANNEL";
    RPCCommands2["SelectVoiceChannel"] = "SELECT_VOICE_CHANNEL";
    RPCCommands2["SendActivityJoinInvite"] = "SEND_ACTIVITY_JOIN_INVITE";
    RPCCommands2["SetActivity"] = "SET_ACTIVITY";
    RPCCommands2["SetCertifiedDevices"] = "SET_CERTIFIED_DEVICES";
    RPCCommands2["SetOverlayLocked"] = "SET_OVERLAY_LOCKED";
    RPCCommands2["SetUserVoiceSettings"] = "SET_USER_VOICE_SETTINGS";
    RPCCommands2["SetUserVoiceSettings2"] = "SET_USER_VOICE_SETTINGS_2";
    RPCCommands2["SetVoiceSettings"] = "SET_VOICE_SETTINGS";
    RPCCommands2["SetVoiceSettings2"] = "SET_VOICE_SETTINGS_2";
    RPCCommands2["StartPurchase"] = "START_PURCHASE";
    RPCCommands2["Subscribe"] = "SUBSCRIBE";
    RPCCommands2["Unsubscribe"] = "UNSUBSCRIBE";
    RPCCommands2["ValidateApplication"] = "VALIDATE_APPLICATION";
  })(RPCCommands || (exports.RPCCommands = RPCCommands = {}));
  var RPCEvents;
  (function(RPCEvents2) {
    RPCEvents2["ActivityInvite"] = "ACTIVITY_INVITE";
    RPCEvents2["ActivityJoin"] = "ACTIVITY_JOIN";
    RPCEvents2["ActivityJoinRequest"] = "ACTIVITY_JOIN_REQUEST";
    RPCEvents2["ActivitySpectate"] = "ACTIVITY_SPECTATE";
    RPCEvents2["ChannelCreate"] = "CHANNEL_CREATE";
    RPCEvents2["CurrentUserUpdate"] = "CURRENT_USER_UPDATE";
    RPCEvents2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    RPCEvents2["EntitlementDelete"] = "ENTITLEMENT_DELETE";
    RPCEvents2["Error"] = "ERROR";
    RPCEvents2["GameJoin"] = "GAME_JOIN";
    RPCEvents2["GameSpectate"] = "GAME_SPECTATE";
    RPCEvents2["GuildCreate"] = "GUILD_CREATE";
    RPCEvents2["GuildStatus"] = "GUILD_STATUS";
    RPCEvents2["MessageCreate"] = "MESSAGE_CREATE";
    RPCEvents2["MessageDelete"] = "MESSAGE_DELETE";
    RPCEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
    RPCEvents2["NotificationCreate"] = "NOTIFICATION_CREATE";
    RPCEvents2["Overlay"] = "OVERLAY";
    RPCEvents2["OverlayUpdate"] = "OVERLAY_UPDATE";
    RPCEvents2["Ready"] = "READY";
    RPCEvents2["RelationshipUpdate"] = "RELATIONSHIP_UPDATE";
    RPCEvents2["SpeakingStart"] = "SPEAKING_START";
    RPCEvents2["SpeakingStop"] = "SPEAKING_STOP";
    RPCEvents2["VoiceChannelSelect"] = "VOICE_CHANNEL_SELECT";
    RPCEvents2["VoiceConnectionStatus"] = "VOICE_CONNECTION_STATUS";
    RPCEvents2["VoiceSettingsUpdate"] = "VOICE_SETTINGS_UPDATE";
    RPCEvents2["VoiceSettingsUpdate2"] = "VOICE_SETTINGS_UPDATE_2";
    RPCEvents2["VoiceStateCreate"] = "VOICE_STATE_CREATE";
    RPCEvents2["VoiceStateDelete"] = "VOICE_STATE_DELETE";
    RPCEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
  })(RPCEvents || (exports.RPCEvents = RPCEvents = {}));
});

// ../../node_modules/discord-api-types/utils/v10.js
var require_v105 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDMInteraction = isDMInteraction;
  exports.isGuildInteraction = isGuildInteraction;
  exports.isApplicationCommandDMInteraction = isApplicationCommandDMInteraction;
  exports.isApplicationCommandGuildInteraction = isApplicationCommandGuildInteraction;
  exports.isMessageComponentDMInteraction = isMessageComponentDMInteraction;
  exports.isMessageComponentGuildInteraction = isMessageComponentGuildInteraction;
  exports.isLinkButton = isLinkButton;
  exports.isInteractionButton = isInteractionButton;
  exports.isMessageComponentInteraction = isMessageComponentInteraction;
  exports.isMessageComponentButtonInteraction = isMessageComponentButtonInteraction;
  exports.isMessageComponentSelectMenuInteraction = isMessageComponentSelectMenuInteraction;
  exports.isChatInputApplicationCommandInteraction = isChatInputApplicationCommandInteraction;
  exports.isContextMenuApplicationCommandInteraction = isContextMenuApplicationCommandInteraction;
  var index_1 = require_v102();
  function isDMInteraction(interaction) {
    return Reflect.has(interaction, "user");
  }
  function isGuildInteraction(interaction) {
    return Reflect.has(interaction, "guild_id");
  }
  function isApplicationCommandDMInteraction(interaction) {
    return isDMInteraction(interaction);
  }
  function isApplicationCommandGuildInteraction(interaction) {
    return isGuildInteraction(interaction);
  }
  function isMessageComponentDMInteraction(interaction) {
    return isDMInteraction(interaction);
  }
  function isMessageComponentGuildInteraction(interaction) {
    return isGuildInteraction(interaction);
  }
  function isLinkButton(component) {
    return component.style === index_1.ButtonStyle.Link;
  }
  function isInteractionButton(component) {
    return ![index_1.ButtonStyle.Link, index_1.ButtonStyle.Premium].includes(component.style);
  }
  function isMessageComponentInteraction(interaction) {
    return interaction.type === index_1.InteractionType.MessageComponent;
  }
  function isMessageComponentButtonInteraction(interaction) {
    return interaction.data.component_type === index_1.ComponentType.Button;
  }
  function isMessageComponentSelectMenuInteraction(interaction) {
    return [
      index_1.ComponentType.StringSelect,
      index_1.ComponentType.UserSelect,
      index_1.ComponentType.RoleSelect,
      index_1.ComponentType.MentionableSelect,
      index_1.ComponentType.ChannelSelect
    ].includes(interaction.data.component_type);
  }
  function isChatInputApplicationCommandInteraction(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.ChatInput;
  }
  function isContextMenuApplicationCommandInteraction(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.Message || interaction.data.type === index_1.ApplicationCommandType.User;
  }
});

// ../../node_modules/discord-api-types/v10.js
var require_v106 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Utils = undefined;
  __exportStar(require_v10(), exports);
  __exportStar(require_globals(), exports);
  __exportStar(require_v102(), exports);
  __exportStar(require_v103(), exports);
  __exportStar(require_v104(), exports);
  __exportStar(require_internals(), exports);
  exports.Utils = require_v105();
});

// ../../node_modules/@discordjs/rest/node_modules/@discordjs/collection/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    findLast(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const val = entries[index][1];
        const key = entries[index][0];
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findLastKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const key = entries[index][0];
        const val = entries[index][1];
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    reduceRight(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      const entries = [...this.entries()];
      let accumulator;
      let index;
      if (initialValue === undefined) {
        if (entries.length === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = entries[entries.length - 1][1];
        index = entries.length - 1;
      } else {
        accumulator = initialValue;
        index = entries.length;
      }
      while (--index >= 0) {
        const key = entries[index][0];
        const val = entries[index][1];
        accumulator = fn(accumulator, val, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersection(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    union(other) {
      const coll = new this.constructor[Symbol.species](this);
      for (const [key, value] of other) {
        if (!coll.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    symmetricDifference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    toReversed() {
      return new this.constructor[Symbol.species](this).reverse();
    }
    toSorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.entries()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "2.1.1";
});

// ../../node_modules/@sapphire/snowflake/dist/cjs/index.cjs
var require_cjs = __commonJS((exports) => {
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var IncrementSymbol = Symbol("@sapphire/snowflake.increment");
  var EpochSymbol = Symbol("@sapphire/snowflake.epoch");
  var ProcessIdSymbol = Symbol("@sapphire/snowflake.processId");
  var WorkerIdSymbol = Symbol("@sapphire/snowflake.workerId");
  var MaximumWorkerId = 0b11111n;
  var MaximumProcessId = 0b11111n;
  var MaximumIncrement = 0b111111111111n;
  var _a;
  var _b;
  var _c;
  var _d;
  var _Snowflake = class _Snowflake2 {
    constructor(epoch) {
      __publicField(this, "decode", this.deconstruct);
      __publicField(this, _a);
      __publicField(this, _b, 0n);
      __publicField(this, _c, 1n);
      __publicField(this, _d, 0n);
      this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);
    }
    get epoch() {
      return this[EpochSymbol];
    }
    get processId() {
      return this[ProcessIdSymbol];
    }
    set processId(value) {
      this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;
    }
    get workerId() {
      return this[WorkerIdSymbol];
    }
    set workerId(value) {
      this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;
    }
    generate({
      increment,
      timestamp = Date.now(),
      workerId = this[WorkerIdSymbol],
      processId = this[ProcessIdSymbol]
    } = {}) {
      if (timestamp instanceof Date)
        timestamp = BigInt(timestamp.getTime());
      else if (typeof timestamp === "number")
        timestamp = BigInt(timestamp);
      else if (typeof timestamp !== "bigint") {
        throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp})`);
      }
      if (typeof increment !== "bigint") {
        increment = this[IncrementSymbol];
        this[IncrementSymbol] = increment + 1n & MaximumIncrement;
      }
      return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;
    }
    deconstruct(id) {
      const bigIntId = BigInt(id);
      const epoch = this[EpochSymbol];
      return {
        id: bigIntId,
        timestamp: (bigIntId >> 22n) + epoch,
        workerId: bigIntId >> 17n & MaximumWorkerId,
        processId: bigIntId >> 12n & MaximumProcessId,
        increment: bigIntId & MaximumIncrement,
        epoch
      };
    }
    timestampFrom(id) {
      return Number((BigInt(id) >> 22n) + this[EpochSymbol]);
    }
    static compare(a, b) {
      const typeA = typeof a;
      return typeA === typeof b ? typeA === "string" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));
    }
  };
  _a = EpochSymbol, _b = IncrementSymbol, _c = ProcessIdSymbol, _d = WorkerIdSymbol;
  __name(_Snowflake, "Snowflake");
  var Snowflake = _Snowflake;
  function cmpBigInt(a, b) {
    return a === b ? 0 : a < b ? -1 : 1;
  }
  __name(cmpBigInt, "cmpBigInt");
  function cmpString(a, b) {
    return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;
  }
  __name(cmpString, "cmpString");
  var DiscordSnowflake = new Snowflake(1420070400000n);
  var TwitterSnowflake = new Snowflake(1288834974657n);
  exports.DiscordSnowflake = DiscordSnowflake;
  exports.MaximumIncrement = MaximumIncrement;
  exports.MaximumProcessId = MaximumProcessId;
  exports.MaximumWorkerId = MaximumWorkerId;
  exports.Snowflake = Snowflake;
  exports.TwitterSnowflake = TwitterSnowflake;
});

// ../../node_modules/@vladfrangu/async_event_emitter/dist/index.cjs
var require_dist3 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
  };
  var __commonJS2 = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var init_cjs_shims = __esm({
    "node_modules/tsup/assets/cjs_shims.js"() {}
  });
  var require_inspect = __commonJS2({
    "node_modules/node-inspect-extracted/dist/inspect.js"(exports2, module2) {
      init_cjs_shims();
      (function(t, e) {
        typeof exports2 == "object" && typeof module2 == "object" ? module2.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof exports2 == "object" ? exports2.util = e() : t.util = e();
      })(exports2, () => (() => {
        var t = { 22: (t2) => {
          t2.exports = { CHAR_DOT: 46, CHAR_FORWARD_SLASH: 47, CHAR_BACKWARD_SLASH: 92 };
        }, 24: (t2) => {
          t2.exports = URL;
        }, 33: (t2, e2, r) => {
          function n(t3) {
            return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
              return typeof t4;
            } : function(t4) {
              return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
            }, n(t3);
          }
          __name(n, "n");
          function o(t3, e3) {
            var r2 = typeof Symbol != "undefined" && t3[Symbol.iterator] || t3["@@iterator"];
            if (!r2) {
              if (Array.isArray(t3) || (r2 = function(t4, e4) {
                if (t4) {
                  if (typeof t4 == "string")
                    return a(t4, e4);
                  var r3 = {}.toString.call(t4).slice(8, -1);
                  return r3 === "Object" && t4.constructor && (r3 = t4.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(t4) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? a(t4, e4) : undefined;
                }
              }(t3)) || e3 && t3 && typeof t3.length == "number") {
                r2 && (t3 = r2);
                var n2 = 0, o2 = /* @__PURE__ */ __name(function() {}, "o");
                return { s: o2, n: /* @__PURE__ */ __name(function() {
                  return n2 >= t3.length ? { done: true } : { done: false, value: t3[n2++] };
                }, "n"), e: /* @__PURE__ */ __name(function(t4) {
                  throw t4;
                }, "e"), f: o2 };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var i2, c2 = true, u2 = false;
            return { s: /* @__PURE__ */ __name(function() {
              r2 = r2.call(t3);
            }, "s"), n: /* @__PURE__ */ __name(function() {
              var t4 = r2.next();
              return c2 = t4.done, t4;
            }, "n"), e: /* @__PURE__ */ __name(function(t4) {
              u2 = true, i2 = t4;
            }, "e"), f: /* @__PURE__ */ __name(function() {
              try {
                c2 || r2.return == null || r2.return();
              } finally {
                if (u2)
                  throw i2;
              }
            }, "f") };
          }
          __name(o, "o");
          function a(t3, e3) {
            (e3 == null || e3 > t3.length) && (e3 = t3.length);
            for (var r2 = 0, n2 = Array(e3);r2 < e3; r2++)
              n2[r2] = t3[r2];
            return n2;
          }
          __name(a, "a");
          function i(t3, e3) {
            var r2 = Object.keys(t3);
            if (Object.getOwnPropertySymbols) {
              var n2 = Object.getOwnPropertySymbols(t3);
              e3 && (n2 = n2.filter(function(e4) {
                return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
              })), r2.push.apply(r2, n2);
            }
            return r2;
          }
          __name(i, "i");
          function c(t3) {
            for (var e3 = 1;e3 < arguments.length; e3++) {
              var r2 = arguments[e3] != null ? arguments[e3] : {};
              e3 % 2 ? i(Object(r2), true).forEach(function(e4) {
                u(t3, e4, r2[e4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r2)) : i(Object(r2)).forEach(function(e4) {
                Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(r2, e4));
              });
            }
            return t3;
          }
          __name(c, "c");
          function u(t3, e3, r2) {
            return (e3 = function(t4) {
              var e4 = function(t5) {
                if (n(t5) != "object" || !t5)
                  return t5;
                var e5 = t5[Symbol.toPrimitive];
                if (e5 !== undefined) {
                  var r3 = e5.call(t5, "string");
                  if (n(r3) != "object")
                    return r3;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t5);
              }(t4);
              return n(e4) == "symbol" ? e4 : e4 + "";
            }(e3)) in t3 ? Object.defineProperty(t3, e3, { value: r2, enumerable: true, configurable: true, writable: true }) : t3[e3] = r2, t3;
          }
          __name(u, "u");
          var l, f, s, y = r(425), p = y.AggregateError, g = y.AggregateErrorPrototype, v = y.Array, h = y.ArrayBuffer, d = y.ArrayBufferPrototype, b = y.ArrayIsArray, m = y.ArrayPrototype, S = y.ArrayPrototypeFilter, P = y.ArrayPrototypeForEach, x = y.ArrayPrototypeIncludes, w = y.ArrayPrototypeIndexOf, A = y.ArrayPrototypeJoin, O = y.ArrayPrototypeMap, _ = y.ArrayPrototypePop, j = y.ArrayPrototypePush, E = y.ArrayPrototypePushApply, k = y.ArrayPrototypeSlice, I = y.ArrayPrototypeSort, R = y.ArrayPrototypeSplice, L = y.ArrayPrototypeUnshift, T = y.BigIntPrototypeValueOf, B = y.Boolean, z = y.BooleanPrototype, M = y.BooleanPrototypeValueOf, C = y.DataView, D = y.DataViewPrototype, N = y.Date, F = y.DatePrototype, W = y.DatePrototypeGetTime, H = y.DatePrototypeToISOString, U = y.DatePrototypeToString, G = y.Error, V = y.ErrorPrototype, Z = y.ErrorPrototypeToString, $ = y.Function, Y = y.FunctionPrototype, q = y.FunctionPrototypeBind, J = y.FunctionPrototypeCall, K = y.FunctionPrototypeSymbolHasInstance, Q = y.FunctionPrototypeToString, X = y.JSONStringify, tt = y.Map, et = y.MapPrototype, rt = y.MapPrototypeEntries, nt = y.MapPrototypeGetSize, ot = y.MathFloor, at = y.MathMax, it = y.MathMin, ct = y.MathRound, ut = y.MathSqrt, lt = y.MathTrunc, ft = y.Number, st = y.NumberIsFinite, yt = y.NumberIsNaN, pt = y.NumberParseFloat, gt = y.NumberParseInt, vt = y.NumberPrototype, ht = y.NumberPrototypeToString, dt = y.NumberPrototypeValueOf, bt = y.Object, mt = y.ObjectAssign, St = y.ObjectDefineProperty, Pt = y.ObjectGetOwnPropertyDescriptor, xt = y.ObjectGetOwnPropertyNames, wt = y.ObjectGetOwnPropertySymbols, At = y.ObjectGetPrototypeOf, Ot = y.ObjectIs, _t = y.ObjectKeys, jt = y.ObjectPrototype, Et = y.ObjectPrototypeHasOwnProperty, kt = y.ObjectPrototypePropertyIsEnumerable, It = y.ObjectSeal, Rt = y.ObjectSetPrototypeOf, Lt = y.Promise, Tt = y.PromisePrototype, Bt = y.RangeError, zt = y.RangeErrorPrototype, Mt = y.ReflectApply, Ct = y.ReflectOwnKeys, Dt = y.RegExp, Nt = y.RegExpPrototype, Ft = y.RegExpPrototypeExec, Wt = y.RegExpPrototypeSymbolReplace, Ht = y.RegExpPrototypeSymbolSplit, Ut = y.RegExpPrototypeToString, Gt = y.SafeMap, Vt = y.SafeSet, Zt = y.SafeStringIterator, $t = y.Set, Yt = y.SetPrototype, qt = y.SetPrototypeGetSize, Jt = y.SetPrototypeValues, Kt = y.String, Qt = y.StringPrototype, Xt = y.StringPrototypeCharCodeAt, te = y.StringPrototypeCodePointAt, ee = y.StringPrototypeEndsWith, re = y.StringPrototypeIncludes, ne = y.StringPrototypeIndexOf, oe = y.StringPrototypeLastIndexOf, ae = y.StringPrototypeNormalize, ie = y.StringPrototypePadEnd, ce = y.StringPrototypePadStart, ue = y.StringPrototypeRepeat, le = y.StringPrototypeReplace, fe = y.StringPrototypeReplaceAll, se = y.StringPrototypeSlice, ye = y.StringPrototypeSplit, pe = y.StringPrototypeStartsWith, ge = y.StringPrototypeToLowerCase, ve = y.StringPrototypeTrim, he = y.StringPrototypeValueOf, de = y.SymbolIterator, be = y.SymbolPrototypeToString, me = y.SymbolPrototypeValueOf, Se = y.SymbolToPrimitive, Pe = y.SymbolToStringTag, xe = y.TypeError, we = y.TypeErrorPrototype, Ae = y.TypedArray, Oe = y.TypedArrayPrototype, _e = y.TypedArrayPrototypeGetLength, je = y.TypedArrayPrototypeGetSymbolToStringTag, Ee = y.Uint8Array, ke = y.WeakMap, Ie = y.WeakMapPrototype, Re = y.WeakSet, Le = y.WeakSetPrototype, Te = y.globalThis, Be = y.internalBinding, ze = y.uncurryThis, Me = r(153), Ce = Me.constants, De = Ce.ALL_PROPERTIES, Ne = Ce.ONLY_ENUMERABLE, Fe = Ce.kPending, We = Ce.kRejected, He = Me.getOwnNonIndexProperties, Ue = Me.getPromiseDetails, Ge = Me.getProxyDetails, Ve = Me.previewEntries, Ze = Me.getConstructorName, $e = Me.getExternalValue, Ye = Me.Proxy, qe = r(923), Je = qe.customInspectSymbol, Ke = qe.isError, Qe = qe.join, Xe = qe.removeColors, tr = r(924).isStackOverflowError, er = r(617), rr = er.isAsyncFunction, nr = er.isGeneratorFunction, or = er.isAnyArrayBuffer, ar = er.isArrayBuffer, ir = er.isArgumentsObject, cr = er.isBoxedPrimitive, ur = er.isDataView, lr = er.isExternal, fr = er.isMap, sr = er.isMapIterator, yr = er.isModuleNamespaceObject, pr = er.isNativeError, gr = er.isPromise, vr = er.isSet, hr = er.isSetIterator, dr = er.isWeakMap, br = er.isWeakSet, mr = er.isRegExp, Sr = er.isDate, Pr = er.isTypedArray, xr = er.isStringObject, wr = er.isNumberObject, Ar = er.isBooleanObject, Or = er.isBigIntObject, _r = r(229), jr = r(705).BuiltinModule, Er = r(116), kr = Er.validateObject, Ir = Er.validateString, Rr = Er.kValidateObjectAllowArray;
          function Lr(t3) {
            return (f = f || r(802)).pathToFileURL(t3).href;
          }
          __name(Lr, "Lr");
          var Tr, Br, zr, Mr, Cr, Dr = new Vt(S(xt(Te), function(t3) {
            return Ft(/^[A-Z][a-zA-Z0-9]+$/, t3) !== null;
          })), Nr = /* @__PURE__ */ __name(function(t3) {
            return t3 === undefined && t3 !== undefined;
          }, "Nr"), Fr = It({ showHidden: false, depth: 2, colors: false, customInspect: true, showProxy: false, maxArrayLength: 100, maxStringLength: 1e4, breakLength: 80, compact: 3, sorted: false, getters: false, numericSeparator: false });
          try {
            Tr = new Dt("[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]"), Br = new Dt("[\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]", "g"), zr = new Dt("[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]"), Mr = new Dt("[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]", "g");
            var Wr = new Dt("(?<=\\n)");
            Cr = /* @__PURE__ */ __name(function(t3) {
              return Ht(Wr, t3);
            }, "Cr");
          } catch (t3) {
            Tr = /[\x00-\x1f\x27\x5c\x7f-\x9f]/, Br = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g, zr = /[\x00-\x1f\x5c\x7f-\x9f]/, Mr = /[\x00-\x1f\x5c\x7f-\x9f]/g, Cr = /* @__PURE__ */ __name(function(t4) {
              var e3 = Ht(/\n/, t4), r2 = _(e3), n2 = O(e3, function(t5) {
                return t5 + `
`;
              });
              return r2 !== "" && n2.push(r2), n2;
            }, "Cr");
          }
          var Hr, Ur = /^[a-zA-Z_][a-zA-Z_0-9]*$/, Gr = /^(0|[1-9][0-9]*)$/, Vr = /^ {4}at (?:[^/\\(]+ \(|)node:(.+):\d+:\d+\)?$/, Zr = /^(\s+[^(]*?)\s*{/, $r = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g, Yr = ["\\x00", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\x07", "\\b", "\\t", "\\n", "\\x0B", "\\f", "\\r", "\\x0E", "\\x0F", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1A", "\\x1B", "\\x1C", "\\x1D", "\\x1E", "\\x1F", "", "", "", "", "", "", "", "\\'", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\\\", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\x7F", "\\x80", "\\x81", "\\x82", "\\x83", "\\x84", "\\x85", "\\x86", "\\x87", "\\x88", "\\x89", "\\x8A", "\\x8B", "\\x8C", "\\x8D", "\\x8E", "\\x8F", "\\x90", "\\x91", "\\x92", "\\x93", "\\x94", "\\x95", "\\x96", "\\x97", "\\x98", "\\x99", "\\x9A", "\\x9B", "\\x9C", "\\x9D", "\\x9E", "\\x9F"], qr = new Dt("[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/\\#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/\\#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", "g");
          function Jr(t3, e3) {
            var r2 = { budget: {}, indentationLvl: 0, seen: [], currentDepth: 0, stylize: on, showHidden: Fr.showHidden, depth: Fr.depth, colors: Fr.colors, customInspect: Fr.customInspect, showProxy: Fr.showProxy, maxArrayLength: Fr.maxArrayLength, maxStringLength: Fr.maxStringLength, breakLength: Fr.breakLength, compact: Fr.compact, sorted: Fr.sorted, getters: Fr.getters, numericSeparator: Fr.numericSeparator };
            if (arguments.length > 1) {
              if (arguments.length > 2 && (arguments[2] !== undefined && (r2.depth = arguments[2]), arguments.length > 3 && arguments[3] !== undefined && (r2.colors = arguments[3])), typeof e3 == "boolean")
                r2.showHidden = e3;
              else if (e3)
                for (var n2 = _t(e3), o2 = 0;o2 < n2.length; ++o2) {
                  var a2 = n2[o2];
                  Et(Fr, a2) || a2 === "stylize" ? r2[a2] = e3[a2] : r2.userOptions === undefined && (r2.userOptions = e3);
                }
            }
            return r2.colors && (r2.stylize = nn), r2.maxArrayLength === null && (r2.maxArrayLength = 1 / 0), r2.maxStringLength === null && (r2.maxStringLength = 1 / 0), gn(r2, t3, 0);
          }
          __name(Jr, "Jr");
          Jr.custom = Je, St(Jr, "defaultOptions", { __proto__: null, get: /* @__PURE__ */ __name(function() {
            return Fr;
          }, "get"), set: /* @__PURE__ */ __name(function(t3) {
            return kr(t3, "options"), mt(Fr, t3);
          }, "set") });
          var Kr = 39, Qr = 49;
          function Xr(t3, e3) {
            St(Jr.colors, e3, { __proto__: null, get: /* @__PURE__ */ __name(function() {
              return this[t3];
            }, "get"), set: /* @__PURE__ */ __name(function(e4) {
              this[t3] = e4;
            }, "set"), configurable: true, enumerable: false });
          }
          __name(Xr, "Xr");
          function tn(t3, e3) {
            return e3 === -1 ? '"'.concat(t3, '"') : e3 === -2 ? "`".concat(t3, "`") : "'".concat(t3, "'");
          }
          __name(tn, "tn");
          function en(t3) {
            var e3 = Xt(t3);
            return Yr.length > e3 ? Yr[e3] : "\\u".concat(ht(e3, 16));
          }
          __name(en, "en");
          function rn(t3) {
            var e3 = Tr, r2 = Br, n2 = 39;
            if (re(t3, "'") && (re(t3, '"') ? re(t3, "`") || re(t3, "${") || (n2 = -2) : n2 = -1, n2 !== 39 && (e3 = zr, r2 = Mr)), t3.length < 5000 && Ft(e3, t3) === null)
              return tn(t3, n2);
            if (t3.length > 100)
              return tn(t3 = Wt(r2, t3, en), n2);
            for (var o2 = "", a2 = 0, i2 = 0;i2 < t3.length; i2++) {
              var c2 = Xt(t3, i2);
              if (c2 === n2 || c2 === 92 || c2 < 32 || c2 > 126 && c2 < 160)
                o2 += a2 === i2 ? Yr[c2] : "".concat(se(t3, a2, i2)).concat(Yr[c2]), a2 = i2 + 1;
              else if (c2 >= 55296 && c2 <= 57343) {
                if (c2 <= 56319 && i2 + 1 < t3.length) {
                  var u2 = Xt(t3, i2 + 1);
                  if (u2 >= 56320 && u2 <= 57343) {
                    i2++;
                    continue;
                  }
                }
                o2 += "".concat(se(t3, a2, i2), "\\u").concat(ht(c2, 16)), a2 = i2 + 1;
              }
            }
            return a2 !== t3.length && (o2 += se(t3, a2)), tn(o2, n2);
          }
          __name(rn, "rn");
          function nn(t3, e3) {
            var r2 = Jr.styles[e3];
            if (r2 !== undefined) {
              var n2 = Jr.colors[r2];
              if (n2 !== undefined)
                return "\x1B[".concat(n2[0], "m").concat(t3, "\x1B[").concat(n2[1], "m");
            }
            return t3;
          }
          __name(nn, "nn");
          function on(t3) {
            return t3;
          }
          __name(on, "on");
          function an() {
            return [];
          }
          __name(an, "an");
          function cn(t3, e3) {
            try {
              return t3 instanceof e3;
            } catch (t4) {
              return false;
            }
          }
          __name(cn, "cn");
          Jr.colors = { __proto__: null, reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], blink: [5, 25], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29], doubleunderline: [21, 24], black: [30, Kr], red: [31, Kr], green: [32, Kr], yellow: [33, Kr], blue: [34, Kr], magenta: [35, Kr], cyan: [36, Kr], white: [37, Kr], bgBlack: [40, Qr], bgRed: [41, Qr], bgGreen: [42, Qr], bgYellow: [43, Qr], bgBlue: [44, Qr], bgMagenta: [45, Qr], bgCyan: [46, Qr], bgWhite: [47, Qr], framed: [51, 54], overlined: [53, 55], gray: [90, Kr], redBright: [91, Kr], greenBright: [92, Kr], yellowBright: [93, Kr], blueBright: [94, Kr], magentaBright: [95, Kr], cyanBright: [96, Kr], whiteBright: [97, Kr], bgGray: [100, Qr], bgRedBright: [101, Qr], bgGreenBright: [102, Qr], bgYellowBright: [103, Qr], bgBlueBright: [104, Qr], bgMagentaBright: [105, Qr], bgCyanBright: [106, Qr], bgWhiteBright: [107, Qr] }, Xr("gray", "grey"), Xr("gray", "blackBright"), Xr("bgGray", "bgGrey"), Xr("bgGray", "bgBlackBright"), Xr("dim", "faint"), Xr("strikethrough", "crossedout"), Xr("strikethrough", "strikeThrough"), Xr("strikethrough", "crossedOut"), Xr("hidden", "conceal"), Xr("inverse", "swapColors"), Xr("inverse", "swapcolors"), Xr("doubleunderline", "doubleUnderline"), Jr.styles = mt({ __proto__: null }, { special: "cyan", number: "yellow", bigint: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", symbol: "green", date: "magenta", regexp: "red", module: "underline" });
          var un = new Gt().set(m, { name: "Array", constructor: v }).set(d, { name: "ArrayBuffer", constructor: h }).set(Y, { name: "Function", constructor: $ }).set(et, { name: "Map", constructor: tt }).set(Yt, { name: "Set", constructor: $t }).set(jt, { name: "Object", constructor: bt }).set(Oe, { name: "TypedArray", constructor: Ae }).set(Nt, { name: "RegExp", constructor: Dt }).set(F, { name: "Date", constructor: N }).set(D, { name: "DataView", constructor: C }).set(V, { name: "Error", constructor: G }).set(g, { name: "AggregateError", constructor: p }).set(zt, { name: "RangeError", constructor: Bt }).set(we, { name: "TypeError", constructor: xe }).set(z, { name: "Boolean", constructor: B }).set(vt, { name: "Number", constructor: ft }).set(Qt, { name: "String", constructor: Kt }).set(Tt, { name: "Promise", constructor: Lt }).set(Ie, { name: "WeakMap", constructor: ke }).set(Le, { name: "WeakSet", constructor: Re });
          function ln(t3, e3, r2, n2) {
            for (var o2, a2 = t3;t3 || Nr(t3); ) {
              var i2 = un.get(t3);
              if (i2 !== undefined) {
                var { name: u2, constructor: l2 } = i2;
                if (K(l2, a2))
                  return n2 !== undefined && o2 !== t3 && fn(e3, a2, o2 || a2, r2, n2), u2;
              }
              var f2 = Pt(t3, "constructor");
              if (f2 !== undefined && typeof f2.value == "function" && f2.value.name !== "" && cn(a2, f2.value))
                return n2 === undefined || o2 === t3 && Dr.has(f2.value.name) || fn(e3, a2, o2 || a2, r2, n2), Kt(f2.value.name);
              t3 = At(t3), o2 === undefined && (o2 = t3);
            }
            if (o2 === null)
              return null;
            var s2 = Ze(a2);
            if (r2 > e3.depth && e3.depth !== null)
              return "".concat(s2, " <Complex prototype>");
            var y2 = ln(o2, e3, r2 + 1, n2);
            return y2 === null ? "".concat(s2, " <").concat(Jr(o2, c(c({}, e3), {}, { customInspect: false, depth: -1 })), ">") : "".concat(s2, " <").concat(y2, ">");
          }
          __name(ln, "ln");
          function fn(t3, e3, r2, n2, a2) {
            var i2, c2, u2 = 0;
            do {
              if (u2 !== 0 || e3 === r2) {
                if ((r2 = At(r2)) === null)
                  return;
                var l2 = Pt(r2, "constructor");
                if (l2 !== undefined && typeof l2.value == "function" && Dr.has(l2.value.name))
                  return;
              }
              u2 === 0 ? c2 = new Vt : P(i2, function(t4) {
                return c2.add(t4);
              }), i2 = Ct(r2), j(t3.seen, e3);
              var f2, s2 = o(i2);
              try {
                for (s2.s();!(f2 = s2.n()).done; ) {
                  var y2 = f2.value;
                  if (!(y2 === "constructor" || Et(e3, y2) || u2 !== 0 && c2.has(y2))) {
                    var p2 = Pt(r2, y2);
                    if (typeof p2.value != "function") {
                      var g2 = Nn(t3, r2, n2, y2, 0, p2, e3);
                      t3.colors ? j(a2, "\x1B[2m".concat(g2, "\x1B[22m")) : j(a2, g2);
                    }
                  }
                }
              } catch (t4) {
                s2.e(t4);
              } finally {
                s2.f();
              }
              _(t3.seen);
            } while (++u2 !== 3);
          }
          __name(fn, "fn");
          function sn(t3, e3, r2) {
            var n2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            return t3 === null ? e3 !== "" && r2 !== e3 ? "[".concat(r2).concat(n2, ": null prototype] [").concat(e3, "] ") : "[".concat(r2).concat(n2, ": null prototype] ") : e3 !== "" && t3 !== e3 ? "".concat(t3).concat(n2, " [").concat(e3, "] ") : "".concat(t3).concat(n2, " ");
          }
          __name(sn, "sn");
          function yn(t3, e3) {
            var r2, n2 = wt(t3);
            if (e3)
              r2 = xt(t3), n2.length !== 0 && E(r2, n2);
            else {
              try {
                r2 = _t(t3);
              } catch (e4) {
                _r(pr(e4) && e4.name === "ReferenceError" && yr(t3)), r2 = xt(t3);
              }
              n2.length !== 0 && E(r2, S(n2, function(e4) {
                return kt(t3, e4);
              }));
            }
            return r2;
          }
          __name(yn, "yn");
          function pn(t3, e3, r2) {
            var n2 = "";
            return e3 === null && (n2 = Ze(t3)) === r2 && (n2 = "Object"), sn(e3, r2, n2);
          }
          __name(pn, "pn");
          function gn(t3, e3, a2, i2) {
            if (n(e3) !== "object" && typeof e3 != "function" && !Nr(e3))
              return An(t3.stylize, e3, t3);
            if (e3 === null)
              return t3.stylize("null", "null");
            var u2 = e3, l2 = Ge(e3, !!t3.showProxy);
            if (l2 !== undefined) {
              if (l2 === null || l2[0] === null)
                return t3.stylize("<Revoked Proxy>", "special");
              if (t3.showProxy)
                return function(t4, e4, r2) {
                  if (r2 > t4.depth && t4.depth !== null)
                    return t4.stylize("Proxy [Array]", "special");
                  r2 += 1, t4.indentationLvl += 2;
                  var n2 = [gn(t4, e4[0], r2), gn(t4, e4[1], r2)];
                  return t4.indentationLvl -= 2, Wn(t4, n2, "", ["Proxy [", "]"], 2, r2);
                }(t3, l2, a2);
              e3 = l2;
            }
            if (t3.customInspect) {
              var p2, g2 = e3[Je];
              if (typeof g2 == "function" && g2 !== Jr && ((p2 = Pt(e3, "constructor")) === null || p2 === undefined || (p2 = p2.value) === null || p2 === undefined ? undefined : p2.prototype) !== e3) {
                var v2 = t3.depth === null ? null : t3.depth - a2, h2 = l2 !== undefined || !K(bt, u2), d2 = J(g2, u2, v2, function(t4, e4) {
                  var r2 = c({ stylize: t4.stylize, showHidden: t4.showHidden, depth: t4.depth, colors: t4.colors, customInspect: t4.customInspect, showProxy: t4.showProxy, maxArrayLength: t4.maxArrayLength, maxStringLength: t4.maxStringLength, breakLength: t4.breakLength, compact: t4.compact, sorted: t4.sorted, getters: t4.getters, numericSeparator: t4.numericSeparator }, t4.userOptions);
                  if (e4) {
                    Rt(r2, null);
                    var a3, i3 = o(_t(r2));
                    try {
                      for (i3.s();!(a3 = i3.n()).done; ) {
                        var u3 = a3.value;
                        n(r2[u3]) !== "object" && typeof r2[u3] != "function" || r2[u3] === null || delete r2[u3];
                      }
                    } catch (t5) {
                      i3.e(t5);
                    } finally {
                      i3.f();
                    }
                    r2.stylize = Rt(function(e5, r3) {
                      var n2;
                      try {
                        n2 = "".concat(t4.stylize(e5, r3));
                      } catch (t5) {}
                      return typeof n2 != "string" ? e5 : n2;
                    }, null);
                  }
                  return r2;
                }(t3, h2), Jr);
                if (d2 !== u2)
                  return typeof d2 != "string" ? gn(t3, d2, a2) : fe(d2, `
`, `
`.concat(ue(" ", t3.indentationLvl)));
              }
            }
            if (t3.seen.includes(e3)) {
              var m2 = 1;
              return t3.circular === undefined ? (t3.circular = new Gt, t3.circular.set(e3, m2)) : (m2 = t3.circular.get(e3)) === undefined && (m2 = t3.circular.size + 1, t3.circular.set(e3, m2)), t3.stylize("[Circular *".concat(m2, "]"), "special");
            }
            return function(t4, e4, n2, a3) {
              var i3, c2;
              t4.showHidden && (n2 <= t4.depth || t4.depth === null) && (c2 = []);
              var u3 = ln(e4, t4, n2, c2);
              c2 !== undefined && c2.length === 0 && (c2 = undefined);
              var l3 = e4[Pe];
              (typeof l3 != "string" || l3 !== "" && (t4.showHidden ? Et : kt)(e4, Pe)) && (l3 = "");
              var p3, g3, v3 = "", h3 = an, d3 = true, m3 = 0, S2 = t4.showHidden ? De : Ne, P2 = 0;
              if (de in e4 || u3 === null)
                if (d3 = false, b(e4)) {
                  var O2 = u3 !== "Array" || l3 !== "" ? sn(u3, l3, "Array", "(".concat(e4.length, ")")) : "";
                  if (i3 = He(e4, S2), p3 = ["".concat(O2, "["), "]"], e4.length === 0 && i3.length === 0 && c2 === undefined)
                    return "".concat(p3[0], "]");
                  P2 = 2, h3 = En;
                } else if (vr(e4)) {
                  var _2 = qt(e4), B2 = sn(u3, l3, "Set", "(".concat(_2, ")"));
                  if (i3 = yn(e4, t4.showHidden), h3 = q(In, null, u3 !== null ? e4 : Jt(e4)), _2 === 0 && i3.length === 0 && c2 === undefined)
                    return "".concat(B2, "{}");
                  p3 = ["".concat(B2, "{"), "}"];
                } else if (fr(e4)) {
                  var z2 = nt(e4), C2 = sn(u3, l3, "Map", "(".concat(z2, ")"));
                  if (i3 = yn(e4, t4.showHidden), h3 = q(Rn, null, u3 !== null ? e4 : rt(e4)), z2 === 0 && i3.length === 0 && c2 === undefined)
                    return "".concat(C2, "{}");
                  p3 = ["".concat(C2, "{"), "}"];
                } else if (Pr(e4)) {
                  i3 = He(e4, S2);
                  var D2 = e4, N2 = "";
                  u3 === null && (N2 = je(e4), D2 = new y[N2](e4));
                  var F2 = _e(e4), G2 = sn(u3, l3, N2, "(".concat(F2, ")"));
                  if (p3 = ["".concat(G2, "["), "]"], e4.length === 0 && i3.length === 0 && !t4.showHidden)
                    return "".concat(p3[0], "]");
                  h3 = q(kn, null, D2, F2), P2 = 2;
                } else
                  sr(e4) ? (i3 = yn(e4, t4.showHidden), p3 = vn("Map", l3), h3 = q(Cn, null, p3)) : hr(e4) ? (i3 = yn(e4, t4.showHidden), p3 = vn("Set", l3), h3 = q(Cn, null, p3)) : d3 = true;
              if (d3) {
                if (i3 = yn(e4, t4.showHidden), p3 = ["{", "}"], typeof e4 == "function") {
                  if (v3 = function(t5, e5, r2, n3) {
                    var o2 = Q(e5);
                    if (pe(o2, "class") && o2[o2.length - 1] === "}") {
                      var a4 = se(o2, 5, -1), i4 = ne(a4, "{");
                      if (i4 !== -1 && (!re(se(a4, 0, i4), "(") || Ft(Zr, Wt($r, a4)) !== null))
                        return function(t6, e6, r3) {
                          var n4 = Et(t6, "name") && t6.name || "(anonymous)", o3 = "class ".concat(n4);
                          if (e6 !== "Function" && e6 !== null && (o3 += " [".concat(e6, "]")), r3 !== "" && e6 !== r3 && (o3 += " [".concat(r3, "]")), e6 !== null) {
                            var a5 = At(t6).name;
                            a5 && (o3 += " extends ".concat(a5));
                          } else
                            o3 += " extends [null prototype]";
                          return "[".concat(o3, "]");
                        }(e5, r2, n3);
                    }
                    var c3 = "Function";
                    nr(e5) && (c3 = "Generator".concat(c3)), rr(e5) && (c3 = "Async".concat(c3));
                    var u4 = "[".concat(c3);
                    return r2 === null && (u4 += " (null prototype)"), e5.name === "" ? u4 += " (anonymous)" : u4 += ": ".concat(typeof e5.name == "string" ? e5.name : gn(t5, e5.name)), u4 += "]", r2 !== c3 && r2 !== null && (u4 += " ".concat(r2)), n3 !== "" && r2 !== n3 && (u4 += " [".concat(n3, "]")), u4;
                  }(t4, e4, u3, l3), i3.length === 0 && c2 === undefined)
                    return t4.stylize(v3, "special");
                } else if (u3 === "Object") {
                  if (ir(e4) ? p3[0] = "[Arguments] {" : l3 !== "" && (p3[0] = "".concat(sn(u3, l3, "Object"), "{")), i3.length === 0 && c2 === undefined)
                    return "".concat(p3[0], "}");
                } else if (mr(e4)) {
                  v3 = Ut(u3 !== null ? e4 : new Dt(e4));
                  var V2 = sn(u3, l3, "RegExp");
                  if (V2 !== "RegExp " && (v3 = "".concat(V2).concat(v3)), i3.length === 0 && c2 === undefined || n2 > t4.depth && t4.depth !== null)
                    return t4.stylize(v3, "regexp");
                } else if (Sr(e4)) {
                  v3 = yt(W(e4)) ? U(e4) : H(e4);
                  var Z2 = sn(u3, l3, "Date");
                  if (Z2 !== "Date " && (v3 = "".concat(Z2).concat(v3)), i3.length === 0 && c2 === undefined)
                    return t4.stylize(v3, "date");
                } else if (Ke(e4)) {
                  if (v3 = function(t5, e5, r2, n3, a4) {
                    var i4 = t5.name != null ? t5.name : "Error", c3 = dn(n3, t5);
                    (function(t6, e6, r3, n4) {
                      if (!t6.showHidden && e6.length !== 0)
                        for (var o2 = 0, a5 = ["name", "message", "stack"];o2 < a5.length; o2++) {
                          var i5 = a5[o2], c4 = w(e6, i5);
                          c4 === -1 || typeof r3[i5] == "string" && !re(n4, r3[i5]) || R(e6, c4, 1);
                        }
                    })(n3, a4, t5, c3), !("cause" in t5) || a4.length !== 0 && x(a4, "cause") || j(a4, "cause"), !b(t5.errors) || a4.length !== 0 && x(a4, "errors") || j(a4, "errors"), c3 = function(t6, e6, r3, n4) {
                      var o2 = r3.length;
                      if (typeof r3 != "string" && (t6 = le(t6, "".concat(r3), "".concat(r3, " [").concat(se(sn(e6, n4, "Error"), 0, -1), "]"))), e6 === null || ee(r3, "Error") && pe(t6, r3) && (t6.length === o2 || t6[o2] === ":" || t6[o2] === `
`)) {
                        var a5 = "Error";
                        if (e6 === null) {
                          var i5 = Ft(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/, t6) || Ft(/^([a-z_A-Z0-9-]*Error)$/, t6);
                          o2 = (a5 = (i5 == null ? undefined : i5[1]) || "").length, a5 = a5 || "Error";
                        }
                        var c4 = se(sn(e6, n4, a5), 0, -1);
                        r3 !== c4 && (t6 = re(c4, r3) ? o2 === 0 ? "".concat(c4, ": ").concat(t6) : "".concat(c4).concat(se(t6, o2)) : "".concat(c4, " [").concat(r3, "]").concat(se(t6, o2)));
                      }
                      return t6;
                    }(c3, e5, i4, r2);
                    var u4 = t5.message && ne(c3, t5.message) || -1;
                    u4 !== -1 && (u4 += t5.message.length);
                    var l4 = ne(c3, `
    at`, u4);
                    if (l4 === -1)
                      c3 = "[".concat(c3, "]");
                    else {
                      var f2 = se(c3, 0, l4), s2 = function(t6, e6, r3) {
                        var n4, o2 = ye(r3, `
`);
                        try {
                          n4 = e6.cause;
                        } catch (t7) {}
                        if (n4 != null && Ke(n4)) {
                          var a5 = dn(t6, n4), i5 = ne(a5, `
    at`);
                          if (i5 !== -1) {
                            var c4 = hn(o2, ye(se(a5, i5 + 1), `
`)), u5 = c4.len, l5 = c4.offset;
                            if (u5 > 0) {
                              var f3 = u5 - 2, s3 = "    ... ".concat(f3, " lines matching cause stack trace ...");
                              o2.splice(l5 + 1, f3, t6.stylize(s3, "undefined"));
                            }
                          }
                        }
                        return o2;
                      }(n3, t5, se(c3, l4 + 1));
                      if (n3.colors) {
                        var y2, p4, g4 = function() {
                          var t6;
                          try {
                            t6 = process.cwd();
                          } catch (t7) {
                            return;
                          }
                          return t6;
                        }(), v4 = o(s2);
                        try {
                          for (v4.s();!(p4 = v4.n()).done; ) {
                            var h4 = p4.value, d4 = Ft(Vr, h4);
                            if (d4 !== null && jr.exists(d4[1]))
                              f2 += `
`.concat(n3.stylize(h4, "undefined"));
                            else {
                              if (f2 += `
`, h4 = bn(n3, h4), g4 !== undefined) {
                                var m4 = mn(n3, h4, g4);
                                m4 === h4 && (m4 = mn(n3, h4, y2 = y2 || Lr(g4))), h4 = m4;
                              }
                              f2 += h4;
                            }
                          }
                        } catch (t6) {
                          v4.e(t6);
                        } finally {
                          v4.f();
                        }
                      } else
                        f2 += `
`.concat(A(s2, `
`));
                      c3 = f2;
                    }
                    if (n3.indentationLvl !== 0) {
                      var S3 = ue(" ", n3.indentationLvl);
                      c3 = fe(c3, `
`, `
`.concat(S3));
                    }
                    return c3;
                  }(e4, u3, l3, t4, i3), i3.length === 0 && c2 === undefined)
                    return v3;
                } else if (or(e4)) {
                  var $2 = sn(u3, l3, ar(e4) ? "ArrayBuffer" : "SharedArrayBuffer");
                  if (a3 === undefined)
                    h3 = jn;
                  else if (i3.length === 0 && c2 === undefined)
                    return $2 + "{ byteLength: ".concat(xn(t4.stylize, e4.byteLength, false), " }");
                  p3[0] = "".concat($2, "{"), L(i3, "byteLength");
                } else if (ur(e4))
                  p3[0] = "".concat(sn(u3, l3, "DataView"), "{"), L(i3, "byteLength", "byteOffset", "buffer");
                else if (gr(e4))
                  p3[0] = "".concat(sn(u3, l3, "Promise"), "{"), h3 = Dn;
                else if (br(e4))
                  p3[0] = "".concat(sn(u3, l3, "WeakSet"), "{"), h3 = t4.showHidden ? zn : Bn;
                else if (dr(e4))
                  p3[0] = "".concat(sn(u3, l3, "WeakMap"), "{"), h3 = t4.showHidden ? Mn : Bn;
                else if (yr(e4))
                  p3[0] = "".concat(sn(u3, l3, "Module"), "{"), h3 = On.bind(null, i3);
                else if (cr(e4)) {
                  if (v3 = function(t5, e5, r2, n3, o2) {
                    var a4, i4;
                    wr(t5) ? (a4 = dt, i4 = "Number") : xr(t5) ? (a4 = he, i4 = "String", r2.splice(0, t5.length)) : Ar(t5) ? (a4 = M, i4 = "Boolean") : Or(t5) ? (a4 = T, i4 = "BigInt") : (a4 = me, i4 = "Symbol");
                    var c3 = "[".concat(i4);
                    return i4 !== n3 && (c3 += n3 === null ? " (null prototype)" : " (".concat(n3, ")")), c3 += ": ".concat(An(on, a4(t5), e5), "]"), o2 !== "" && o2 !== n3 && (c3 += " [".concat(o2, "]")), r2.length !== 0 || e5.stylize === on ? c3 : e5.stylize(c3, ge(i4));
                  }(e4, t4, i3, u3, l3), i3.length === 0 && c2 === undefined)
                    return v3;
                } else if (!function(t5) {
                  return f = f || r(802), typeof t5.href == "string" && t5 instanceof f.URL;
                }(e4) || n2 > t4.depth && t4.depth !== null) {
                  if (i3.length === 0 && c2 === undefined) {
                    if (lr(e4)) {
                      var Y2 = $e(e4).toString(16);
                      return t4.stylize("[External: ".concat(Y2, "]"), "special");
                    }
                    return "".concat(pn(e4, u3, l3), "{}");
                  }
                  p3[0] = "".concat(pn(e4, u3, l3), "{");
                } else if (i3 = function(t5) {
                  return s = s || wt(new f.URL("http://user:pass@localhost:8080/?foo=bar#baz")), t5.filter(function(t6) {
                    return s[t6] === -1;
                  });
                }(i3), v3 = e4.href, i3.length === 0 && c2 === undefined)
                  return v3;
              }
              if (n2 > t4.depth && t4.depth !== null) {
                var J2 = se(pn(e4, u3, l3), 0, -1);
                return u3 !== null && (J2 = "[".concat(J2, "]")), t4.stylize(J2, "special");
              }
              n2 += 1, t4.seen.push(e4), t4.currentDepth = n2;
              var K2 = t4.indentationLvl;
              try {
                for (g3 = h3(t4, e4, n2), m3 = 0;m3 < i3.length; m3++)
                  j(g3, Nn(t4, e4, n2, i3[m3], P2));
                c2 !== undefined && E(g3, c2);
              } catch (r2) {
                if (!tr(r2))
                  throw r2;
                return function(t5, e5, r3, n3) {
                  return t5.seen.pop(), t5.indentationLvl = n3, t5.stylize("[".concat(r3, ": Inspection interrupted ") + "prematurely. Maximum call stack size exceeded.]", "special");
                }(t4, 0, se(pn(e4, u3, l3), 0, -1), K2);
              }
              if (t4.circular !== undefined) {
                var X2 = t4.circular.get(e4);
                if (X2 !== undefined) {
                  var tt2 = t4.stylize("<ref *".concat(X2, ">"), "special");
                  t4.compact !== true ? v3 = v3 === "" ? tt2 : "".concat(tt2, " ").concat(v3) : p3[0] = "".concat(tt2, " ").concat(p3[0]);
                }
              }
              if (t4.seen.pop(), t4.sorted) {
                var et2 = t4.sorted === true ? undefined : t4.sorted;
                if (P2 === 0)
                  I(g3, et2);
                else if (i3.length > 1) {
                  var ot2 = I(k(g3, g3.length - i3.length), et2);
                  L(ot2, g3, g3.length - i3.length, i3.length), Mt(R, null, ot2);
                }
              }
              var at2 = Wn(t4, g3, v3, p3, P2, n2, e4), it2 = (t4.budget[t4.indentationLvl] || 0) + at2.length;
              return t4.budget[t4.indentationLvl] = it2, it2 > Math.pow(2, 27) && (t4.depth = -1), at2;
            }(t3, e3, a2, i2);
          }
          __name(gn, "gn");
          function vn(t3, e3) {
            return e3 !== "".concat(t3, " Iterator") && (e3 !== "" && (e3 += "] ["), e3 += "".concat(t3, " Iterator")), ["[".concat(e3, "] {"), "}"];
          }
          __name(vn, "vn");
          function hn(t3, e3) {
            for (var r2 = 0;r2 < t3.length - 3; r2++) {
              var n2 = w(e3, t3[r2]);
              if (n2 !== -1) {
                var o2 = e3.length - n2;
                if (o2 > 3) {
                  for (var a2 = 1, i2 = it(t3.length - r2, o2);i2 > a2 && t3[r2 + a2] === e3[n2 + a2]; )
                    a2++;
                  if (a2 > 3)
                    return { len: a2, offset: r2 };
                }
              }
            }
            return { len: 0, offset: 0 };
          }
          __name(hn, "hn");
          function dn(t3, e3) {
            if (e3.stack) {
              if (typeof e3.stack == "string")
                return e3.stack;
              t3.seen.push(e3), t3.indentationLvl += 4;
              var r2 = gn(t3, e3.stack);
              return t3.indentationLvl -= 4, t3.seen.pop(), "".concat(Z(e3), `
    `).concat(r2);
            }
            return Z(e3);
          }
          __name(dn, "dn");
          function bn(t3, e3) {
            for (var r2 = "", n2 = 0, o2 = 0;; ) {
              var a2 = ne(e3, "node_modules", o2);
              if (a2 === -1)
                break;
              var i2 = e3[a2 - 1], c2 = e3[a2 + 12];
              if (c2 !== "/" && c2 !== "\\" || i2 !== "/" && i2 !== "\\")
                o2 = a2 + 1;
              else {
                var u2 = a2 + 13;
                r2 += se(e3, n2, u2);
                var l2 = ne(e3, i2, u2);
                e3[u2] === "@" && (l2 = ne(e3, i2, l2 + 1));
                var f2 = se(e3, u2, l2);
                r2 += t3.stylize(f2, "module"), n2 = l2, o2 = l2;
              }
            }
            return n2 !== 0 && (e3 = r2 + se(e3, n2)), e3;
          }
          __name(bn, "bn");
          function mn(t3, e3, r2) {
            var n2 = ne(e3, r2), o2 = "", a2 = r2.length;
            if (n2 !== -1) {
              se(e3, n2 - 7, n2) === "file://" && (a2 += 7, n2 -= 7);
              var i2 = e3[n2 - 1] === "(" ? n2 - 1 : n2, c2 = i2 !== n2 && ee(e3, ")") ? -1 : e3.length, u2 = n2 + a2 + 1, l2 = se(e3, i2, u2);
              o2 += se(e3, 0, i2), o2 += t3.stylize(l2, "undefined"), o2 += se(e3, u2, c2), c2 === -1 && (o2 += t3.stylize(")", "undefined"));
            } else
              o2 += e3;
            return o2;
          }
          __name(mn, "mn");
          function Sn(t3) {
            var e3 = "", r2 = t3.length;
            _r(r2 !== 0);
            for (var n2 = t3[0] === "-" ? 1 : 0;r2 >= n2 + 4; r2 -= 3)
              e3 = "_".concat(se(t3, r2 - 3, r2)).concat(e3);
            return r2 === t3.length ? t3 : "".concat(se(t3, 0, r2)).concat(e3);
          }
          __name(Sn, "Sn");
          var Pn = /* @__PURE__ */ __name(function(t3) {
            return "... ".concat(t3, " more item").concat(t3 > 1 ? "s" : "");
          }, "Pn");
          function xn(t3, e3, r2) {
            if (!r2)
              return Ot(e3, -0) ? t3("-0", "number") : t3("".concat(e3), "number");
            var n2 = lt(e3), o2 = Kt(n2);
            return n2 === e3 ? !st(e3) || re(o2, "e") ? t3(o2, "number") : t3("".concat(Sn(o2)), "number") : yt(e3) ? t3(o2, "number") : t3("".concat(Sn(o2), ".").concat(function(t4) {
              for (var e4 = "", r3 = 0;r3 < t4.length - 3; r3 += 3)
                e4 += "".concat(se(t4, r3, r3 + 3), "_");
              return r3 === 0 ? t4 : "".concat(e4).concat(se(t4, r3));
            }(se(Kt(e3), o2.length + 1))), "number");
          }
          __name(xn, "xn");
          function wn(t3, e3, r2) {
            var n2 = Kt(e3);
            return t3("".concat(r2 ? Sn(n2) : n2, "n"), "bigint");
          }
          __name(wn, "wn");
          function An(t3, e3, r2) {
            if (typeof e3 == "string") {
              var n2 = "";
              if (e3.length > r2.maxStringLength) {
                var o2 = e3.length - r2.maxStringLength;
                e3 = se(e3, 0, r2.maxStringLength), n2 = "... ".concat(o2, " more character").concat(o2 > 1 ? "s" : "");
              }
              return r2.compact !== true && e3.length > 16 && e3.length > r2.breakLength - r2.indentationLvl - 4 ? A(O(Cr(e3), function(e4) {
                return t3(rn(e4), "string");
              }), ` +
`.concat(ue(" ", r2.indentationLvl + 2))) + n2 : t3(rn(e3), "string") + n2;
            }
            return typeof e3 == "number" ? xn(t3, e3, r2.numericSeparator) : typeof e3 == "bigint" ? wn(t3, e3, r2.numericSeparator) : typeof e3 == "boolean" ? t3("".concat(e3), "boolean") : e3 === undefined ? t3("undefined", "undefined") : t3(be(e3), "symbol");
          }
          __name(An, "An");
          function On(t3, e3, r2, n2) {
            for (var o2 = new v(t3.length), a2 = 0;a2 < t3.length; a2++)
              try {
                o2[a2] = Nn(e3, r2, n2, t3[a2], 0);
              } catch (r3) {
                _r(pr(r3) && r3.name === "ReferenceError");
                var i2 = u({}, t3[a2], "");
                o2[a2] = Nn(e3, i2, n2, t3[a2], 0);
                var c2 = oe(o2[a2], " ");
                o2[a2] = se(o2[a2], 0, c2 + 1) + e3.stylize("<uninitialized>", "special");
              }
            return t3.length = 0, o2;
          }
          __name(On, "On");
          function _n(t3, e3, r2, n2, o2, a2) {
            for (var i2 = _t(e3), c2 = a2;a2 < i2.length && o2.length < n2; a2++) {
              var u2 = i2[a2], l2 = +u2;
              if (l2 > Math.pow(2, 32) - 2)
                break;
              if ("".concat(c2) !== u2) {
                if (Ft(Gr, u2) === null)
                  break;
                var f2 = l2 - c2, s2 = f2 > 1 ? "s" : "", y2 = "<".concat(f2, " empty item").concat(s2, ">");
                if (j(o2, t3.stylize(y2, "undefined")), c2 = l2, o2.length === n2)
                  break;
              }
              j(o2, Nn(t3, e3, r2, u2, 1)), c2++;
            }
            var p2 = e3.length - c2;
            if (o2.length !== n2) {
              if (p2 > 0) {
                var g2 = p2 > 1 ? "s" : "", v2 = "<".concat(p2, " empty item").concat(g2, ">");
                j(o2, t3.stylize(v2, "undefined"));
              }
            } else
              p2 > 0 && j(o2, Pn(p2));
            return o2;
          }
          __name(_n, "_n");
          function jn(t3, e3) {
            var n2;
            try {
              n2 = new Ee(e3);
            } catch (e4) {
              return [t3.stylize("(detached)", "special")];
            }
            l === undefined && (l = ze(r(883).h.prototype.hexSlice));
            var o2 = ve(Wt(/(.{2})/g, l(n2, 0, it(t3.maxArrayLength, n2.length)), "$1 ")), a2 = n2.length - t3.maxArrayLength;
            return a2 > 0 && (o2 += " ... ".concat(a2, " more byte").concat(a2 > 1 ? "s" : "")), ["".concat(t3.stylize("[Uint8Contents]", "special"), ": <").concat(o2, ">")];
          }
          __name(jn, "jn");
          function En(t3, e3, r2) {
            for (var n2 = e3.length, o2 = it(at(0, t3.maxArrayLength), n2), a2 = n2 - o2, i2 = [], c2 = 0;c2 < o2; c2++) {
              if (!Et(e3, c2))
                return _n(t3, e3, r2, o2, i2, c2);
              j(i2, Nn(t3, e3, r2, c2, 1));
            }
            return a2 > 0 && j(i2, Pn(a2)), i2;
          }
          __name(En, "En");
          function kn(t3, e3, r2, n2, o2) {
            for (var a2 = it(at(0, r2.maxArrayLength), e3), i2 = t3.length - a2, c2 = new v(a2), u2 = t3.length > 0 && typeof t3[0] == "number" ? xn : wn, l2 = 0;l2 < a2; ++l2)
              c2[l2] = u2(r2.stylize, t3[l2], r2.numericSeparator);
            if (i2 > 0 && (c2[a2] = Pn(i2)), r2.showHidden) {
              r2.indentationLvl += 2;
              for (var f2 = 0, s2 = ["BYTES_PER_ELEMENT", "length", "byteLength", "byteOffset", "buffer"];f2 < s2.length; f2++) {
                var y2 = s2[f2], p2 = gn(r2, t3[y2], o2, true);
                j(c2, "[".concat(y2, "]: ").concat(p2));
              }
              r2.indentationLvl -= 2;
            }
            return c2;
          }
          __name(kn, "kn");
          function In(t3, e3, r2, n2) {
            var a2 = t3.size, i2 = it(at(0, e3.maxArrayLength), a2), c2 = a2 - i2, u2 = [];
            e3.indentationLvl += 2;
            var l2, f2 = 0, s2 = o(t3);
            try {
              for (s2.s();!(l2 = s2.n()).done; ) {
                var y2 = l2.value;
                if (f2 >= i2)
                  break;
                j(u2, gn(e3, y2, n2)), f2++;
              }
            } catch (t4) {
              s2.e(t4);
            } finally {
              s2.f();
            }
            return c2 > 0 && j(u2, Pn(c2)), e3.indentationLvl -= 2, u2;
          }
          __name(In, "In");
          function Rn(t3, e3, r2, n2) {
            var a2 = t3.size, i2 = it(at(0, e3.maxArrayLength), a2), c2 = a2 - i2, u2 = [];
            e3.indentationLvl += 2;
            var l2, f2 = 0, s2 = o(t3);
            try {
              for (s2.s();!(l2 = s2.n()).done; ) {
                var y2 = l2.value, p2 = y2[0], g2 = y2[1];
                if (f2 >= i2)
                  break;
                j(u2, "".concat(gn(e3, p2, n2), " => ").concat(gn(e3, g2, n2))), f2++;
              }
            } catch (t4) {
              s2.e(t4);
            } finally {
              s2.f();
            }
            return c2 > 0 && j(u2, Pn(c2)), e3.indentationLvl -= 2, u2;
          }
          __name(Rn, "Rn");
          function Ln(t3, e3, r2, n2) {
            var o2 = at(t3.maxArrayLength, 0), a2 = it(o2, r2.length), i2 = new v(a2);
            t3.indentationLvl += 2;
            for (var c2 = 0;c2 < a2; c2++)
              i2[c2] = gn(t3, r2[c2], e3);
            t3.indentationLvl -= 2, n2 !== 0 || t3.sorted || I(i2);
            var u2 = r2.length - a2;
            return u2 > 0 && j(i2, Pn(u2)), i2;
          }
          __name(Ln, "Ln");
          function Tn(t3, e3, r2, n2) {
            var o2 = at(t3.maxArrayLength, 0), a2 = r2.length / 2, i2 = a2 - o2, c2 = it(o2, a2), u2 = new v(c2), l2 = 0;
            if (t3.indentationLvl += 2, n2 === 0) {
              for (;l2 < c2; l2++) {
                var f2 = 2 * l2;
                u2[l2] = "".concat(gn(t3, r2[f2], e3), " => ").concat(gn(t3, r2[f2 + 1], e3));
              }
              t3.sorted || I(u2);
            } else
              for (;l2 < c2; l2++) {
                var s2 = 2 * l2, y2 = [gn(t3, r2[s2], e3), gn(t3, r2[s2 + 1], e3)];
                u2[l2] = Wn(t3, y2, "", ["[", "]"], 2, e3);
              }
            return t3.indentationLvl -= 2, i2 > 0 && j(u2, Pn(i2)), u2;
          }
          __name(Tn, "Tn");
          function Bn(t3) {
            return [t3.stylize("<items unknown>", "special")];
          }
          __name(Bn, "Bn");
          function zn(t3, e3, r2) {
            return Ln(t3, r2, Ve(e3), 0);
          }
          __name(zn, "zn");
          function Mn(t3, e3, r2) {
            return Tn(t3, r2, Ve(e3), 0);
          }
          __name(Mn, "Mn");
          function Cn(t3, e3, r2, n2) {
            var o2 = Ve(r2, true), a2 = o2[0];
            return o2[1] ? (t3[0] = Wt(/ Iterator] {$/, t3[0], " Entries] {"), Tn(e3, n2, a2, 2)) : Ln(e3, n2, a2, 1);
          }
          __name(Cn, "Cn");
          function Dn(t3, e3, r2) {
            var n2, o2 = Ue(e3), a2 = o2[0], i2 = o2[1];
            if (a2 === Fe)
              n2 = [t3.stylize("<pending>", "special")];
            else {
              t3.indentationLvl += 2;
              var c2 = gn(t3, i2, r2);
              t3.indentationLvl -= 2, n2 = [a2 === We ? "".concat(t3.stylize("<rejected>", "special"), " ").concat(c2) : c2];
            }
            return n2;
          }
          __name(Dn, "Dn");
          function Nn(t3, e3, r2, o2, a2, i2) {
            var c2, u2, l2 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : e3, f2 = " ";
            if ((i2 = i2 || Pt(e3, o2) || { value: e3[o2], enumerable: true }).value !== undefined) {
              var s2 = t3.compact !== true || a2 !== 0 ? 2 : 3;
              t3.indentationLvl += s2, u2 = gn(t3, i2.value, r2), s2 === 3 && t3.breakLength < Hr(u2, t3.colors) && (f2 = `
`.concat(ue(" ", t3.indentationLvl))), t3.indentationLvl -= s2;
            } else if (i2.get !== undefined) {
              var y2 = i2.set !== undefined ? "Getter/Setter" : "Getter", p2 = t3.stylize, g2 = "special";
              if (t3.getters && (t3.getters === true || t3.getters === "get" && i2.set === undefined || t3.getters === "set" && i2.set !== undefined))
                try {
                  var v2 = J(i2.get, l2);
                  if (t3.indentationLvl += 2, v2 === null)
                    u2 = "".concat(p2("[".concat(y2, ":"), g2), " ").concat(p2("null", "null")).concat(p2("]", g2));
                  else if (n(v2) === "object")
                    u2 = "".concat(p2("[".concat(y2, "]"), g2), " ").concat(gn(t3, v2, r2));
                  else {
                    var h2 = An(p2, v2, t3);
                    u2 = "".concat(p2("[".concat(y2, ":"), g2), " ").concat(h2).concat(p2("]", g2));
                  }
                  t3.indentationLvl -= 2;
                } catch (t4) {
                  var d2 = "<Inspection threw (".concat(t4.message, ")>");
                  u2 = "".concat(p2("[".concat(y2, ":"), g2), " ").concat(d2).concat(p2("]", g2));
                }
              else
                u2 = t3.stylize("[".concat(y2, "]"), g2);
            } else
              u2 = i2.set !== undefined ? t3.stylize("[Setter]", "special") : t3.stylize("undefined", "undefined");
            if (a2 === 1)
              return u2;
            if (n(o2) === "symbol") {
              var b2 = Wt(Br, be(o2), en);
              c2 = t3.stylize(b2, "symbol");
            } else
              c2 = Ft(Ur, o2) !== null ? o2 === "__proto__" ? "['__proto__']" : t3.stylize(o2, "name") : t3.stylize(rn(o2), "string");
            return i2.enumerable === false && (c2 = "[".concat(c2, "]")), "".concat(c2, ":").concat(f2).concat(u2);
          }
          __name(Nn, "Nn");
          function Fn(t3, e3, r2, n2) {
            var o2 = e3.length + r2;
            if (o2 + e3.length > t3.breakLength)
              return false;
            for (var a2 = 0;a2 < e3.length; a2++)
              if (t3.colors ? o2 += Xe(e3[a2]).length : o2 += e3[a2].length, o2 > t3.breakLength)
                return false;
            return n2 === "" || !re(n2, `
`);
          }
          __name(Fn, "Fn");
          function Wn(t3, e3, r2, n2, o2, a2, i2) {
            if (t3.compact !== true) {
              if (typeof t3.compact == "number" && t3.compact >= 1) {
                var c2 = e3.length;
                if (o2 === 2 && c2 > 6 && (e3 = function(t4, e4, r3) {
                  var n3 = 0, o3 = 0, a3 = 0, i3 = e4.length;
                  t4.maxArrayLength < e4.length && i3--;
                  for (var c3 = new v(i3);a3 < i3; a3++) {
                    var u3 = Hr(e4[a3], t4.colors);
                    c3[a3] = u3, n3 += u3 + 2, o3 < u3 && (o3 = u3);
                  }
                  var l3 = o3 + 2;
                  if (3 * l3 + t4.indentationLvl < t4.breakLength && (n3 / l3 > 5 || o3 <= 6)) {
                    var f3 = ut(l3 - n3 / e4.length), s3 = at(l3 - 3 - f3, 1), y2 = it(ct(ut(2.5 * s3 * i3) / s3), ot((t4.breakLength - t4.indentationLvl) / l3), 4 * t4.compact, 15);
                    if (y2 <= 1)
                      return e4;
                    for (var p2 = [], g2 = [], h2 = 0;h2 < y2; h2++) {
                      for (var d2 = 0, b2 = h2;b2 < e4.length; b2 += y2)
                        c3[b2] > d2 && (d2 = c3[b2]);
                      d2 += 2, g2[h2] = d2;
                    }
                    var m2 = ce;
                    if (r3 !== undefined) {
                      for (var S2 = 0;S2 < e4.length; S2++)
                        if (typeof r3[S2] != "number" && typeof r3[S2] != "bigint") {
                          m2 = ie;
                          break;
                        }
                    }
                    for (var P2 = 0;P2 < i3; P2 += y2) {
                      for (var x2 = it(P2 + y2, i3), w2 = "", A2 = P2;A2 < x2 - 1; A2++) {
                        var O2 = g2[A2 - P2] + e4[A2].length - c3[A2];
                        w2 += m2("".concat(e4[A2], ", "), O2, " ");
                      }
                      if (m2 === ce) {
                        var _2 = g2[A2 - P2] + e4[A2].length - c3[A2] - 2;
                        w2 += ce(e4[A2], _2, " ");
                      } else
                        w2 += e4[A2];
                      j(p2, w2);
                    }
                    t4.maxArrayLength < e4.length && j(p2, e4[i3]), e4 = p2;
                  }
                  return e4;
                }(t3, e3, i2)), t3.currentDepth - a2 < t3.compact && c2 === e3.length && Fn(t3, e3, e3.length + t3.indentationLvl + n2[0].length + r2.length + 10, r2)) {
                  var u2 = Qe(e3, ", ");
                  if (!re(u2, `
`))
                    return "".concat(r2 ? "".concat(r2, " ") : "").concat(n2[0], " ").concat(u2) + " ".concat(n2[1]);
                }
              }
              var l2 = `
`.concat(ue(" ", t3.indentationLvl));
              return "".concat(r2 ? "".concat(r2, " ") : "").concat(n2[0]).concat(l2, "  ") + "".concat(Qe(e3, ",".concat(l2, "  "))).concat(l2).concat(n2[1]);
            }
            if (Fn(t3, e3, 0, r2))
              return "".concat(n2[0]).concat(r2 ? " ".concat(r2) : "", " ").concat(Qe(e3, ", "), " ") + n2[1];
            var f2 = ue(" ", t3.indentationLvl), s2 = r2 === "" && n2[0].length === 1 ? " " : "".concat(r2 ? " ".concat(r2) : "", `
`).concat(f2, "  ");
            return "".concat(n2[0]).concat(s2).concat(Qe(e3, `,
`.concat(f2, "  ")), " ").concat(n2[1]);
          }
          __name(Wn, "Wn");
          function Hn(t3) {
            var e3 = Ge(t3, false);
            if (e3 !== undefined) {
              if (e3 === null)
                return true;
              t3 = e3;
            }
            var r2 = Et, n2 = Et;
            if (typeof t3.toString != "function") {
              if (typeof t3[Se] != "function")
                return true;
              if (Et(t3, Se))
                return false;
              r2 = Un;
            } else {
              if (Et(t3, "toString"))
                return false;
              if (typeof t3[Se] != "function")
                n2 = Un;
              else if (Et(t3, Se))
                return false;
            }
            var o2 = t3;
            do {
              o2 = At(o2);
            } while (!r2(o2, "toString") && !n2(o2, Se));
            var a2 = Pt(o2, "constructor");
            return a2 !== undefined && typeof a2.value == "function" && Dr.has(a2.value.name);
          }
          __name(Hn, "Hn");
          function Un() {
            return false;
          }
          __name(Un, "Un");
          var Gn, Vn = /* @__PURE__ */ __name(function(t3) {
            return ye(t3.message, `
`, 1)[0];
          }, "Vn");
          function Zn(t3) {
            try {
              return X(t3);
            } catch (t4) {
              if (!Gn)
                try {
                  var e3 = {};
                  e3.a = e3, X(e3);
                } catch (t5) {
                  Gn = Vn(t5);
                }
              if (t4.name === "TypeError" && Vn(t4) === Gn)
                return "[Circular]";
              throw t4;
            }
          }
          __name(Zn, "Zn");
          function $n(t3, e3) {
            var r2;
            return xn(on, t3, (r2 = e3 == null ? undefined : e3.numericSeparator) !== null && r2 !== undefined ? r2 : Fr.numericSeparator);
          }
          __name($n, "$n");
          function Yn(t3, e3) {
            var r2;
            return wn(on, t3, (r2 = e3 == null ? undefined : e3.numericSeparator) !== null && r2 !== undefined ? r2 : Fr.numericSeparator);
          }
          __name(Yn, "Yn");
          function qn(t3, e3) {
            var r2 = e3[0], o2 = 0, a2 = "", i2 = "";
            if (typeof r2 == "string") {
              if (e3.length === 1)
                return r2;
              for (var u2, l2 = 0, f2 = 0;f2 < r2.length - 1; f2++)
                if (Xt(r2, f2) === 37) {
                  var s2 = Xt(r2, ++f2);
                  if (o2 + 1 !== e3.length) {
                    switch (s2) {
                      case 115:
                        var y2 = e3[++o2];
                        u2 = typeof y2 == "number" ? $n(y2, t3) : typeof y2 == "bigint" ? Yn(y2, t3) : n(y2) === "object" && y2 !== null && Hn(y2) ? Jr(y2, c(c({}, t3), {}, { compact: 3, colors: false, depth: 0 })) : Kt(y2);
                        break;
                      case 106:
                        u2 = Zn(e3[++o2]);
                        break;
                      case 100:
                        var p2 = e3[++o2];
                        u2 = typeof p2 == "bigint" ? Yn(p2, t3) : n(p2) === "symbol" ? "NaN" : $n(ft(p2), t3);
                        break;
                      case 79:
                        u2 = Jr(e3[++o2], t3);
                        break;
                      case 111:
                        u2 = Jr(e3[++o2], c(c({}, t3), {}, { showHidden: true, showProxy: true, depth: 4 }));
                        break;
                      case 105:
                        var g2 = e3[++o2];
                        u2 = typeof g2 == "bigint" ? Yn(g2, t3) : n(g2) === "symbol" ? "NaN" : $n(gt(g2), t3);
                        break;
                      case 102:
                        var v2 = e3[++o2];
                        u2 = n(v2) === "symbol" ? "NaN" : $n(pt(v2), t3);
                        break;
                      case 99:
                        o2 += 1, u2 = "";
                        break;
                      case 37:
                        a2 += se(r2, l2, f2), l2 = f2 + 1;
                        continue;
                      default:
                        continue;
                    }
                    l2 !== f2 - 1 && (a2 += se(r2, l2, f2 - 1)), a2 += u2, l2 = f2 + 1;
                  } else
                    s2 === 37 && (a2 += se(r2, l2, f2), l2 = f2 + 1);
                }
              l2 !== 0 && (o2++, i2 = " ", l2 < r2.length && (a2 += se(r2, l2)));
            }
            for (;o2 < e3.length; ) {
              var h2 = e3[o2];
              a2 += i2, a2 += typeof h2 != "string" ? Jr(h2, t3) : h2, i2 = " ", o2++;
            }
            return a2;
          }
          __name(qn, "qn");
          function Jn(t3) {
            return t3 <= 31 || t3 >= 127 && t3 <= 159 || t3 >= 768 && t3 <= 879 || t3 >= 8203 && t3 <= 8207 || t3 >= 8400 && t3 <= 8447 || t3 >= 65024 && t3 <= 65039 || t3 >= 65056 && t3 <= 65071 || t3 >= 917760 && t3 <= 917999;
          }
          __name(Jn, "Jn");
          if (Be("config").hasIntl)
            _r(false);
          else {
            Hr = /* @__PURE__ */ __name(function(t3) {
              var e3 = 0;
              (!(arguments.length > 1 && arguments[1] !== undefined) || arguments[1]) && (t3 = Qn(t3)), t3 = ae(t3, "NFC");
              var r2, n2 = o(new Zt(t3));
              try {
                for (n2.s();!(r2 = n2.n()).done; ) {
                  var a2 = r2.value, i2 = te(a2, 0);
                  Kn(i2) ? e3 += 2 : Jn(i2) || e3++;
                }
              } catch (t4) {
                n2.e(t4);
              } finally {
                n2.f();
              }
              return e3;
            }, "Hr");
            var Kn = /* @__PURE__ */ __name(function(t3) {
              return t3 >= 4352 && (t3 <= 4447 || t3 === 9001 || t3 === 9002 || t3 >= 11904 && t3 <= 12871 && t3 !== 12351 || t3 >= 12880 && t3 <= 19903 || t3 >= 19968 && t3 <= 42182 || t3 >= 43360 && t3 <= 43388 || t3 >= 44032 && t3 <= 55203 || t3 >= 63744 && t3 <= 64255 || t3 >= 65040 && t3 <= 65049 || t3 >= 65072 && t3 <= 65131 || t3 >= 65281 && t3 <= 65376 || t3 >= 65504 && t3 <= 65510 || t3 >= 110592 && t3 <= 110593 || t3 >= 127488 && t3 <= 127569 || t3 >= 127744 && t3 <= 128591 || t3 >= 131072 && t3 <= 262141);
            }, "Kn");
          }
          function Qn(t3) {
            return Ir(t3, "str"), Wt(qr, t3, "");
          }
          __name(Qn, "Qn");
          var Xn = { 34: "&quot;", 38: "&amp;", 39: "&apos;", 60: "&lt;", 62: "&gt;", 160: "&nbsp;" };
          function to(t3) {
            return t3.replace(/[\u0000-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u00FF]/g, function(t4) {
              var e3 = Kt(t4.charCodeAt(0));
              return Xn[e3] || "&#" + e3 + ";";
            });
          }
          __name(to, "to");
          t2.exports = { identicalSequenceRange: hn, inspect: Jr, inspectDefaultOptions: Fr, format: /* @__PURE__ */ __name(function() {
            for (var t3 = arguments.length, e3 = new Array(t3), r2 = 0;r2 < t3; r2++)
              e3[r2] = arguments[r2];
            return qn(undefined, e3);
          }, "format"), formatWithOptions: /* @__PURE__ */ __name(function(t3) {
            kr(t3, "inspectOptions", Rr);
            for (var e3 = arguments.length, r2 = new Array(e3 > 1 ? e3 - 1 : 0), n2 = 1;n2 < e3; n2++)
              r2[n2 - 1] = arguments[n2];
            return qn(t3, r2);
          }, "formatWithOptions"), getStringWidth: Hr, stripVTControlCharacters: Qn, isZeroWidthCodePoint: Jn, stylizeWithColor: nn, stylizeWithHTML: /* @__PURE__ */ __name(function(t3, e3) {
            var r2 = Jr.styles[e3];
            return r2 !== undefined ? '<span style="color:'.concat(r2, ';">').concat(to(t3), "</span>") : to(t3);
          }, "stylizeWithHTML"), Proxy: Ye };
        }, 116: (t2, e2, r) => {
          function n(t3) {
            return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
              return typeof t4;
            } : function(t4) {
              return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
            }, n(t3);
          }
          __name(n, "n");
          var o = r(425).ArrayIsArray, a = r(924), i = a.hideStackFrames, c = a.codes.ERR_INVALID_ARG_TYPE, u = i(function(t3, e3) {
            var r2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            if (r2 === 0) {
              if (t3 === null || o(t3))
                throw new c(e3, "Object", t3);
              if (n(t3) !== "object")
                throw new c(e3, "Object", t3);
            } else {
              if (!(1 & r2) && t3 === null)
                throw new c(e3, "Object", t3);
              if (!(2 & r2) && o(t3))
                throw new c(e3, "Object", t3);
              var a2 = !(4 & r2), i2 = n(t3);
              if (i2 !== "object" && (a2 || i2 !== "function"))
                throw new c(e3, "Object", t3);
            }
          });
          t2.exports = { kValidateObjectNone: 0, kValidateObjectAllowNullable: 1, kValidateObjectAllowArray: 2, kValidateObjectAllowFunction: 4, validateObject: u, validateString: /* @__PURE__ */ __name(function(t3, e3) {
            if (typeof t3 != "string")
              throw new c(e3, "string", t3);
          }, "validateString") };
        }, 153: (t2, e2, r) => {
          function n(t3) {
            return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
              return typeof t4;
            } : function(t4) {
              return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
            }, n(t3);
          }
          __name(n, "n");
          function o(t3, e3) {
            return function(t4) {
              if (Array.isArray(t4))
                return t4;
            }(t3) || function(t4, e4) {
              var r2 = t4 == null ? null : typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
              if (r2 != null) {
                var n2, o2, a2, i2, c2 = [], u2 = true, l2 = false;
                try {
                  if (a2 = (r2 = r2.call(t4)).next, e4 === 0) {
                    if (Object(r2) !== r2)
                      return;
                    u2 = false;
                  } else
                    for (;!(u2 = (n2 = a2.call(r2)).done) && (c2.push(n2.value), c2.length !== e4); u2 = true)
                      ;
                } catch (t5) {
                  l2 = true, o2 = t5;
                } finally {
                  try {
                    if (!u2 && r2.return != null && (i2 = r2.return(), Object(i2) !== i2))
                      return;
                  } finally {
                    if (l2)
                      throw o2;
                  }
                }
                return c2;
              }
            }(t3, e3) || i(t3, e3) || function() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }();
          }
          __name(o, "o");
          function a(t3, e3) {
            var r2 = typeof Symbol != "undefined" && t3[Symbol.iterator] || t3["@@iterator"];
            if (!r2) {
              if (Array.isArray(t3) || (r2 = i(t3)) || e3 && t3 && typeof t3.length == "number") {
                r2 && (t3 = r2);
                var n2 = 0, o2 = /* @__PURE__ */ __name(function() {}, "o");
                return { s: o2, n: /* @__PURE__ */ __name(function() {
                  return n2 >= t3.length ? { done: true } : { done: false, value: t3[n2++] };
                }, "n"), e: /* @__PURE__ */ __name(function(t4) {
                  throw t4;
                }, "e"), f: o2 };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var a2, c2 = true, u2 = false;
            return { s: /* @__PURE__ */ __name(function() {
              r2 = r2.call(t3);
            }, "s"), n: /* @__PURE__ */ __name(function() {
              var t4 = r2.next();
              return c2 = t4.done, t4;
            }, "n"), e: /* @__PURE__ */ __name(function(t4) {
              u2 = true, a2 = t4;
            }, "e"), f: /* @__PURE__ */ __name(function() {
              try {
                c2 || r2.return == null || r2.return();
              } finally {
                if (u2)
                  throw a2;
              }
            }, "f") };
          }
          __name(a, "a");
          function i(t3, e3) {
            if (t3) {
              if (typeof t3 == "string")
                return c(t3, e3);
              var r2 = {}.toString.call(t3).slice(8, -1);
              return r2 === "Object" && t3.constructor && (r2 = t3.constructor.name), r2 === "Map" || r2 === "Set" ? Array.from(t3) : r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? c(t3, e3) : undefined;
            }
          }
          __name(i, "i");
          function c(t3, e3) {
            (e3 == null || e3 > t3.length) && (e3 = t3.length);
            for (var r2 = 0, n2 = Array(e3);r2 < e3; r2++)
              n2[r2] = t3[r2];
            return n2;
          }
          __name(c, "c");
          var u = r(425), l = u.BigInt, f = u.Error, s = u.NumberParseInt, y = u.ObjectEntries, p = u.ObjectGetOwnPropertyDescriptor, g = u.ObjectGetOwnPropertyDescriptors, v = u.ObjectGetOwnPropertySymbols, h = u.ObjectPrototypeToString, d = u.Symbol, b = r(569), m = d("kPending"), S = d("kRejected");
          t2.exports = { constants: { kPending: m, kRejected: S, ALL_PROPERTIES: 0, ONLY_ENUMERABLE: 2 }, getOwnNonIndexProperties: /* @__PURE__ */ __name(function(t3) {
            var e3, r2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2, n2 = g(t3), i2 = [], c2 = a(y(n2));
            try {
              for (c2.s();!(e3 = c2.n()).done; ) {
                var u2 = o(e3.value, 2), l2 = u2[0], f2 = u2[1];
                if (!/^(0|[1-9][0-9]*)$/.test(l2) || s(l2, 10) >= Math.pow(2, 32) - 1) {
                  if (r2 === 2 && !f2.enumerable)
                    continue;
                  i2.push(l2);
                }
              }
            } catch (t4) {
              c2.e(t4);
            } finally {
              c2.f();
            }
            var h2, d2 = a(v(t3));
            try {
              for (d2.s();!(h2 = d2.n()).done; ) {
                var b2 = h2.value, m2 = p(t3, b2);
                (r2 !== 2 || m2.enumerable) && i2.push(b2);
              }
            } catch (t4) {
              d2.e(t4);
            } finally {
              d2.f();
            }
            return i2;
          }, "getOwnNonIndexProperties"), getPromiseDetails: /* @__PURE__ */ __name(function() {
            return [m, undefined];
          }, "getPromiseDetails"), getProxyDetails: b.getProxyDetails, Proxy: b.Proxy, previewEntries: /* @__PURE__ */ __name(function(t3) {
            return [[], false];
          }, "previewEntries"), getConstructorName: /* @__PURE__ */ __name(function(t3) {
            var e3;
            if (!t3 || n(t3) !== "object")
              throw new f("Invalid object");
            if ((e3 = t3.constructor) !== null && e3 !== undefined && e3.name)
              return t3.constructor.name;
            var r2 = h(t3).match(/^\[object ([^\]]+)\]/);
            return r2 ? r2[1] : "Object";
          }, "getConstructorName"), getExternalValue: /* @__PURE__ */ __name(function() {
            return l(0);
          }, "getExternalValue") };
        }, 229: (t2, e2, r) => {
          var n;
          function o() {
            return n = n != null ? n : r(924).codes.ERR_INTERNAL_ASSERTION;
          }
          __name(o, "o");
          function a(t3, e3) {
            if (!t3)
              throw new (o())(e3);
          }
          __name(a, "a");
          a.fail = function(t3) {
            throw new (o())(t3);
          }, t2.exports = a;
        }, 370: (t2, e2, r) => {
          var n = r(425), o = n.StringPrototypeCharCodeAt, a = n.StringPrototypeLastIndexOf, i = n.StringPrototypeSlice, c = r(22), u = c.CHAR_DOT, l = c.CHAR_FORWARD_SLASH, f = r(116).validateString;
          function s(t3) {
            return t3 === l;
          }
          __name(s, "s");
          function y(t3, e3, r2, n2) {
            for (var c2 = "", f2 = 0, s2 = -1, y2 = 0, p = 0, g = 0;g <= t3.length; ++g) {
              if (g < t3.length)
                p = o(t3, g);
              else {
                if (n2(p))
                  break;
                p = l;
              }
              if (n2(p)) {
                if (s2 === g - 1 || y2 === 1)
                  ;
                else if (y2 === 2) {
                  if (c2.length < 2 || f2 !== 2 || o(c2, c2.length - 1) !== u || o(c2, c2.length - 2) !== u) {
                    if (c2.length > 2) {
                      var v = a(c2, r2);
                      v === -1 ? (c2 = "", f2 = 0) : f2 = (c2 = i(c2, 0, v)).length - 1 - a(c2, r2), s2 = g, y2 = 0;
                      continue;
                    }
                    if (c2.length !== 0) {
                      c2 = "", f2 = 0, s2 = g, y2 = 0;
                      continue;
                    }
                  }
                  e3 && (c2 += c2.length > 0 ? "".concat(r2, "..") : "..", f2 = 2);
                } else
                  c2.length > 0 ? c2 += "".concat(r2).concat(i(t3, s2 + 1, g)) : c2 = i(t3, s2 + 1, g), f2 = g - s2 - 1;
                s2 = g, y2 = 0;
              } else
                p === u && y2 !== -1 ? ++y2 : y2 = -1;
            }
            return c2;
          }
          __name(y, "y");
          t2.exports = { isPosixPathSeparator: s, normalizeString: y, resolve: /* @__PURE__ */ __name(function() {
            if ((arguments.length === 0 || arguments.length === 1 && ((arguments.length <= 0 ? undefined : arguments[0]) === "" || (arguments.length <= 0 ? undefined : arguments[0]) === ".")) && o("/", 0) === l)
              return "/";
            for (var t3 = "", e3 = false, r2 = arguments.length - 1;r2 >= 0 && !e3; r2--) {
              var n2 = r2 < 0 || arguments.length <= r2 ? undefined : arguments[r2];
              f(n2, "paths[".concat(r2, "]")), n2.length !== 0 && (t3 = "".concat(n2, "/").concat(t3), e3 = o(n2, 0) === l);
            }
            return e3 || (t3 = "".concat("/", "/").concat(t3), e3 = o("/", 0) === l), t3 = y(t3, !e3, "/", s), e3 ? "/".concat(t3) : t3.length > 0 ? t3 : ".";
          }, "resolve") };
        }, 425: (t2) => {
          function e2() {
            var t3, n2, o2 = typeof Symbol == "function" ? Symbol : {}, a2 = o2.iterator || "@@iterator", i2 = o2.toStringTag || "@@toStringTag";
            function c2(e3, o3, a3, i3) {
              var c3 = o3 && o3.prototype instanceof l2 ? o3 : l2, f3 = Object.create(c3.prototype);
              return r(f3, "_invoke", function(e4, r2, o4) {
                var a4, i4, c4, l3 = 0, f4 = o4 || [], s3 = false, y3 = { p: 0, n: 0, v: t3, a: p3, f: p3.bind(t3, 4), d: /* @__PURE__ */ __name(function(e5, r3) {
                  return a4 = e5, i4 = 0, c4 = t3, y3.n = r3, u2;
                }, "d") };
                function p3(e5, r3) {
                  for (i4 = e5, c4 = r3, n2 = 0;!s3 && l3 && !o5 && n2 < f4.length; n2++) {
                    var o5, a5 = f4[n2], p4 = y3.p, g3 = a5[2];
                    e5 > 3 ? (o5 = g3 === r3) && (c4 = a5[(i4 = a5[4]) ? 5 : (i4 = 3, 3)], a5[4] = a5[5] = t3) : a5[0] <= p4 && ((o5 = e5 < 2 && p4 < a5[1]) ? (i4 = 0, y3.v = r3, y3.n = a5[1]) : p4 < g3 && (o5 = e5 < 3 || a5[0] > r3 || r3 > g3) && (a5[4] = e5, a5[5] = r3, y3.n = g3, i4 = 0));
                  }
                  if (o5 || e5 > 1)
                    return u2;
                  throw s3 = true, r3;
                }
                __name(p3, "p");
                return function(o5, f5, g3) {
                  if (l3 > 1)
                    throw TypeError("Generator is already running");
                  for (s3 && f5 === 1 && p3(f5, g3), i4 = f5, c4 = g3;(n2 = i4 < 2 ? t3 : c4) || !s3; ) {
                    a4 || (i4 ? i4 < 3 ? (i4 > 1 && (y3.n = -1), p3(i4, c4)) : y3.n = c4 : y3.v = c4);
                    try {
                      if (l3 = 2, a4) {
                        if (i4 || (o5 = "next"), n2 = a4[o5]) {
                          if (!(n2 = n2.call(a4, c4)))
                            throw TypeError("iterator result is not an object");
                          if (!n2.done)
                            return n2;
                          c4 = n2.value, i4 < 2 && (i4 = 0);
                        } else
                          i4 === 1 && (n2 = a4.return) && n2.call(a4), i4 < 2 && (c4 = TypeError("The iterator does not provide a '" + o5 + "' method"), i4 = 1);
                        a4 = t3;
                      } else if ((n2 = (s3 = y3.n < 0) ? c4 : e4.call(r2, y3)) !== u2)
                        break;
                    } catch (e5) {
                      a4 = t3, i4 = 1, c4 = e5;
                    } finally {
                      l3 = 1;
                    }
                  }
                  return { value: n2, done: s3 };
                };
              }(e3, a3, i3), true), f3;
            }
            __name(c2, "c");
            var u2 = {};
            function l2() {}
            __name(l2, "l");
            function f2() {}
            __name(f2, "f");
            function s2() {}
            __name(s2, "s");
            n2 = Object.getPrototypeOf;
            var y2 = [][a2] ? n2(n2([][a2]())) : (r(n2 = {}, a2, function() {
              return this;
            }), n2), p2 = s2.prototype = l2.prototype = Object.create(y2);
            function g2(t4) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(t4, s2) : (t4.__proto__ = s2, r(t4, i2, "GeneratorFunction")), t4.prototype = Object.create(p2), t4;
            }
            __name(g2, "g");
            return f2.prototype = s2, r(p2, "constructor", s2), r(s2, "constructor", f2), f2.displayName = "GeneratorFunction", r(s2, i2, "GeneratorFunction"), r(p2), r(p2, i2, "Generator"), r(p2, a2, function() {
              return this;
            }), r(p2, "toString", function() {
              return "[object Generator]";
            }), (e2 = /* @__PURE__ */ __name(function() {
              return { w: c2, m: g2 };
            }, "e"))();
          }
          __name(e2, "e");
          function r(t3, e3, n2, o2) {
            var a2 = Object.defineProperty;
            try {
              a2({}, "", {});
            } catch (t4) {
              a2 = 0;
            }
            r = /* @__PURE__ */ __name(function(t4, e4, n3, o3) {
              function i2(e5, n4) {
                r(t4, e5, function(t5) {
                  return this._invoke(e5, n4, t5);
                });
              }
              __name(i2, "i");
              e4 ? a2 ? a2(t4, e4, { value: n3, enumerable: !o3, configurable: !o3, writable: !o3 }) : t4[e4] = n3 : (i2("next", 0), i2("throw", 1), i2("return", 2));
            }, "r"), r(t3, e3, n2, o2);
          }
          __name(r, "r");
          function n(t3, e3, r2) {
            return e3 = a(e3), function(t4, e4) {
              if (e4 && (d(e4) == "object" || typeof e4 == "function"))
                return e4;
              if (e4 !== undefined)
                throw new TypeError("Derived constructors may only return object or undefined");
              return function(t5) {
                if (t5 === undefined)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t5;
              }(t4);
            }(t3, o() ? Reflect.construct(e3, r2 || [], a(t3).constructor) : e3.apply(t3, r2));
          }
          __name(n, "n");
          function o() {
            try {
              var t3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
            } catch (t4) {}
            return (o = /* @__PURE__ */ __name(function() {
              return !!t3;
            }, "o"))();
          }
          __name(o, "o");
          function a(t3) {
            return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
              return t4.__proto__ || Object.getPrototypeOf(t4);
            }, a(t3);
          }
          __name(a, "a");
          function i(t3, e3) {
            if (typeof e3 != "function" && e3 !== null)
              throw new TypeError("Super expression must either be null or a function");
            t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, writable: true, configurable: true } }), Object.defineProperty(t3, "prototype", { writable: false }), e3 && c(t3, e3);
          }
          __name(i, "i");
          function c(t3, e3) {
            return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
              return t4.__proto__ = e4, t4;
            }, c(t3, e3);
          }
          __name(c, "c");
          function u(t3, e3) {
            if (!(t3 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }
          __name(u, "u");
          function l(t3, e3) {
            for (var r2 = 0;r2 < e3.length; r2++) {
              var n2 = e3[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, g(n2.key), n2);
            }
          }
          __name(l, "l");
          function f(t3, e3, r2) {
            return e3 && l(t3.prototype, e3), r2 && l(t3, r2), Object.defineProperty(t3, "prototype", { writable: false }), t3;
          }
          __name(f, "f");
          function s(t3, e3) {
            var r2 = Object.keys(t3);
            if (Object.getOwnPropertySymbols) {
              var n2 = Object.getOwnPropertySymbols(t3);
              e3 && (n2 = n2.filter(function(e4) {
                return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
              })), r2.push.apply(r2, n2);
            }
            return r2;
          }
          __name(s, "s");
          function y(t3) {
            for (var e3 = 1;e3 < arguments.length; e3++) {
              var r2 = arguments[e3] != null ? arguments[e3] : {};
              e3 % 2 ? s(Object(r2), true).forEach(function(e4) {
                p(t3, e4, r2[e4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r2)) : s(Object(r2)).forEach(function(e4) {
                Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(r2, e4));
              });
            }
            return t3;
          }
          __name(y, "y");
          function p(t3, e3, r2) {
            return (e3 = g(e3)) in t3 ? Object.defineProperty(t3, e3, { value: r2, enumerable: true, configurable: true, writable: true }) : t3[e3] = r2, t3;
          }
          __name(p, "p");
          function g(t3) {
            var e3 = function(t4) {
              if (d(t4) != "object" || !t4)
                return t4;
              var e4 = t4[Symbol.toPrimitive];
              if (e4 !== undefined) {
                var r2 = e4.call(t4, "string");
                if (d(r2) != "object")
                  return r2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t4);
            }(t3);
            return d(e3) == "symbol" ? e3 : e3 + "";
          }
          __name(g, "g");
          function v(t3, e3) {
            var r2 = typeof Symbol != "undefined" && t3[Symbol.iterator] || t3["@@iterator"];
            if (!r2) {
              if (Array.isArray(t3) || (r2 = function(t4, e4) {
                if (t4) {
                  if (typeof t4 == "string")
                    return h(t4, e4);
                  var r3 = {}.toString.call(t4).slice(8, -1);
                  return r3 === "Object" && t4.constructor && (r3 = t4.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(t4) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? h(t4, e4) : undefined;
                }
              }(t3)) || e3 && t3 && typeof t3.length == "number") {
                r2 && (t3 = r2);
                var n2 = 0, o2 = /* @__PURE__ */ __name(function() {}, "o");
                return { s: o2, n: /* @__PURE__ */ __name(function() {
                  return n2 >= t3.length ? { done: true } : { done: false, value: t3[n2++] };
                }, "n"), e: /* @__PURE__ */ __name(function(t4) {
                  throw t4;
                }, "e"), f: o2 };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            var a2, i2 = true, c2 = false;
            return { s: /* @__PURE__ */ __name(function() {
              r2 = r2.call(t3);
            }, "s"), n: /* @__PURE__ */ __name(function() {
              var t4 = r2.next();
              return i2 = t4.done, t4;
            }, "n"), e: /* @__PURE__ */ __name(function(t4) {
              c2 = true, a2 = t4;
            }, "e"), f: /* @__PURE__ */ __name(function() {
              try {
                i2 || r2.return == null || r2.return();
              } finally {
                if (c2)
                  throw a2;
              }
            }, "f") };
          }
          __name(v, "v");
          function h(t3, e3) {
            (e3 == null || e3 > t3.length) && (e3 = t3.length);
            for (var r2 = 0, n2 = Array(e3);r2 < e3; r2++)
              n2[r2] = t3[r2];
            return n2;
          }
          __name(h, "h");
          function d(t3) {
            return d = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
              return typeof t4;
            } : function(t4) {
              return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
            }, d(t3);
          }
          __name(d, "d");
          function b(t3) {
            return function() {
              return new m(t3.apply(this, arguments));
            };
          }
          __name(b, "b");
          function m(t3) {
            var e3, r2;
            function n2(e4, r3) {
              try {
                var a2 = t3[e4](r3), i2 = a2.value, c2 = i2 instanceof S;
                Promise.resolve(c2 ? i2.v : i2).then(function(r4) {
                  if (c2) {
                    var u2 = e4 === "return" ? "return" : "next";
                    if (!i2.k || r4.done)
                      return n2(u2, r4);
                    r4 = t3[u2](r4).value;
                  }
                  o2(a2.done ? "return" : "normal", r4);
                }, function(t4) {
                  n2("throw", t4);
                });
              } catch (t4) {
                o2("throw", t4);
              }
            }
            __name(n2, "n");
            function o2(t4, o3) {
              switch (t4) {
                case "return":
                  e3.resolve({ value: o3, done: true });
                  break;
                case "throw":
                  e3.reject(o3);
                  break;
                default:
                  e3.resolve({ value: o3, done: false });
              }
              (e3 = e3.next) ? n2(e3.key, e3.arg) : r2 = null;
            }
            __name(o2, "o");
            this._invoke = function(t4, o3) {
              return new Promise(function(a2, i2) {
                var c2 = { key: t4, arg: o3, resolve: a2, reject: i2, next: null };
                r2 ? r2 = r2.next = c2 : (e3 = r2 = c2, n2(t4, o3));
              });
            }, typeof t3.return != "function" && (this.return = undefined);
          }
          __name(m, "m");
          function S(t3, e3) {
            this.v = t3, this.k = e3;
          }
          __name(S, "S");
          m.prototype[typeof Symbol == "function" && Symbol.asyncIterator || "@@asyncIterator"] = function() {
            return this;
          }, m.prototype.next = function(t3) {
            return this._invoke("next", t3);
          }, m.prototype.throw = function(t3) {
            return this._invoke("throw", t3);
          }, m.prototype.return = function(t3) {
            return this._invoke("return", t3);
          };
          var P = { __proto__: null }, x = Reflect.defineProperty, w = Reflect.getOwnPropertyDescriptor, A = Reflect.ownKeys, O = Function.prototype, _ = O.apply, j = O.bind, E = O.call, k = j.bind(E);
          P.uncurryThis = k;
          var I = j.bind(_);
          P.applyBind = I;
          var R = ["ArrayOf", "ArrayPrototypePush", "ArrayPrototypeUnshift", "MathHypot", "MathMax", "MathMin", "StringFromCharCode", "StringFromCodePoint", "StringPrototypeConcat", "TypedArrayOf"];
          function L(t3) {
            return d(t3) === "symbol" ? "Symbol".concat(t3.description[7].toUpperCase()).concat(t3.description.slice(8)) : "".concat(t3[0].toUpperCase()).concat(t3.slice(1));
          }
          __name(L, "L");
          function T(t3, e3, r2, n2) {
            var { enumerable: o2, get: a2, set: i2 } = n2;
            x(t3, "".concat(e3, "Get").concat(r2), { __proto__: null, value: k(a2), enumerable: o2 }), i2 !== undefined && x(t3, "".concat(e3, "Set").concat(r2), { __proto__: null, value: k(i2), enumerable: o2 });
          }
          __name(T, "T");
          function B(t3, e3, r2) {
            var n2, o2 = v(A(t3));
            try {
              for (o2.s();!(n2 = o2.n()).done; ) {
                var a2 = n2.value, i2 = L(a2), c2 = w(t3, a2);
                if ("get" in c2)
                  T(e3, r2, i2, c2);
                else {
                  var u2 = "".concat(r2).concat(i2);
                  x(e3, u2, y({ __proto__: null }, c2)), R.includes(u2) && x(e3, "".concat(u2, "Apply"), { __proto__: null, value: I(c2.value, t3) });
                }
              }
            } catch (t4) {
              o2.e(t4);
            } finally {
              o2.f();
            }
          }
          __name(B, "B");
          function z(t3, e3, r2) {
            var n2, o2 = v(A(t3));
            try {
              for (o2.s();!(n2 = o2.n()).done; ) {
                var a2 = n2.value, i2 = L(a2), c2 = w(t3, a2);
                if ("get" in c2)
                  T(e3, r2, i2, c2);
                else {
                  var u2 = c2.value;
                  typeof u2 == "function" && (c2.value = k(u2));
                  var l2 = "".concat(r2).concat(i2);
                  x(e3, l2, y({ __proto__: null }, c2)), R.includes(l2) && x(e3, "".concat(l2, "Apply"), { __proto__: null, value: I(u2) });
                }
              }
            } catch (t4) {
              o2.e(t4);
            } finally {
              o2.f();
            }
          }
          __name(z, "z");
          ["Proxy", "globalThis"].forEach(function(t3) {
            P[t3] = globalThis[t3];
          }), [decodeURI, decodeURIComponent, encodeURI, encodeURIComponent].forEach(function(t3) {
            P[t3.name] = t3;
          }), [escape, eval, unescape].forEach(function(t3) {
            P[t3.name] = t3;
          }), ["Atomics", "JSON", "Math", "Proxy", "Reflect"].forEach(function(t3) {
            B(globalThis[t3], P, t3);
          }), ["AggregateError", "Array", "ArrayBuffer", "BigInt", "BigInt64Array", "BigUint64Array", "Boolean", "DataView", "Date", "Error", "EvalError", "FinalizationRegistry", "Float32Array", "Float64Array", "Function", "Int16Array", "Int32Array", "Int8Array", "Map", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "Set", "String", "Symbol", "SyntaxError", "TypeError", "URIError", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray", "WeakMap", "WeakRef", "WeakSet"].forEach(function(t3) {
            var e3 = globalThis[t3];
            e3 && (P[t3] = e3, B(e3, P, t3), z(e3.prototype, P, "".concat(t3, "Prototype")));
          }), ["Promise"].forEach(function(t3) {
            var e3 = globalThis[t3];
            P[t3] = e3, function(t4, e4, r2) {
              var n2, o2 = v(A(t4));
              try {
                for (o2.s();!(n2 = o2.n()).done; ) {
                  var a2 = n2.value, i2 = L(a2), c2 = w(t4, a2);
                  if ("get" in c2)
                    T(e4, r2, i2, c2);
                  else {
                    var u2 = c2.value;
                    typeof u2 == "function" && (c2.value = u2.bind(t4));
                    var l2 = "".concat(r2).concat(i2);
                    x(e4, l2, y({ __proto__: null }, c2));
                  }
                }
              } catch (t5) {
                o2.e(t5);
              } finally {
                o2.f();
              }
            }(e3, P, t3), z(e3.prototype, P, "".concat(t3, "Prototype"));
          }), [{ name: "TypedArray", original: Reflect.getPrototypeOf(Uint8Array) }, { name: "ArrayIterator", original: { prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]()) } }, { name: "StringIterator", original: { prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]()) } }].forEach(function(t3) {
            var { name: e3, original: r2 } = t3;
            P[e3] = r2, z(r2, P, e3), z(r2.prototype, P, "".concat(e3, "Prototype"));
          }), P.IteratorPrototype = Reflect.getPrototypeOf(P.ArrayIteratorPrototype);
          var { ArrayPrototypeForEach: M, FinalizationRegistry: C, FunctionPrototypeCall: D, Map: N, ObjectFreeze: F, ObjectSetPrototypeOf: W, RegExp: H, Set: U, SymbolIterator: G, WeakMap: V, WeakRef: Z, WeakSet: $ } = P, Y = /* @__PURE__ */ __name(function(t3, e3) {
            var r2 = function() {
              return f(/* @__PURE__ */ __name(function e4(r3) {
                u(this, e4), this._iterator = t3(r3);
              }, "e"), [{ key: "next", value: /* @__PURE__ */ __name(function() {
                return e3(this._iterator);
              }, "value") }, { key: G, value: /* @__PURE__ */ __name(function() {
                return this;
              }, "value") }]);
            }();
            return W(r2.prototype, null), F(r2.prototype), F(r2), r2;
          }, "Y");
          P.SafeArrayIterator = Y(P.ArrayPrototypeSymbolIterator, P.ArrayIteratorPrototypeNext), P.SafeStringIterator = Y(P.StringPrototypeSymbolIterator, P.StringIteratorPrototypeNext);
          var q = /* @__PURE__ */ __name(function(t3, e3) {
            M(A(t3), function(r2) {
              w(e3, r2) || x(e3, r2, y({ __proto__: null }, w(t3, r2)));
            });
          }, "q"), J = /* @__PURE__ */ __name(function(t3, e3) {
            if (G in t3.prototype) {
              var r2, n2 = new t3;
              M(A(t3.prototype), function(o2) {
                if (!w(e3.prototype, o2)) {
                  var a2, i2 = w(t3.prototype, o2);
                  if (typeof i2.value == "function" && i2.value.length === 0 && G in ((a2 = D(i2.value, n2)) !== null && a2 !== undefined ? a2 : {})) {
                    var c2 = k(i2.value);
                    r2 = r2 || k(c2(n2).next);
                    var u2 = Y(c2, r2);
                    i2.value = function() {
                      return new u2(this);
                    };
                  }
                  x(e3.prototype, o2, y({ __proto__: null }, i2));
                }
              });
            } else
              q(t3.prototype, e3.prototype);
            return q(t3, e3), W(e3.prototype, null), F(e3.prototype), F(e3), e3;
          }, "J");
          P.makeSafe = J, P.SafeMap = J(N, function(t3) {
            function e3(t4) {
              return u(this, e3), n(this, e3, [t4]);
            }
            __name(e3, "e");
            return i(e3, t3), f(e3);
          }(N)), P.SafeWeakMap = J(V, function(t3) {
            function e3(t4) {
              return u(this, e3), n(this, e3, [t4]);
            }
            __name(e3, "e");
            return i(e3, t3), f(e3);
          }(V)), P.SafeSet = J(U, function(t3) {
            function e3(t4) {
              return u(this, e3), n(this, e3, [t4]);
            }
            __name(e3, "e");
            return i(e3, t3), f(e3);
          }(U)), P.SafeWeakSet = J($, function(t3) {
            function e3(t4) {
              return u(this, e3), n(this, e3, [t4]);
            }
            __name(e3, "e");
            return i(e3, t3), f(e3);
          }($)), P.SafeFinalizationRegistry = J(C, function(t3) {
            function e3(t4) {
              return u(this, e3), n(this, e3, [t4]);
            }
            __name(e3, "e");
            return i(e3, t3), f(e3);
          }(C)), P.SafeWeakRef = J(Z, function(t3) {
            function e3(t4) {
              return u(this, e3), n(this, e3, [t4]);
            }
            __name(e3, "e");
            return i(e3, t3), f(e3);
          }(Z)), P.AsyncIteratorPrototype = P.ReflectGetPrototypeOf(b(e2().m(/* @__PURE__ */ __name(function t3() {
            return e2().w(function(t4) {
              for (;; )
                if (t4.n === 0)
                  return t4.a(2);
            }, t3);
          }, "t")))).prototype, P.internalBinding = function(t3) {
            if (t3 === "config")
              return { hasIntl: false };
            throw new Error('unknown module: "'.concat(t3, '"'));
          }, P._stringPrototypeReplaceAll = function(t3, e3, r2) {
            return Object.prototype.toString.call(e3).toLowerCase() === "[object regexp]" ? t3.replace(e3, r2) : t3.replace(new H(e3, "g"), r2);
          }, P.StringPrototypeReplaceAll = P.StringPrototypeReplaceAll || P._stringPrototypeReplaceAll, W(P, null), F(P), t2.exports = P;
        }, 569: (t2, e2, r) => {
          function n(t3) {
            return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
              return typeof t4;
            } : function(t4) {
              return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
            }, n(t3);
          }
          __name(n, "n");
          function o(t3, e3) {
            for (var r2 = 0;r2 < e3.length; r2++) {
              var n2 = e3[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, a(n2.key), n2);
            }
          }
          __name(o, "o");
          function a(t3) {
            var e3 = function(t4) {
              if (n(t4) != "object" || !t4)
                return t4;
              var e4 = t4[Symbol.toPrimitive];
              if (e4 !== undefined) {
                var r2 = e4.call(t4, "string");
                if (n(r2) != "object")
                  return r2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t4);
            }(t3);
            return n(e3) == "symbol" ? e3 : e3 + "";
          }
          __name(a, "a");
          var i = r(425), c = i.Proxy, u = i.ProxyRevocable, l = new (0, i.SafeWeakMap), f = function() {
            return t3 = /* @__PURE__ */ __name(function t4(e4, r2) {
              (function(t5, e5) {
                if (!(t5 instanceof e5))
                  throw new TypeError("Cannot call a class as a function");
              })(this, t4);
              var n2 = new c(e4, r2);
              return l.set(n2, [e4, r2]), n2;
            }, "t"), e3 = [{ key: "getProxyDetails", value: /* @__PURE__ */ __name(function(t4) {
              var e4 = !(arguments.length > 1 && arguments[1] !== undefined) || arguments[1], r2 = l.get(t4);
              if (r2)
                return e4 ? r2 : r2[0];
            }, "value") }, { key: "revocable", value: /* @__PURE__ */ __name(function(t4, e4) {
              var r2 = u(t4, e4);
              l.set(r2.proxy, [t4, e4]);
              var n2 = r2.revoke;
              return r2.revoke = function() {
                l.set(r2.proxy, [null, null]), n2();
              }, r2;
            }, "value") }], null, e3 && o(t3, e3), Object.defineProperty(t3, "prototype", { writable: false }), t3;
            var t3, e3;
          }();
          t2.exports = { getProxyDetails: f.getProxyDetails.bind(f), Proxy: f };
        }, 617: (t2, e2, r) => {
          function n(t3) {
            return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
              return typeof t4;
            } : function(t4) {
              return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
            }, n(t3);
          }
          __name(n, "n");
          var o = r(425), a = o.ArrayIsArray, i = o.BigInt, c = o.Boolean, u = o.DatePrototype, l = o.Error, f = o.FunctionPrototype, s = o.MapPrototypeHas, y = o.Number, p = o.ObjectDefineProperty, g = o.ObjectGetOwnPropertyDescriptor, v = o.ObjectGetPrototypeOf, h = o.ObjectIsFrozen, d = o.ObjectPrototype, b = o.SetPrototypeHas, m = o.String, S = o.Symbol, P = o.SymbolToStringTag, x = o.globalThis, w = r(153).getConstructorName;
          function A(t3) {
            for (var e3 = arguments.length, r2 = new Array(e3 > 1 ? e3 - 1 : 0), o2 = 1;o2 < e3; o2++)
              r2[o2 - 1] = arguments[o2];
            for (var a2 = 0, i2 = r2;a2 < i2.length; a2++) {
              var c2 = i2[a2], u2 = x[c2];
              if (u2 && t3 instanceof u2)
                return true;
            }
            for (;t3; ) {
              if (n(t3) !== "object")
                return false;
              if (r2.indexOf(w(t3)) >= 0)
                return true;
              t3 = v(t3);
            }
            return false;
          }
          __name(A, "A");
          function O(t3) {
            return function(e3) {
              if (!A(e3, t3.name))
                return false;
              try {
                t3.prototype.valueOf.call(e3);
              } catch (t4) {
                return false;
              }
              return true;
            };
          }
          __name(O, "O");
          n(x) !== "object" && (p(d, "__magic__", { get: /* @__PURE__ */ __name(function() {
            return this;
          }, "get"), configurable: true }), __magic__.globalThis = __magic__, delete d.__magic__);
          var _ = O(m), j = O(y), E = O(c), k = O(i), I = O(S);
          t2.exports = { isAsyncFunction: /* @__PURE__ */ __name(function(t3) {
            return typeof t3 == "function" && f.toString.call(t3).startsWith("async");
          }, "isAsyncFunction"), isGeneratorFunction: /* @__PURE__ */ __name(function(t3) {
            return typeof t3 == "function" && f.toString.call(t3).match(/^(async\s+)?function *\*/);
          }, "isGeneratorFunction"), isAnyArrayBuffer: /* @__PURE__ */ __name(function(t3) {
            return A(t3, "ArrayBuffer", "SharedArrayBuffer");
          }, "isAnyArrayBuffer"), isArrayBuffer: /* @__PURE__ */ __name(function(t3) {
            return A(t3, "ArrayBuffer");
          }, "isArrayBuffer"), isArgumentsObject: /* @__PURE__ */ __name(function(t3) {
            if (t3 !== null && n(t3) === "object" && !a(t3) && typeof t3.length == "number" && t3.length === (0 | t3.length) && t3.length >= 0) {
              var e3 = g(t3, "callee");
              return e3 && !e3.enumerable;
            }
            return false;
          }, "isArgumentsObject"), isBoxedPrimitive: /* @__PURE__ */ __name(function(t3) {
            return j(t3) || _(t3) || E(t3) || k(t3) || I(t3);
          }, "isBoxedPrimitive"), isDataView: /* @__PURE__ */ __name(function(t3) {
            return A(t3, "DataView");
          }, "isDataView"), isExternal: /* @__PURE__ */ __name(function(t3) {
            return n(t3) === "object" && h(t3) && v(t3) == null;
          }, "isExternal"), isMap: /* @__PURE__ */ __name(function(t3) {
            if (!A(t3, "Map"))
              return false;
            try {
              s(t3);
            } catch (t4) {
              return false;
            }
            return true;
          }, "isMap"), isMapIterator: /* @__PURE__ */ __name(function(t3) {
            return d.toString.call(v(t3)) === "[object Map Iterator]";
          }, "isMapIterator"), isModuleNamespaceObject: /* @__PURE__ */ __name(function(t3) {
            return t3 && n(t3) === "object" && t3[P] === "Module";
          }, "isModuleNamespaceObject"), isNativeError: /* @__PURE__ */ __name(function(t3) {
            return t3 instanceof l && A(t3, "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "AggregateError");
          }, "isNativeError"), isPromise: /* @__PURE__ */ __name(function(t3) {
            return A(t3, "Promise");
          }, "isPromise"), isSet: /* @__PURE__ */ __name(function(t3) {
            if (!A(t3, "Set"))
              return false;
            try {
              b(t3);
            } catch (t4) {
              return false;
            }
            return true;
          }, "isSet"), isSetIterator: /* @__PURE__ */ __name(function(t3) {
            return d.toString.call(v(t3)) === "[object Set Iterator]";
          }, "isSetIterator"), isWeakMap: /* @__PURE__ */ __name(function(t3) {
            return A(t3, "WeakMap");
          }, "isWeakMap"), isWeakSet: /* @__PURE__ */ __name(function(t3) {
            return A(t3, "WeakSet");
          }, "isWeakSet"), isRegExp: /* @__PURE__ */ __name(function(t3) {
            return A(t3, "RegExp");
          }, "isRegExp"), isDate: /* @__PURE__ */ __name(function(t3) {
            if (A(t3, "Date"))
              try {
                return u.getTime.call(t3), true;
              } catch (t4) {}
            return false;
          }, "isDate"), isTypedArray: /* @__PURE__ */ __name(function(t3) {
            return A(t3, "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array");
          }, "isTypedArray"), isStringObject: _, isNumberObject: j, isBooleanObject: E, isBigIntObject: k, isSymbolObject: I };
        }, 705: (t2) => {
          var e2 = ["_http_agent", "_http_client", "_http_common", "_http_incoming", "_http_outgoing", "_http_server", "_stream_duplex", "_stream_passthrough", "_stream_readable", "_stream_transform", "_stream_wrap", "_stream_writable", "_tls_common", "_tls_wrap", "assert", "assert/strict", "async_hooks", "buffer", "child_process", "cluster", "console", "constants", "crypto", "dgram", "diagnostics_channel", "dns", "dns/promises", "domain", "events", "fs", "fs/promises", "http", "http2", "https", "inspector", "module", "Module", "net", "os", "path", "path/posix", "path/win32", "perf_hooks", "process", "punycode", "querystring", "readline", "readline/promises", "repl", "stream", "stream/consumers", "stream/promises", "stream/web", "string_decoder", "sys", "timers", "timers/promises", "tls", "trace_events", "tty", "url", "util", "util/types", "v8", "vm", "wasi", "worker_threads", "zlib"];
          t2.exports.BuiltinModule = { exists: /* @__PURE__ */ __name(function(t3) {
            return t3.startsWith("internal/") || e2.indexOf(t3) !== -1;
          }, "exists") };
        }, 802: (t2, e2, r) => {
          var n = r(425), o = n.StringPrototypeCharCodeAt, a = n.StringPrototypeIncludes, i = n.StringPrototypeReplace, c = r(24), u = r(22).CHAR_FORWARD_SLASH, l = r(370), f = /%/g, s = /\\/g, y = /\n/g, p = /\r/g, g = /\t/g;
          t2.exports = { pathToFileURL: /* @__PURE__ */ __name(function(t3) {
            var e3 = new c("file://"), r2 = l.resolve(t3);
            return o(t3, t3.length - 1) === u && r2[r2.length - 1] !== l.sep && (r2 += "/"), e3.pathname = function(t4) {
              return a(t4, "%") && (t4 = i(t4, f, "%25")), a(t4, "\\") && (t4 = i(t4, s, "%5C")), a(t4, `
`) && (t4 = i(t4, y, "%0A")), a(t4, "\r") && (t4 = i(t4, p, "%0D")), a(t4, "\t") && (t4 = i(t4, g, "%09")), t4;
            }(r2), e3;
          }, "pathToFileURL"), URL: c };
        }, 883: (t2, e2, r) => {
          function n(t3) {
            return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
              return typeof t4;
            } : function(t4) {
              return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
            }, n(t3);
          }
          __name(n, "n");
          function o(t3, e3) {
            for (var r2 = 0;r2 < e3.length; r2++) {
              var n2 = e3[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, a(n2.key), n2);
            }
          }
          __name(o, "o");
          function a(t3) {
            var e3 = function(t4) {
              if (n(t4) != "object" || !t4)
                return t4;
              var e4 = t4[Symbol.toPrimitive];
              if (e4 !== undefined) {
                var r2 = e4.call(t4, "string");
                if (n(r2) != "object")
                  return r2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t4);
            }(t3);
            return n(e3) == "symbol" ? e3 : e3 + "";
          }
          __name(a, "a");
          var i = r(425).ArrayPrototypeMap, c = function() {
            return t3 = /* @__PURE__ */ __name(function t4() {
              (function(t5, e4) {
                if (!(t5 instanceof e4))
                  throw new TypeError("Cannot call a class as a function");
              })(this, t4);
            }, "t"), e3 = [{ key: "hexSlice", value: /* @__PURE__ */ __name(function() {
              var t4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0, e4 = arguments.length > 1 ? arguments[1] : undefined;
              return i(this.slice(t4, e4), function(t5) {
                return ("00" + t5.toString(16)).slice(-2);
              }).join("");
            }, "value") }], e3 && o(t3.prototype, e3), Object.defineProperty(t3, "prototype", { writable: false }), t3;
            var t3, e3;
          }();
          e2.h = c;
        }, 923: (t2, e2, r) => {
          var n = r(425), o = n.ArrayPrototypeJoin, a = n.Error, i = n.StringPrototypeReplace, c = n.SymbolFor, u = /\u001b\[\d\d?m/g;
          t2.exports = { customInspectSymbol: c("nodejs.util.inspect.custom"), isError: /* @__PURE__ */ __name(function(t3) {
            return t3 instanceof a;
          }, "isError"), join: o, removeColors: /* @__PURE__ */ __name(function(t3) {
            return i(t3, u, "");
          }, "removeColors") };
        }, 924: (t2, e2, r) => {
          function n(t3, e3) {
            (e3 == null || e3 > t3.length) && (e3 = t3.length);
            for (var r2 = 0, n2 = Array(e3);r2 < e3; r2++)
              n2[r2] = t3[r2];
            return n2;
          }
          __name(n, "n");
          function o(t3) {
            return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
              return typeof t4;
            } : function(t4) {
              return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
            }, o(t3);
          }
          __name(o, "o");
          function a(t3, e3) {
            for (var r2 = 0;r2 < e3.length; r2++) {
              var n2 = e3[r2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, i(n2.key), n2);
            }
          }
          __name(a, "a");
          function i(t3) {
            var e3 = function(t4) {
              if (o(t4) != "object" || !t4)
                return t4;
              var e4 = t4[Symbol.toPrimitive];
              if (e4 !== undefined) {
                var r2 = e4.call(t4, "string");
                if (o(r2) != "object")
                  return r2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t4);
            }(t3);
            return o(e3) == "symbol" ? e3 : e3 + "";
          }
          __name(i, "i");
          function c() {
            try {
              var t3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
            } catch (t4) {}
            return (c = /* @__PURE__ */ __name(function() {
              return !!t3;
            }, "c"))();
          }
          __name(c, "c");
          function u(t3) {
            return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
              return t4.__proto__ || Object.getPrototypeOf(t4);
            }, u(t3);
          }
          __name(u, "u");
          function l(t3, e3) {
            return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
              return t4.__proto__ = e4, t4;
            }, l(t3, e3);
          }
          __name(l, "l");
          var f, s, y = r(425), p = y.ArrayIsArray, g = y.ArrayPrototypeIncludes, v = y.ArrayPrototypeIndexOf, h = y.ArrayPrototypeJoin, d = y.ArrayPrototypePush, b = y.ArrayPrototypeSlice, m = y.ArrayPrototypeSplice, S = y.Error, P = y.ErrorCaptureStackTrace, x = y.JSONStringify, w = y.ObjectDefineProperty, A = y.ReflectApply, O = y.RegExpPrototypeExec, _ = y.SafeMap, j = y.SafeWeakMap, E = y.String, k = y.StringPrototypeEndsWith, I = y.StringPrototypeIncludes, R = y.StringPrototypeIndexOf, L = y.StringPrototypeSlice, T = y.StringPrototypeToLowerCase, B = y.Symbol, z = y.TypeError, M = B("kIsNodeError"), C = new _, D = {}, N = /^[A-Z][a-zA-Z0-9]*$/, F = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], W = new j, H = r(229), U = null;
          function G(t3, e3) {
            var r2 = function(t4) {
              function r3() {
                var t5, n3, a2, l2;
                (function(t6, e4) {
                  if (!(t6 instanceof e4))
                    throw new TypeError("Cannot call a class as a function");
                })(this, r3), t5 = function(t6, e4, r4) {
                  return e4 = u(e4), function(t7, e5) {
                    if (e5 && (o(e5) == "object" || typeof e5 == "function"))
                      return e5;
                    if (e5 !== undefined)
                      throw new TypeError("Derived constructors may only return object or undefined");
                    return function(t8) {
                      if (t8 === undefined)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      return t8;
                    }(t7);
                  }(t6, c() ? Reflect.construct(e4, r4 || [], u(t6).constructor) : e4.apply(t6, r4));
                }(this, r3), n3 = t5, l2 = e3, (a2 = i(a2 = "code")) in n3 ? Object.defineProperty(n3, a2, { value: l2, enumerable: true, configurable: true, writable: true }) : n3[a2] = l2;
                for (var f3 = arguments.length, s3 = new Array(f3), y2 = 0;y2 < f3; y2++)
                  s3[y2] = arguments[y2];
                return w(t5, "message", { __proto__: null, value: Z(e3, s3, t5), enumerable: false, writable: true, configurable: true }), t5;
              }
              __name(r3, "r");
              return function(t5, e4) {
                if (typeof e4 != "function" && e4 !== null)
                  throw new TypeError("Super expression must either be null or a function");
                t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && l(t5, e4);
              }(r3, t4), n2 = r3, (f2 = [{ key: "toString", value: /* @__PURE__ */ __name(function() {
                return "".concat(this.name, " [").concat(e3, "]: ").concat(this.message);
              }, "value") }]) && a(n2.prototype, f2), s2 && a(n2, s2), Object.defineProperty(n2, "prototype", { writable: false }), n2;
              var n2, f2, s2;
            }(t3);
            return r2;
          }
          __name(G, "G");
          function V(t3, e3, r2) {
            C.set(t3, e3);
            var n2 = G(r2, t3);
            D[t3] = n2;
          }
          __name(V, "V");
          function Z(t3, e3, r2) {
            var n2 = C.get(t3);
            if (typeof n2 == "function")
              return H(n2.length <= e3.length, "Code: ".concat(t3, "; The provided arguments length (").concat(e3.length, ") does not ") + "match the required ones (".concat(n2.length, ").")), A(n2, r2, e3);
          }
          __name(Z, "Z");
          var $ = B("kEnhanceStackBeforeInspector");
          function Y(t3) {
            if (t3 === null)
              return "null";
            if (t3 === undefined)
              return "undefined";
            switch (o(t3)) {
              case "bigint":
                return "type bigint (".concat(t3, "n)");
              case "number":
                return t3 === 0 ? 1 / t3 == -1 / 0 ? "type number (-0)" : "type number (0)" : t3 != t3 ? "type number (NaN)" : t3 === 1 / 0 ? "type number (Infinity)" : t3 === -1 / 0 ? "type number (-Infinity)" : "type number (".concat(t3, ")");
              case "boolean":
                return t3 ? "type boolean (true)" : "type boolean (false)";
              case "symbol":
                return "type symbol (".concat(E(t3), ")");
              case "function":
                return "function ".concat(t3.name);
              case "object":
                return t3.constructor && "name" in t3.constructor ? "an instance of ".concat(t3.constructor.name) : "".concat((U = U || r(33)).inspect(t3, { depth: -1 }));
              case "string":
                return t3.length > 28 && (t3 = "".concat(L(t3, 0, 25), "...")), R(t3, "'") === -1 ? "type string ('".concat(t3, "')") : "type string (".concat(x(t3), ")");
            }
          }
          __name(Y, "Y");
          function q(t3) {
            var e3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "and";
            switch (t3.length) {
              case 0:
                return "";
              case 1:
                return "".concat(t3[0]);
              case 2:
                return "".concat(t3[0], " ").concat(e3, " ").concat(t3[1]);
              case 3:
                return "".concat(t3[0], ", ").concat(t3[1], ", ").concat(e3, " ").concat(t3[2]);
              default:
                return "".concat(h(b(t3, 0, -1), ", "), ", ").concat(e3, " ").concat(t3[t3.length - 1]);
            }
          }
          __name(q, "q");
          t2.exports = { codes: D, determineSpecificType: Y, E: V, formatList: q, getMessage: Z, hideStackFrames: /* @__PURE__ */ __name(function(t3) {
            function e3() {
              try {
                for (var r2 = arguments.length, n2 = new Array(r2), o2 = 0;o2 < r2; o2++)
                  n2[o2] = arguments[o2];
                return A(t3, this, n2);
              } catch (t4) {
                throw S.stackTraceLimit && P(t4, e3), t4;
              }
            }
            __name(e3, "e");
            return e3.withoutStackTrace = t3, e3;
          }, "hideStackFrames"), isStackOverflowError: /* @__PURE__ */ __name(function(t3) {
            if (s === undefined)
              try {
                var e3 = /* @__PURE__ */ __name(function() {
                  e3();
                }, "e");
                e3();
              } catch (t4) {
                s = t4.message, f = t4.name;
              }
            return t3 && t3.name === f && t3.message === s;
          }, "isStackOverflowError"), kEnhanceStackBeforeInspector: $, kIsNodeError: M, overrideStackTrace: W }, V("ERR_INTERNAL_ASSERTION", function(t3) {
            var e3 = `This is caused by either a bug in Node.js or incorrect usage of Node.js internals.
Please open an issue with this stack trace at https://github.com/nodejs/node/issues
`;
            return t3 === undefined ? e3 : "".concat(t3, `
`).concat(e3);
          }, S), V("ERR_INVALID_ARG_TYPE", function(t3, e3, r2) {
            H(typeof t3 == "string", "'name' must be a string"), p(e3) || (e3 = [e3]);
            var o2 = "The ";
            if (k(t3, " argument"))
              o2 += "".concat(t3, " ");
            else {
              var a2 = I(t3, ".") ? "property" : "argument";
              o2 += '"'.concat(t3, '" ').concat(a2, " ");
            }
            o2 += "must be ";
            var i2, c2 = [], u2 = [], l2 = [], f2 = function(t4, e4) {
              var r3 = typeof Symbol != "undefined" && t4[Symbol.iterator] || t4["@@iterator"];
              if (!r3) {
                if (Array.isArray(t4) || (r3 = function(t5, e5) {
                  if (t5) {
                    if (typeof t5 == "string")
                      return n(t5, e5);
                    var r4 = {}.toString.call(t5).slice(8, -1);
                    return r4 === "Object" && t5.constructor && (r4 = t5.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(t5) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? n(t5, e5) : undefined;
                  }
                }(t4)) || e4 && t4 && typeof t4.length == "number") {
                  r3 && (t4 = r3);
                  var o3 = 0, a3 = /* @__PURE__ */ __name(function() {}, "a");
                  return { s: a3, n: /* @__PURE__ */ __name(function() {
                    return o3 >= t4.length ? { done: true } : { done: false, value: t4[o3++] };
                  }, "n"), e: /* @__PURE__ */ __name(function(t5) {
                    throw t5;
                  }, "e"), f: a3 };
                }
                throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
              }
              var i3, c3 = true, u3 = false;
              return { s: /* @__PURE__ */ __name(function() {
                r3 = r3.call(t4);
              }, "s"), n: /* @__PURE__ */ __name(function() {
                var t5 = r3.next();
                return c3 = t5.done, t5;
              }, "n"), e: /* @__PURE__ */ __name(function(t5) {
                u3 = true, i3 = t5;
              }, "e"), f: /* @__PURE__ */ __name(function() {
                try {
                  c3 || r3.return == null || r3.return();
                } finally {
                  if (u3)
                    throw i3;
                }
              }, "f") };
            }(e3);
            try {
              for (f2.s();!(i2 = f2.n()).done; ) {
                var s2 = i2.value;
                H(typeof s2 == "string", "All expected entries have to be of type string"), g(F, s2) ? d(c2, T(s2)) : O(N, s2) !== null ? d(u2, s2) : (H(s2 !== "object", 'The value "object" should be written as "Object"'), d(l2, s2));
              }
            } catch (t4) {
              f2.e(t4);
            } finally {
              f2.f();
            }
            if (u2.length > 0) {
              var y2 = v(c2, "object");
              y2 !== -1 && (m(c2, y2, 1), d(u2, "Object"));
            }
            return c2.length > 0 && (o2 += "".concat(c2.length > 1 ? "one of type" : "of type", " ").concat(q(c2, "or")), (u2.length > 0 || l2.length > 0) && (o2 += " or ")), u2.length > 0 && (o2 += "an instance of ".concat(q(u2, "or")), l2.length > 0 && (o2 += " or ")), l2.length > 0 && (l2.length > 1 ? o2 += "one of ".concat(q(l2, "or")) : (T(l2[0]) !== l2[0] && (o2 += "an "), o2 += "".concat(l2[0]))), o2 + ". Received ".concat(Y(r2));
          }, z);
        } }, e = {};
        return (/* @__PURE__ */ __name(function r(n) {
          var o = e[n];
          if (o !== undefined)
            return o.exports;
          var a = e[n] = { exports: {} };
          return t[n](a, a.exports, r), a.exports;
        }, "r"))(33);
      })());
    }
  });
  var src_exports = {};
  __export2(src_exports, {
    AbortError: () => AbortError,
    AsyncEventEmitter: () => AsyncEventEmitter
  });
  module.exports = __toCommonJS(src_exports);
  init_cjs_shims();
  init_cjs_shims();
  var import_inspect = __toESM2(require_inspect(), 1);
  var {
    inspect,
    format,
    formatWithOptions,
    stripVTControlCharacters,
    stylizeWithColor,
    stylizeWithHTML,
    Proxy: Proxy2
  } = import_inspect.default;
  function validateListener(input) {
    if (typeof input !== "function") {
      throw new TypeError(`The listener argument must be a function. Received ${typeof input}`);
    }
  }
  __name(validateListener, "validateListener");
  function validateAbortSignal(input) {
    if (input && !(input instanceof AbortSignal)) {
      throw new TypeError(`The signal option must be an AbortSignal. Received ${input}`);
    }
  }
  __name(validateAbortSignal, "validateAbortSignal");
  function spliceOne(list, index) {
    for (;index + 1 < list.length; index++) {
      list[index] = list[index + 1];
    }
    list.pop();
  }
  __name(spliceOne, "spliceOne");
  function arrayClone(arr) {
    switch (arr.length) {
      case 2:
        return [arr[0], arr[1]];
      case 3:
        return [arr[0], arr[1], arr[2]];
      case 4:
        return [arr[0], arr[1], arr[2], arr[3]];
      case 5:
        return [arr[0], arr[1], arr[2], arr[3], arr[4]];
      case 6:
        return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
    }
    return arr.slice();
  }
  __name(arrayClone, "arrayClone");
  function identicalSequenceRange(a, b) {
    for (let i = 0;i < a.length - 3; i++) {
      const pos = b.indexOf(a[i]);
      if (pos !== -1) {
        const rest = b.length - pos;
        if (rest > 3) {
          let len = 1;
          const maxLen = Math.min(a.length - i, rest);
          while (maxLen > len && a[i + len] === b[pos + len]) {
            len++;
          }
          if (len > 3) {
            return [len, i];
          }
        }
      }
    }
    return [0, 0];
  }
  __name(identicalSequenceRange, "identicalSequenceRange");
  function enhanceStackTrace(err, own) {
    let ctorInfo = "";
    try {
      const { name } = this.constructor;
      if (name !== "AsyncEventEmitter")
        ctorInfo = ` on ${name} instance`;
    } catch {}
    const sep = `
Emitted 'error' event${ctorInfo} at:
`;
    const errStack = err.stack.split(`
`).slice(1);
    const ownStack = own.stack.split(`
`).slice(1);
    const { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);
    if (len > 0) {
      ownStack.splice(off + 1, len - 2, "    [... lines matching original stack trace ...]");
    }
    return err.stack + sep + ownStack.join(`
`);
  }
  __name(enhanceStackTrace, "enhanceStackTrace");
  var brandSymbol = Symbol.for("async-event-emitter.ts-brand");
  var kCapturePromiseRejections = Symbol.for("async-event-emitter.ts-capture-promise-rejections");
  var _a;
  _a = kCapturePromiseRejections;
  var _AsyncEventEmitter = class _AsyncEventEmitter2 {
    constructor() {
      this._events = {
        __proto__: null
      };
      this._eventCount = 0;
      this._maxListeners = 10;
      this._internalPromiseMap = /* @__PURE__ */ new Map;
      this._wrapperId = 0n;
      this[_a] = true;
    }
    addListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    on(eventName, listener) {
      return this.addListener(eventName, listener);
    }
    once(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    removeListener(eventName, listener) {
      validateListener(listener);
      const events = this._events;
      const eventList = events[eventName];
      if (eventList === undefined) {
        return this;
      }
      if (eventList === listener || eventList.listener === listener) {
        if (--this._eventCount === 0) {
          this._events = { __proto__: null };
        } else {
          delete events[eventName];
          if (events.removeListener) {
            this.emit("removeListener", eventName, eventList.listener ?? eventList);
          }
        }
      } else if (typeof eventList !== "function") {
        let position = -1;
        for (let i = eventList.length - 1;i >= 0; i--) {
          if (eventList[i] === listener || eventList[i].listener === listener) {
            position = i;
            break;
          }
        }
        if (position < 0) {
          return this;
        }
        if (position === 0) {
          eventList.shift();
        } else {
          spliceOne(eventList, position);
        }
        if (eventList.length === 0) {
          delete events[eventName];
          --this._eventCount;
        }
        if (events.removeListener !== undefined) {
          this.emit("removeListener", eventName, listener);
        }
      }
      return this;
    }
    off(eventName, listener) {
      return this.removeListener(eventName, listener);
    }
    removeAllListeners(event) {
      const events = this._events;
      if (events.removeListener === undefined) {
        if (!event) {
          this._events = { __proto__: null };
          this._eventCount = 0;
        } else if (events[event] !== undefined) {
          if (--this._eventCount === 0) {
            this._events = { __proto__: null };
          } else {
            delete events[event];
          }
        }
        return this;
      }
      if (!event) {
        for (const key of Reflect.ownKeys(events)) {
          if (key === "removeListener") {
            continue;
          }
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = { __proto__: null };
        this._eventCount = 0;
        return this;
      }
      const listeners = events[event];
      if (typeof listeners === "function") {
        this.removeListener(event, listeners);
      } else if (listeners !== undefined) {
        for (let i = listeners.length - 1;i >= 0; i--) {
          this.removeListener(event, listeners[i]);
        }
      }
      return this;
    }
    setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new RangeError(`Expected to get a non-negative number for "setMaxListeners", got ${n} instead`);
      }
      this._maxListeners = n;
      return this;
    }
    getMaxListeners() {
      return this._maxListeners;
    }
    listeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList.listener ?? eventList];
      }
      const ret = arrayClone(eventList);
      for (let i = 0;i < ret.length; ++i) {
        const orig = ret[i].listener;
        if (typeof orig === "function") {
          ret[i] = orig;
        }
      }
      return ret;
    }
    rawListeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList];
      }
      return arrayClone(eventList);
    }
    emit(eventName, ...args) {
      let doError = eventName === "error";
      const events = this._events;
      if (events !== undefined) {
        doError = doError && events.error === undefined;
      } else if (!doError) {
        return false;
      }
      if (doError) {
        let er;
        if (args.length > 0) {
          er = args[0];
        }
        if (er instanceof Error) {
          try {
            const capture = {};
            Error.captureStackTrace(capture, _AsyncEventEmitter2.prototype.emit);
            Object.defineProperty(er, "stack", {
              value: enhanceStackTrace.call(this, er, capture),
              configurable: true
            });
          } catch {}
          throw er;
        }
        let stringifiedError;
        try {
          stringifiedError = inspect(er);
        } catch {
          stringifiedError = String(er);
        }
        const err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);
        err.context = er;
        throw err;
      }
      const handlers = events[eventName];
      if (handlers === undefined) {
        return false;
      }
      if (typeof handlers === "function") {
        const result = handlers.apply(this, args);
        if (result !== undefined && result !== null) {
          handleMaybeAsync(this, result);
        }
      } else {
        const len = handlers.length;
        const listeners = arrayClone(handlers);
        for (let i = 0;i < len; ++i) {
          const result = listeners[i].apply(this, args);
          if (result !== undefined && result !== null) {
            handleMaybeAsync(this, result);
          }
        }
      }
      return true;
    }
    listenerCount(eventName) {
      const events = this._events;
      if (events === undefined) {
        return 0;
      }
      const eventListeners = events[eventName];
      if (typeof eventListeners === "function") {
        return 1;
      }
      return eventListeners?.length ?? 0;
    }
    prependListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    prependOnceListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    eventNames() {
      return this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];
    }
    async waitForAllListenersToComplete() {
      const promises = [...this._internalPromiseMap.values()];
      if (promises.length === 0) {
        return false;
      }
      await Promise.all(promises);
      return true;
    }
    _addListener(eventName, wrappedListener, prepend) {
      if (this._events.newListener !== undefined) {
        this.emit("newListener", eventName, wrappedListener.listener ?? wrappedListener);
      }
      let existing = this._events[eventName];
      if (existing === undefined) {
        existing = this._events[eventName] = wrappedListener;
        ++this._eventCount;
      } else if (typeof existing === "function") {
        existing = this._events[eventName] = prepend ? [wrappedListener, existing] : [existing, wrappedListener];
      } else if (prepend) {
        existing.unshift(wrappedListener);
      } else {
        existing.push(wrappedListener);
      }
      const existingWarnedAboutMaxListeners = Reflect.get(existing, "_hasWarnedAboutMaxListeners");
      if (this._maxListeners > 0 && existing.length > this._maxListeners && !existingWarnedAboutMaxListeners) {
        Reflect.set(existing, "_hasWarnedAboutMaxListeners", true);
        const warningMessage = [
          `Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${this.constructor.name}.`,
          `Use emitter.setMaxListeners() to increase the limit.`
        ].join(" ");
        console.warn(warningMessage);
      }
    }
    _wrapListener(eventName, listener, once) {
      if (!once) {
        return listener;
      }
      const state = {
        fired: false,
        wrapFn: undefined,
        eventEmitter: this,
        eventName,
        listener
      };
      const aliased = onceWrapper;
      const wrapped = aliased.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    static listenerCount(emitter, eventName) {
      return emitter.listenerCount(eventName);
    }
    static async once(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      return new Promise((resolve, reject) => {
        const errorListener = /* @__PURE__ */ __name((err) => {
          emitter.removeListener(eventName, resolver);
          if (signal) {
            eventTargetAgnosticRemoveListener(emitter, eventName, abortListener);
          }
          reject(err);
        }, "errorListener");
        const resolver = /* @__PURE__ */ __name((...args) => {
          emitter.removeListener("error", errorListener);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          resolve(args);
        }, "resolver");
        emitter.once(eventName, resolver);
        if (eventName !== "error") {
          emitter.once("error", errorListener);
        }
        const abortListener = /* @__PURE__ */ __name(() => {
          eventTargetAgnosticRemoveListener(emitter, eventName, resolver);
          eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
          reject(new AbortError(undefined, { cause: getReason(signal) }));
        }, "abortListener");
        if (signal) {
          eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
        }
      });
    }
    static on(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      const unconsumedEvents = [];
      const unconsumedPromises = [];
      let error = null;
      let finished = false;
      const abortListener = /* @__PURE__ */ __name(() => {
        errorHandler(new AbortError(undefined, { cause: getReason(signal) }));
      }, "abortListener");
      const eventHandler = /* @__PURE__ */ __name((...args) => {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEvents.push(args);
        }
      }, "eventHandler");
      const errorHandler = /* @__PURE__ */ __name((err) => {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err);
        } else {
          error = err;
        }
        iterator.return();
      }, "errorHandler");
      const iterator = Object.setPrototypeOf({
        next() {
          const value = unconsumedEvents.shift();
          if (value) {
            return Promise.resolve(createIterResult(value, false));
          }
          if (error) {
            const p = Promise.reject(error);
            error = null;
            return p;
          }
          if (finished) {
            return Promise.resolve(createIterResult(undefined, true));
          }
          return new Promise((resolve, reject) => {
            unconsumedPromises.push({ resolve, reject });
          });
        },
        return() {
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          finished = true;
          const doneResult = createIterResult(undefined, true);
          for (const promise of unconsumedPromises) {
            promise.resolve(doneResult);
          }
          return Promise.resolve(doneResult);
        },
        throw(err) {
          if (!err || !(err instanceof Error)) {
            throw new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);
          }
          error = err;
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      }, AsyncIteratorPrototype);
      emitter.on(eventName, eventHandler);
      if (eventName !== "error") {
        emitter.on("error", errorHandler);
      }
      if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener);
      }
      return iterator;
    }
  };
  __name(_AsyncEventEmitter, "AsyncEventEmitter");
  var AsyncEventEmitter = _AsyncEventEmitter;
  function onceWrapper() {
    if (!this.fired) {
      this.eventEmitter.removeListener(this.eventName, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0) {
        return this.listener.call(this.eventEmitter);
      }
      return this.listener.apply(this.eventEmitter, arguments);
    }
  }
  __name(onceWrapper, "onceWrapper");
  function getReason(signal) {
    return signal?.reason;
  }
  __name(getReason, "getReason");
  function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
    if (typeof emitter.off === "function") {
      emitter.off(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
      emitter.removeEventListener(name, listener, flags);
    }
  }
  __name(eventTargetAgnosticRemoveListener, "eventTargetAgnosticRemoveListener");
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags?.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, listener, flags);
    }
  }
  __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);
  function createIterResult(value, done) {
    return { value, done };
  }
  __name(createIterResult, "createIterResult");
  var _AbortError = class _AbortError2 extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object") {
        throw new TypeError(`Failed to create AbortError: options is not an object or undefined`);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  };
  __name(_AbortError, "AbortError");
  var AbortError = _AbortError;
  function handleMaybeAsync(emitter, result) {
    if (!emitter[kCapturePromiseRejections]) {
      return;
    }
    try {
      const the = result.then;
      const fin = result.finally;
      let handledPromise = result;
      if (typeof the === "function") {
        handledPromise = the.call(result, undefined, (error) => {
          emitErrorFromRejectionHandler(emitter, error);
        });
      }
      if (typeof fin === "function") {
        const promiseId = String(++emitter["_wrapperId"]);
        emitter["_internalPromiseMap"].set(promiseId, result);
        fin.call(handledPromise, /* @__PURE__ */ __name(function final() {
          emitter["_internalPromiseMap"].delete(promiseId);
        }, "final"));
      }
    } catch (err) {
      emitter.emit("error", err);
    }
  }
  __name(handleMaybeAsync, "handleMaybeAsync");
  function emitErrorFromRejectionHandler(emitter, error) {
    setTimeout(() => {
      try {
        emitter[kCapturePromiseRejections] = false;
        emitter.emit("error", error);
      } finally {
        emitter[kCapturePromiseRejections] = true;
      }
    }, 0);
  }
  __name(emitErrorFromRejectionHandler, "emitErrorFromRejectionHandler");
  /*! Bundled license information:
  
  node-inspect-extracted/dist/inspect.js:
    (*! For license information please see inspect.js.LICENSE.txt *)
  */
});

// ../../node_modules/magic-bytes.js/dist/model/toHex.js
var require_toHex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromHex = exports.toHex = undefined;
  var hex = (num) => new Number(num).toString(16).toLowerCase();
  var toHex = (num) => `0x${hex(num).length === 1 ? "0" + hex(num) : hex(num)}`;
  exports.toHex = toHex;
  var fromHex = (hex2) => new Number(hex2);
  exports.fromHex = fromHex;
});

// ../../node_modules/magic-bytes.js/dist/model/tree.js
var require_tree = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createComplexNode = exports.createNode = exports.merge = undefined;
  var createMatch = (leaf) => ({
    typename: leaf.typename,
    mime: leaf.info.mime,
    extension: leaf.info.extension
  });
  var isLeafNode = (tree, path) => tree && path.length === 0;
  var merge = (node, tree) => {
    if (node.bytes.length === 0)
      return tree;
    const [currentByte, ...path] = node.bytes;
    const currentTree = tree.bytes[currentByte];
    if (isLeafNode(currentTree, path)) {
      const matchingNode = tree.bytes[currentByte];
      tree.bytes[currentByte] = {
        ...matchingNode,
        matches: [
          ...matchingNode.matches ?? [],
          createMatch(node)
        ]
      };
      return tree;
    }
    if (tree.bytes[currentByte]) {
      tree.bytes[currentByte] = exports.merge(exports.createNode(node.typename, path, node.info), tree.bytes[currentByte]);
    } else {
      tree.bytes[currentByte] = exports.createComplexNode(node.typename, path, node.info);
    }
    return tree;
  };
  exports.merge = merge;
  var createNode = (typename, bytes, info) => {
    return { typename, bytes, info: info ? info : {} };
  };
  exports.createNode = createNode;
  var createComplexNode = (typename, bytes, info) => {
    let obj = {
      bytes: {},
      matches: undefined
    };
    const [currentKey, ...path] = bytes;
    if (bytes.length === 0) {
      return {
        matches: [
          createMatch({
            typename,
            info: info ? { extension: info.extension, mime: info.mime } : {}
          })
        ],
        bytes: {}
      };
    }
    obj.bytes[currentKey] = exports.createComplexNode(typename, path, info);
    return obj;
  };
  exports.createComplexNode = createComplexNode;
});

// ../../node_modules/magic-bytes.js/dist/model/pattern-tree.js
var require_pattern_tree = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTree = exports.add = undefined;
  var toHex_1 = require_toHex();
  var tree_1 = require_tree();
  var tree = {
    noOffset: null,
    offset: {}
  };
  var add = (typename, signature, additionalInfo, offset) => {
    if (offset) {
      const existing = tree.offset[toHex_1.toHex(offset)];
      if (!existing) {
        tree.offset[toHex_1.toHex(offset)] = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        const merged = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), { ...existing });
        tree.offset[toHex_1.toHex(offset)] = merged;
      }
    } else {
      if (tree.noOffset === null) {
        tree.noOffset = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        tree.noOffset = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), tree.noOffset);
      }
    }
  };
  exports.add = add;
  exports.add("gif", ["0x47", "0x49", "0x46", "0x38", "0x37", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  exports.add("gif", ["0x47", "0x49", "0x46", "0x38", "0x39", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  exports.add("jpg", ["0xFF", "0xD8", "0xFF"], {
    mime: "image/jpeg",
    extension: "jpeg"
  });
  exports.add("webp", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x45",
    "0x42",
    "0x50"
  ], { mime: "image/webp", extension: "webp" });
  exports.add("heif", ["0x66", "0x74", "0x79", "0x70", "0x6D", "0x69", "0x66", "0x31"], { mime: "image/heif", extension: "heif" }, 4);
  exports.add("heif", ["0x66", "0x74", "0x79", "0x70", "0x68", "0x65", "0x69", "0x63"], { mime: "image/heif", extension: "heic" }, 4);
  exports.add("rpm", ["0xed", "0xab", "0xee", "0xdb"]);
  exports.add("bin", ["0x53", "0x50", "0x30", "0x31"], {
    mime: "application/octet-stream",
    extension: "bin"
  });
  exports.add("pic", ["0x00"]);
  exports.add("pif", ["0x00"]);
  exports.add("sea", ["0x00"]);
  exports.add("ytr", ["0x00"]);
  exports.add("mp4", ["0x66", "0x74", "0x79", "0x70"], { mime: "video/mp4", extension: "mp4" }, 4);
  exports.add("ttf", ["0x00", "0x01", "0x00", "0x00", "0x00"], {
    mime: "font/ttf",
    extension: "ttf"
  });
  exports.add("otf", ["0x4F", "0x54", "0x54", "0x4F"], {
    mime: "font/otf",
    extension: "otf"
  });
  exports.add("eot", ["0x50", "0x4C"], {
    mime: "application/vnd.ms-fontobject",
    extension: "eot"
  });
  exports.add("woff", ["0x77", "0x4F", "0x46", "0x46"], {
    mime: "font/woff",
    extension: "woff"
  });
  exports.add("woff2", ["0x77", "0x4F", "0x46", "0x32"], {
    mime: "font/woff2",
    extension: "woff2"
  });
  exports.add("pdb", [
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ]);
  exports.add("dba", ["0xBE", "0xBA", "0xFE", "0xCA"]);
  exports.add("dba2", ["0x00", "0x01", "0x42", "0x44"]);
  exports.add("tda", ["0x00", "0x01", "0x44", "0x54"]);
  exports.add("tda2", ["0x00", "0x01", "0x00", "0x00"]);
  exports.add("ico", ["0x00", "0x00", "0x01", "0x00"], {
    mime: "image/x-icon",
    extension: "ico"
  });
  exports.add("3gp", ["0x66", "0x74", "0x79", "0x70", "0x33", "0x67"]);
  exports.add("z", ["0x1F", "0x9D"]);
  exports.add("tar.z", ["0x1F", "0xA0"]);
  exports.add("bac", [
    "0x42",
    "0x41",
    "0x43",
    "0x4B",
    "0x4D",
    "0x49",
    "0x4B",
    "0x45",
    "0x44",
    "0x49",
    "0x53",
    "0x4B"
  ]);
  exports.add("bz2", ["0x42", "0x5A", "0x68"], {
    mime: "application/x-bzip2",
    extension: "bz2"
  });
  exports.add("tif", ["0x49", "0x49", "0x2A", "0x00"], {
    mime: "image/tiff",
    extension: "tif"
  });
  exports.add("tiff", ["0x4D", "0x4D", "0x00", "0x2A"], {
    mime: "image/tiff",
    extension: "tiff"
  });
  exports.add("cr2", [
    "0x49",
    "0x49",
    "0x2A",
    "0x00",
    "0x10",
    "0x00",
    "0x00",
    "0x00",
    "0x43",
    "0x52"
  ]);
  exports.add("cin", ["0x80", "0x2A", "0x5F", "0xD7"]);
  exports.add("cin1", ["0x52", "0x4E", "0x43", "0x01"]);
  exports.add("cin2", ["0x52", "0x4E", "0x43", "0x02"]);
  exports.add("dpx", ["0x53", "0x44", "0x50", "0x58"]);
  exports.add("dpx2", ["0x58", "0x50", "0x44", "0x53"]);
  exports.add("exr", ["0x76", "0x2F", "0x31", "0x01"]);
  exports.add("bpg", ["0x42", "0x50", "0x47", "0xFB"]);
  exports.add("ilbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x49",
    "0x4C",
    "0x42",
    "0x4D"
  ]);
  exports.add("8svx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x38",
    "0x53",
    "0x56",
    "0x58"
  ]);
  exports.add("acbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x43",
    "0x42",
    "0x4D"
  ]);
  exports.add("anbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x42",
    "0x4D"
  ]);
  exports.add("anim", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x49",
    "0x4D"
  ]);
  exports.add("faxx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x58",
    "0x58"
  ]);
  exports.add("ftxt", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x54",
    "0x58",
    "0x54"
  ]);
  exports.add("smus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  exports.add("cmus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x43",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  exports.add("yuvn", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x59",
    "0x55",
    "0x56",
    "0x4E"
  ]);
  exports.add("iff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x4E",
    "0x54"
  ]);
  exports.add("aiff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x49",
    "0x46",
    "0x46"
  ], { mime: "audio/x-aiff", extension: "aiff" });
  exports.add("idx", ["0x49", "0x4E", "0x44", "0x58"]);
  exports.add("lz", ["0x4C", "0x5A", "0x49", "0x50"]);
  exports.add("exe", ["0x4D", "0x5A"]);
  exports.add("zip", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/zip",
    extension: "zip"
  });
  exports.add("zip", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/zip",
    extension: "zip"
  });
  exports.add("zip", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/zip",
    extension: "zip"
  });
  exports.add("jar", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  exports.add("jar", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  exports.add("jar", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  exports.add("odt", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  exports.add("odt", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  exports.add("odt", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  exports.add("ods", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  exports.add("ods", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  exports.add("ods", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  exports.add("odp", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  exports.add("odp", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  exports.add("odp", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  exports.add("docx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  exports.add("docx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  exports.add("docx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  exports.add("xlsx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  exports.add("xlsx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  exports.add("xlsx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  exports.add("pptx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  exports.add("pptx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  exports.add("pptx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  exports.add("vsdx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  exports.add("vsdx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  exports.add("vsdx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  exports.add("apk", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  exports.add("apk", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  exports.add("apk", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  exports.add("aar", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  exports.add("aar", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  exports.add("aar", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  exports.add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  exports.add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x01", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  exports.add("rar", ["0x7F", "0x45", "0x4C", "0x46"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  exports.add("png", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/png",
    extension: "png"
  });
  exports.add("apng", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/apng",
    extension: "apng"
  });
  exports.add("class", ["0xCA", "0xFE", "0xBA", "0xBE"]);
  exports.add("class", ["0xEF", "0xBB", "0xBF"]);
  exports.add("class", ["0xFE", "0xed", "0xFA", "0xCE"], undefined, 4096);
  exports.add("class", ["0xFE", "0xed", "0xFA", "0xCF"], undefined, 4096);
  exports.add("class", ["0xCE", "0xFA", "0xed", "0xFE"]);
  exports.add("class", ["0xCF", "0xFA", "0xed", "0xFE"]);
  exports.add("class", ["0xFF", "0xFE"]);
  exports.add("class", ["0xFF", "0xFE"]);
  exports.add("class", ["0xFF", "0xFE", "0x00", "0x00"]);
  exports.add("ps", ["0x25", "0x21", "0x50", "0x53"], {
    mime: "application/postscript",
    extension: ".ps"
  });
  exports.add("pdf", ["0x25", "0x50", "0x44", "0x46"], {
    mime: "application/pdf",
    extension: "pdf"
  });
  exports.add("asf", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  exports.add("wma", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  exports.add("wmv", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  exports.add("deploymentimage", [
    "0x24",
    "0x53",
    "0x44",
    "0x49",
    "0x30",
    "0x30",
    "0x30",
    "0x31"
  ]);
  exports.add("ogv", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x80",
    "0x74",
    "0x68",
    "0x65",
    "0x6F",
    "0x72",
    "0x61"
  ], {
    mime: "video/ogg",
    extension: "ogv"
  });
  exports.add("ogm", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x69",
    "0x64",
    "0x65",
    "0x6F",
    "0x00"
  ], {
    mime: "video/ogg",
    extension: "ogm"
  });
  exports.add("oga", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x7F",
    "0x46",
    "0x4C",
    "0x41",
    "0x43"
  ], {
    mime: "audio/ogg",
    extension: "oga"
  });
  exports.add("spx", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x70",
    "0x65",
    "0x65",
    "0x78",
    "0x20",
    "0x20"
  ], {
    mime: "audio/ogg",
    extension: "spx"
  });
  exports.add("ogg", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x6F",
    "0x72",
    "0x62",
    "0x69",
    "0x73"
  ], {
    mime: "audio/ogg",
    extension: "ogg"
  });
  exports.add("ogx", ["0x4F", "0x67", "0x67", "0x53"], {
    mime: "application/ogg",
    extension: "ogx"
  });
  exports.add("psd", ["0x38", "0x42", "0x50", "0x53"], {
    mime: "application/x-photoshop",
    extension: "psd"
  });
  exports.add("clip", ["0x43", "0x53", "0x46", "0x43", "0x48", "0x55", "0x4e", "0x4b"]);
  exports.add("wav", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x41",
    "0x56",
    "0x45"
  ], { mime: "audio/x-wav", extension: "wav" });
  exports.add("avi", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x56",
    "0x49",
    "0x20"
  ], { mime: "video/x-msvideo", extension: "avi" });
  exports.add("mp3", ["0xFF", "0xFB"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("mp3", ["0xFF", "0xF3"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("mp3", ["0xFF", "0xF2"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("mp3", ["0x49", "0x44", "0x33"], { mime: "audio/mpeg", extension: "mp3" });
  exports.add("bmp", ["0x42", "0x4D"], { mime: "image/bmp", extension: "bmp" });
  exports.add("iso", ["0x43", "0x44", "0x30", "0x30", "0x31"]);
  exports.add("flac", ["0x66", "0x4C", "0x61", "0x43"]);
  exports.add("mid", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "mid"
  });
  exports.add("midi", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "midi"
  });
  exports.add("doc", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/msword",
    extension: "doc"
  });
  exports.add("xls", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-excel",
    extension: "xls"
  });
  exports.add("ppt", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-powerpoint",
    extension: "ppt"
  });
  exports.add("msg", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"]);
  exports.add("dex", ["0x64", "0x65", "0x78", "0x0A", "0x30", "0x33", "0x35", "0x00"]);
  exports.add("vmdk", ["0x4B", "0x44", "0x4D"]);
  exports.add("crx", ["0x43", "0x72", "0x32", "0x34"]);
  exports.add("fh8", ["0x41", "0x47", "0x44", "0x33"]);
  exports.add("cwk", [
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  exports.add("cwk", [
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  exports.add("toast", ["0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  exports.add("toast", ["0x8B", "0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  exports.add("dmg", ["0x78", "0x01", "0x73", "0x0D", "0x62", "0x62", "0x60"]);
  exports.add("xar", ["0x78", "0x61", "0x72", "0x21"]);
  exports.add("dat", ["0x50", "0x4D", "0x4F", "0x43", "0x43", "0x4D", "0x4F", "0x43"]);
  exports.add("nes", ["0x4E", "0x45", "0x53", "0x1A"]);
  exports.add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x00", "0x30", "0x30"], {
    mime: "application/x-tar",
    extension: "tar"
  }, 257);
  exports.add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x20", "0x20", "0x00"], {
    mime: "application/x-tar",
    extension: "tar"
  }, 257);
  exports.add("tox", ["0x74", "0x6F", "0x78", "0x33"]);
  exports.add("mlv", ["0x4D", "0x4C", "0x56", "0x49"]);
  exports.add("windowsupdate", [
    "0x44",
    "0x43",
    "0x4D",
    "0x01",
    "0x50",
    "0x41",
    "0x33",
    "0x30"
  ]);
  exports.add("7z", ["0x37", "0x7A", "0xBC", "0xAF", "0x27", "0x1C"], {
    mime: "application/x-7z-compressed",
    extension: "7z"
  });
  exports.add("gz", ["0x1F", "0x8B"], { mime: "application/gzip", extension: "gz" });
  exports.add("tar.gz", ["0x1F", "0x8B"], {
    mime: "application/gzip",
    extension: "tar.gz"
  });
  exports.add("xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "xz"
  });
  exports.add("tar.xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "tar.xz"
  });
  exports.add("lz2", ["0x04", "0x22", "0x4D", "0x18"]);
  exports.add("cab", ["0x4D", "0x53", "0x43", "0x46"]);
  exports.add("mkv", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "video/x-matroska",
    extension: "mkv"
  });
  exports.add("mka", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "audio/x-matroska",
    extension: "mka"
  });
  exports.add("mks", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "video/x-matroska",
    extension: "mks"
  });
  exports.add("mk3d", ["0x1A", "0x45", "0xDF", "0xA3"]);
  exports.add("webm", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "audio/webm",
    extension: "webm"
  });
  exports.add("dcm", ["0x44", "0x49", "0x43", "0x4D"], undefined, 128);
  exports.add("xml", ["0x3C", "0x3f", "0x78", "0x6d", "0x6C", "0x20"], {
    mime: "application/xml",
    extension: "xml"
  });
  exports.add("wasm", ["0x00", "0x61", "0x73", "0x6d"], {
    mime: "application/wasm",
    extension: "wasm"
  });
  exports.add("lep", ["0xCF", "0x84", "0x01"]);
  exports.add("swf", ["0x43", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  exports.add("swf", ["0x46", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  exports.add("deb", ["0x21", "0x3C", "0x61", "0x72", "0x63", "0x68", "0x3E"]);
  exports.add("rtf", ["0x7B", "0x5C", "0x72", "0x74", "0x66", "0x31"], {
    mime: "application/rtf",
    extension: "rtf"
  });
  exports.add("m2p", ["0x00", "0x00", "0x01", "0xBA"]);
  exports.add("vob", ["0x00", "0x00", "0x01", "0xBA"]);
  exports.add("mpg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpg"
  });
  exports.add("mpeg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  exports.add("mpeg", ["0x47"], { mime: "video/mpeg", extension: "mpeg" });
  exports.add("mpeg", ["0x00", "0x00", "0x01", "0xB3"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  exports.add("mov", ["0x66", "0x72", "0x65", "0x65"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x6D", "0x64", "0x61", "0x74"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x6D", "0x6F", "0x6F", "0x76"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x77", "0x69", "0x64", "0x65"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("mov", ["0x66", "0x74", "0x79", "0x70", "0x71", "0x74"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  exports.add("hl2demo", ["0x48", "0x4C", "0x32", "0x44", "0x45", "0x4D", "0x4F"]);
  exports.add("txt", ["0xEF", "0xBB", "0xBF"], {
    mime: "text/plain; charset=UTF-8",
    extension: "txt"
  });
  exports.add("txt", ["0xFF", "0xFE"], {
    mime: "text/plain; charset=UTF-16LE",
    extension: "txt"
  });
  exports.add("txt", ["0xFE", "0xFF"], {
    mime: "text/plain; charset=UTF-16BE",
    extension: "txt"
  });
  exports.add("txt", ["0xFF", "0xFE", "0x00", "0x00"], {
    mime: "text/plain; charset=UTF-32LE",
    extension: "txt"
  });
  exports.add("txt", ["0x00", "0x00", "0xFE", "0xFF"], {
    mime: "text/plain; charset=UTF-32BE",
    extension: "txt"
  });
  exports.add("SubRip", ["0x31", "0x0D", "0x0A", "0x30", "0x30", "0x3A"], {
    mime: "application/x-subrip",
    extension: "srt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0A"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0D"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x20"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x09"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0A"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0D"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x20"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x09"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  exports.add("Json", ["0x7B"], {
    mime: "application/json",
    extension: ".json"
  });
  exports.add("Json", ["0x5B"], {
    mime: "application/json",
    extension: ".json"
  });
  exports.add("ELF", ["0x7F", "0x45", "0x4C", "0x46"], {
    mime: "application/x-executable",
    extension: ".elf"
  });
  exports.add("Mach-O", ["0xFE", "0xED", "0xFA", "0xC"], {
    mime: "application/x-mach-binary",
    extension: ".o"
  });
  exports.add("Mach-O", ["0xFE", "0xED", "0xFA", "0xCF"], {
    mime: "application/x-executable",
    extension: "elf"
  });
  exports.add("EML", ["0x52", "0x65", "0x63", "0x65", "0x69", "0x76", "0x65", "0x64", "0x3A"], {
    mime: "message/rfc822",
    extension: ".eml"
  });
  exports.add("SVG", ["0x3c", "0x73", "0x76", "0x67"], {
    mime: "image/svg+xml",
    extension: "svg"
  });
  exports.add("avif", ["0x66", "0x74", "0x79", "0x70", "0x61", "0x76", "0x69", "0x66"], {
    mime: "image/avif",
    extension: "avif"
  }, 4);
  var createTree = () => tree;
  exports.createTree = createTree;
  exports.default = () => tree;
});

// ../../node_modules/magic-bytes.js/dist/index.js
var require_dist4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.register = exports.filetypeextension = exports.filetypemime = exports.filetypename = exports.filetypeinfo = undefined;
  var pattern_tree_1 = require_pattern_tree();
  var toHex_1 = require_toHex();
  var patternTree = pattern_tree_1.createTree();
  var filetypeinfo = (bytes) => {
    let tree = patternTree;
    for (const k of Object.keys(tree.offset)) {
      const offset = toHex_1.fromHex(k);
      const offsetExceedsFile = offset >= bytes.length;
      if (offsetExceedsFile) {
        continue;
      }
      const node = patternTree.offset[k];
      const guessed = walkTree(offset, bytes, node);
      if (guessed.length > 0) {
        return guessed;
      }
    }
    if (tree.noOffset === null) {
      return [];
    }
    return walkTree(0, bytes, tree.noOffset);
  };
  exports.filetypeinfo = filetypeinfo;
  var walkTree = (index, bytes, node) => {
    let step = node;
    let guessFile = [];
    while (true) {
      const currentByte = toHex_1.toHex(bytes[index]);
      if (step.bytes["?"] && !step.bytes[currentByte]) {
        step = step.bytes["?"];
      } else {
        step = step.bytes[currentByte];
      }
      if (!step) {
        return guessFile;
      }
      if (step && step.matches) {
        guessFile = step.matches.slice(0);
      }
      index += 1;
    }
  };
  exports.default = exports.filetypeinfo;
  var filetypename = (bytes) => exports.filetypeinfo(bytes).map((e) => e.typename);
  exports.filetypename = filetypename;
  var filetypemime = (bytes) => exports.filetypeinfo(bytes).map((e) => e.mime ? e.mime : null).filter((x) => x !== null);
  exports.filetypemime = filetypemime;
  var filetypeextension = (bytes) => exports.filetypeinfo(bytes).map((e) => e.extension ? e.extension : null).filter((x) => x !== null);
  exports.filetypeextension = filetypeextension;
  var register = (typename, signature, additionalInfo, offset) => {
    pattern_tree_1.add(typename, signature, additionalInfo, offset);
  };
  exports.register = register;
});

// ../../node_modules/@sapphire/async-queue/dist/cjs/index.cjs
var require_cjs2 = __commonJS((exports) => {
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var _AsyncQueueEntry = class _AsyncQueueEntry2 {
    constructor(queue) {
      __publicField(this, "promise");
      __publicField(this, "resolve");
      __publicField(this, "reject");
      __publicField(this, "queue");
      __publicField(this, "signal", null);
      __publicField(this, "signalListener", null);
      this.queue = queue;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
    }
    setSignal(signal) {
      if (signal.aborted)
        return this;
      this.signal = signal;
      this.signalListener = () => {
        const index = this.queue["promises"].indexOf(this);
        if (index !== -1)
          this.queue["promises"].splice(index, 1);
        this.reject(new Error("Request aborted manually"));
      };
      this.signal.addEventListener("abort", this.signalListener);
      return this;
    }
    use() {
      this.dispose();
      this.resolve();
      return this;
    }
    abort() {
      this.dispose();
      this.reject(new Error("Request aborted manually"));
      return this;
    }
    dispose() {
      if (this.signal) {
        this.signal.removeEventListener("abort", this.signalListener);
        this.signal = null;
        this.signalListener = null;
      }
    }
  };
  __name(_AsyncQueueEntry, "AsyncQueueEntry");
  var AsyncQueueEntry = _AsyncQueueEntry;
  var _AsyncQueue = class _AsyncQueue2 {
    constructor() {
      __publicField(this, "promises", []);
    }
    get remaining() {
      return this.promises.length;
    }
    get queued() {
      return this.remaining === 0 ? 0 : this.remaining - 1;
    }
    wait(options) {
      const entry = new AsyncQueueEntry(this);
      if (this.promises.length === 0) {
        this.promises.push(entry);
        return Promise.resolve();
      }
      this.promises.push(entry);
      if (options?.signal)
        entry.setSignal(options.signal);
      return entry.promise;
    }
    shift() {
      if (this.promises.length === 0)
        return;
      if (this.promises.length === 1) {
        this.promises.shift();
        return;
      }
      this.promises.shift();
      this.promises[0].use();
    }
    abortAll() {
      if (this.queued === 0)
        return;
      for (let i = 1;i < this.promises.length; ++i) {
        this.promises[i].abort();
      }
      this.promises.length = 1;
    }
  };
  __name(_AsyncQueue, "AsyncQueue");
  var AsyncQueue = _AsyncQueue;
  exports.AsyncQueue = AsyncQueue;
});

// ../../node_modules/@discordjs/rest/dist/index.js
var require_dist5 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
    ALLOWED_SIZES: () => ALLOWED_SIZES,
    ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
    BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
    CDN: () => CDN,
    DEPRECATION_WARNING_PREFIX: () => DEPRECATION_WARNING_PREFIX,
    DefaultRestOptions: () => DefaultRestOptions,
    DefaultUserAgent: () => DefaultUserAgent,
    DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
    DiscordAPIError: () => DiscordAPIError,
    HTTPError: () => HTTPError,
    OverwrittenMimeTypes: () => OverwrittenMimeTypes,
    REST: () => REST,
    RESTEvents: () => RESTEvents,
    RateLimitError: () => RateLimitError,
    RequestMethod: () => RequestMethod,
    calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
    makeURLSearchParams: () => makeURLSearchParams,
    parseResponse: () => parseResponse,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var import_node_buffer = __require("buffer");
  var import_util2 = require_dist();
  var import_undici2 = __require("undici");
  var defaultStrategy;
  function setDefaultStrategy(newStrategy) {
    defaultStrategy = newStrategy;
  }
  __name(setDefaultStrategy, "setDefaultStrategy");
  function getDefaultStrategy() {
    return defaultStrategy;
  }
  __name(getDefaultStrategy, "getDefaultStrategy");
  var import_node_http = __require("http");
  var import_node_url = __require("url");
  var import_node_util = __require("util");
  var import_undici = __require("undici");
  async function makeRequest(url, init) {
    const options = {
      ...init,
      body: await resolveBody(init.body)
    };
    const res = await (0, import_undici.request)(url, options);
    return {
      body: res.body,
      async arrayBuffer() {
        return res.body.arrayBuffer();
      },
      async json() {
        return res.body.json();
      },
      async text() {
        return res.body.text();
      },
      get bodyUsed() {
        return res.body.bodyUsed;
      },
      headers: new import_undici.Headers(res.headers),
      status: res.statusCode,
      statusText: import_node_http.STATUS_CODES[res.statusCode],
      ok: res.statusCode >= 200 && res.statusCode < 300
    };
  }
  __name(makeRequest, "makeRequest");
  async function resolveBody(body) {
    if (body == null) {
      return null;
    } else if (typeof body === "string") {
      return body;
    } else if (import_node_util.types.isUint8Array(body)) {
      return body;
    } else if (import_node_util.types.isArrayBuffer(body)) {
      return new Uint8Array(body);
    } else if (body instanceof import_node_url.URLSearchParams) {
      return body.toString();
    } else if (body instanceof DataView) {
      return new Uint8Array(body.buffer);
    } else if (body instanceof Blob) {
      return new Uint8Array(await body.arrayBuffer());
    } else if (body instanceof FormData) {
      return body;
    } else if (body[Symbol.iterator]) {
      const chunks = [...body];
      return Buffer.concat(chunks);
    } else if (body[Symbol.asyncIterator]) {
      const chunks = [];
      for await (const chunk of body) {
        chunks.push(chunk);
      }
      return Buffer.concat(chunks);
    }
    throw new TypeError(`Unable to resolve body.`);
  }
  __name(resolveBody, "resolveBody");
  var import_v102 = require_v106();
  var import_util = require_dist();
  var import_v10 = require_v106();
  var DefaultUserAgent = `DiscordBot (https://discord.js.org, 2.6.0)`;
  var DefaultUserAgentAppendix = (0, import_util.getUserAgentAppendix)();
  var DefaultRestOptions = {
    agent: null,
    api: "https://discord.com/api",
    authPrefix: "Bot",
    cdn: "https://cdn.discordapp.com",
    headers: {},
    invalidRequestWarningInterval: 0,
    globalRequestsPerSecond: 50,
    offset: 50,
    rejectOnRateLimit: null,
    retries: 3,
    timeout: 15000,
    userAgentAppendix: DefaultUserAgentAppendix,
    version: import_v10.APIVersion,
    hashSweepInterval: 14400000,
    hashLifetime: 86400000,
    handlerSweepInterval: 3600000,
    async makeRequest(...args) {
      return getDefaultStrategy()(...args);
    },
    mediaProxy: "https://media.discordapp.net"
  };
  var RESTEvents = /* @__PURE__ */ ((RESTEvents2) => {
    RESTEvents2["Debug"] = "restDebug";
    RESTEvents2["HandlerSweep"] = "handlerSweep";
    RESTEvents2["HashSweep"] = "hashSweep";
    RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
    RESTEvents2["RateLimited"] = "rateLimited";
    RESTEvents2["Response"] = "response";
    return RESTEvents2;
  })(RESTEvents || {});
  var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
  var ALLOWED_STICKER_EXTENSIONS = ["png", "json", "gif"];
  var ALLOWED_SIZES = [
    16,
    32,
    64,
    128,
    256,
    512,
    1024,
    2048,
    4096
  ];
  var OverwrittenMimeTypes = {
    "image/apng": "image/png"
  };
  var BurstHandlerMajorIdKey = "burst";
  var DEPRECATION_WARNING_PREFIX = "DeprecationWarning";
  var RateLimitError = class _RateLimitError extends Error {
    static {
      __name(this, "RateLimitError");
    }
    timeToReset;
    limit;
    method;
    hash;
    url;
    route;
    majorParameter;
    global;
    retryAfter;
    sublimitTimeout;
    scope;
    constructor({
      timeToReset,
      limit,
      method,
      hash,
      url,
      route,
      majorParameter,
      global: global2,
      retryAfter,
      sublimitTimeout,
      scope
    }) {
      super();
      this.timeToReset = timeToReset;
      this.limit = limit;
      this.method = method;
      this.hash = hash;
      this.url = url;
      this.route = route;
      this.majorParameter = majorParameter;
      this.global = global2;
      this.retryAfter = retryAfter;
      this.sublimitTimeout = sublimitTimeout;
      this.scope = scope;
    }
    get name() {
      return `${_RateLimitError.name}[${this.route}]`;
    }
  };
  var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
    RequestMethod2["Delete"] = "DELETE";
    RequestMethod2["Get"] = "GET";
    RequestMethod2["Patch"] = "PATCH";
    RequestMethod2["Post"] = "POST";
    RequestMethod2["Put"] = "PUT";
    return RequestMethod2;
  })(RequestMethod || {});
  function serializeSearchParam(value) {
    switch (typeof value) {
      case "string":
        return value;
      case "number":
      case "bigint":
      case "boolean":
        return value.toString();
      case "object":
        if (value === null)
          return null;
        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }
        if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
          return value.toString();
        return null;
      default:
        return null;
    }
  }
  __name(serializeSearchParam, "serializeSearchParam");
  function makeURLSearchParams(options) {
    const params = new URLSearchParams;
    if (!options)
      return params;
    for (const [key, value] of Object.entries(options)) {
      const serialized = serializeSearchParam(value);
      if (serialized !== null)
        params.append(key, serialized);
    }
    return params;
  }
  __name(makeURLSearchParams, "makeURLSearchParams");
  async function parseResponse(res) {
    if (res.headers.get("Content-Type")?.startsWith("application/json")) {
      return res.json();
    }
    return res.arrayBuffer();
  }
  __name(parseResponse, "parseResponse");
  function hasSublimit(bucketRoute, body, method) {
    if (bucketRoute === "/channels/:id") {
      if (typeof body !== "object" || body === null)
        return false;
      if (method !== "PATCH")
        return false;
      const castedBody = body;
      return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
    }
    return true;
  }
  __name(hasSublimit, "hasSublimit");
  function shouldRetry(error) {
    if (error.name === "AbortError")
      return true;
    return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
  }
  __name(shouldRetry, "shouldRetry");
  async function onRateLimit(manager, rateLimitData) {
    const { options } = manager;
    if (!options.rejectOnRateLimit)
      return;
    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
    if (shouldThrow) {
      throw new RateLimitError(rateLimitData);
    }
  }
  __name(onRateLimit, "onRateLimit");
  function calculateUserDefaultAvatarIndex(userId) {
    return Number(BigInt(userId) >> 22n) % 6;
  }
  __name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
  async function sleep(ms) {
    return new Promise((resolve) => {
      setTimeout(() => resolve(), ms);
    });
  }
  __name(sleep, "sleep");
  function isBufferLike(value) {
    return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
  }
  __name(isBufferLike, "isBufferLike");
  function deprecationWarning(message) {
    if (typeof globalThis.process === "undefined") {
      console.warn(`${DEPRECATION_WARNING_PREFIX}: ${message}`);
    } else {
      process.emitWarning(message, DEPRECATION_WARNING_PREFIX);
    }
  }
  __name(deprecationWarning, "deprecationWarning");
  function normalizeRateLimitOffset(offset, route) {
    if (typeof offset === "number") {
      return Math.max(0, offset);
    }
    const result = offset(route);
    return Math.max(0, result);
  }
  __name(normalizeRateLimitOffset, "normalizeRateLimitOffset");
  var deprecationEmittedForEmoji = false;
  var CDN = class {
    constructor(cdn = DefaultRestOptions.cdn, mediaProxy = DefaultRestOptions.mediaProxy) {
      this.cdn = cdn;
      this.mediaProxy = mediaProxy;
    }
    static {
      __name(this, "CDN");
    }
    appAsset(clientId, assetHash, options) {
      return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
    }
    appIcon(clientId, iconHash, options) {
      return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
    }
    avatar(id, avatarHash, options) {
      return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
    }
    avatarDecoration(userIdOrAsset, userAvatarDecoration, options) {
      if (userAvatarDecoration) {
        return this.makeURL(`/avatar-decorations/${userIdOrAsset}/${userAvatarDecoration}`, options);
      }
      return this.makeURL(`/avatar-decoration-presets/${userIdOrAsset}`, { extension: "png" });
    }
    banner(id, bannerHash, options) {
      return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
    }
    channelIcon(channelId, iconHash, options) {
      return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
    }
    defaultAvatar(index) {
      return this.makeURL(`/embed/avatars/${index}`, { extension: "png" });
    }
    discoverySplash(guildId, splashHash, options) {
      return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
    }
    emoji(emojiId, options) {
      let resolvedOptions;
      if (typeof options === "string") {
        if (!deprecationEmittedForEmoji) {
          deprecationWarning("Passing a string for the second parameter of CDN#emoji() is deprecated. Use an object instead.");
          deprecationEmittedForEmoji = true;
        }
        resolvedOptions = { extension: options };
      } else {
        resolvedOptions = options;
      }
      return this.makeURL(`/emojis/${emojiId}`, resolvedOptions);
    }
    guildMemberAvatar(guildId, userId, avatarHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
    }
    guildMemberBanner(guildId, userId, bannerHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banners/${bannerHash}`, bannerHash, options);
    }
    icon(id, iconHash, options) {
      return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
    }
    roleIcon(roleId, roleIconHash, options) {
      return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
    }
    splash(guildId, splashHash, options) {
      return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
    }
    sticker(stickerId, extension = "png") {
      return this.makeURL(`/stickers/${stickerId}`, {
        allowedExtensions: ALLOWED_STICKER_EXTENSIONS,
        base: extension === "gif" ? this.mediaProxy : this.cdn,
        extension
      });
    }
    stickerPackBanner(bannerId, options) {
      return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
    }
    teamIcon(teamId, iconHash, options) {
      return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
    }
    guildScheduledEventCover(scheduledEventId, coverHash, options) {
      return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
    }
    soundboardSound(soundId) {
      return `${this.cdn}${import_v102.CDNRoutes.soundboardSound(soundId)}`;
    }
    guildTagBadge(guildId, badgeHash, options) {
      return this.makeURL(`/guild-tag-badges/${guildId}/${badgeHash}`, options);
    }
    dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
      return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
    }
    makeURL(route, {
      allowedExtensions = ALLOWED_EXTENSIONS,
      base = this.cdn,
      extension = "webp",
      size,
      animated
    } = {}) {
      extension = String(extension).toLowerCase();
      if (!allowedExtensions.includes(extension)) {
        throw new RangeError(`Invalid extension provided: ${extension}
Must be one of: ${allowedExtensions.join(", ")}`);
      }
      if (size && !ALLOWED_SIZES.includes(size)) {
        throw new RangeError(`Invalid size provided: ${size}
Must be one of: ${ALLOWED_SIZES.join(", ")}`);
      }
      const url = new URL(`${base}${route}.${extension}`);
      if (animated !== undefined) {
        url.searchParams.set("animated", String(animated));
      }
      if (size) {
        url.searchParams.set("size", String(size));
      }
      return url.toString();
    }
  };
  function isErrorGroupWrapper(error) {
    return Reflect.has(error, "_errors");
  }
  __name(isErrorGroupWrapper, "isErrorGroupWrapper");
  function isErrorResponse(error) {
    return typeof Reflect.get(error, "message") === "string";
  }
  __name(isErrorResponse, "isErrorResponse");
  var DiscordAPIError = class _DiscordAPIError extends Error {
    constructor(rawError, code, status, method, url, bodyData) {
      super(_DiscordAPIError.getMessage(rawError));
      this.rawError = rawError;
      this.code = code;
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "DiscordAPIError");
    }
    requestBody;
    get name() {
      return `${_DiscordAPIError.name}[${this.code}]`;
    }
    static getMessage(error) {
      let flattened = "";
      if ("code" in error) {
        if (error.errors) {
          flattened = [...this.flattenDiscordError(error.errors)].join(`
`);
        }
        return error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened || "Unknown Error";
      }
      return error.error_description ?? "No Description";
    }
    static *flattenDiscordError(obj, key = "") {
      if (isErrorResponse(obj)) {
        return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
      }
      for (const [otherKey, val] of Object.entries(obj)) {
        const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
        if (typeof val === "string") {
          yield val;
        } else if (isErrorGroupWrapper(val)) {
          for (const error of val._errors) {
            yield* this.flattenDiscordError(error, nextKey);
          }
        } else {
          yield* this.flattenDiscordError(val, nextKey);
        }
      }
    }
  };
  var HTTPError = class _HTTPError extends Error {
    constructor(status, statusText, method, url, bodyData) {
      super(statusText);
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "HTTPError");
    }
    requestBody;
    name = _HTTPError.name;
  };
  var import_collection = require_dist2();
  var import_snowflake = require_cjs();
  var import_async_event_emitter = require_dist3();
  var import_magic_bytes = require_dist4();
  var invalidCount = 0;
  var invalidCountResetTime = null;
  function incrementInvalidCount(manager) {
    if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
      invalidCountResetTime = Date.now() + 1000 * 60 * 10;
      invalidCount = 0;
    }
    invalidCount++;
    const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
    if (emitInvalid) {
      manager.emit("invalidRequestWarning", {
        count: invalidCount,
        remainingTime: invalidCountResetTime - Date.now()
      });
    }
  }
  __name(incrementInvalidCount, "incrementInvalidCount");
  async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
    const controller = new AbortController;
    const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
    if (requestData.signal) {
      if (requestData.signal.aborted)
        controller.abort();
      else
        requestData.signal.addEventListener("abort", () => controller.abort());
    }
    let res;
    try {
      res = await manager.options.makeRequest(url, { ...options, signal: controller.signal });
    } catch (error) {
      if (!(error instanceof Error))
        throw error;
      if (shouldRetry(error) && retries !== manager.options.retries) {
        return null;
      }
      throw error;
    } finally {
      clearTimeout(timeout);
    }
    if (manager.listenerCount("response")) {
      manager.emit("response", {
        method: options.method ?? "get",
        path: routeId.original,
        route: routeId.bucketRoute,
        options,
        data: requestData,
        retries
      }, res instanceof Response ? res.clone() : { ...res });
    }
    return res;
  }
  __name(makeNetworkRequest, "makeNetworkRequest");
  async function handleErrors(manager, res, method, url, requestData, retries) {
    const status = res.status;
    if (status >= 500 && status < 600) {
      if (retries !== manager.options.retries) {
        return null;
      }
      throw new HTTPError(status, res.statusText, method, url, requestData);
    } else {
      if (status >= 400 && status < 500) {
        if (status === 401 && requestData.auth) {
          manager.setToken(null);
        }
        const data = await parseResponse(res);
        throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
      }
      return res;
    }
  }
  __name(handleErrors, "handleErrors");
  var BurstHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "BurstHandler");
    }
    id;
    inactive = false;
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async queueRequest(routeId, url, options, requestData) {
      return this.runRequest(routeId, url, options, requestData);
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const retry = res.headers.get("Retry-After");
      const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
      if (retry)
        retryAfter = Number(retry) * 1000 + offset;
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (status >= 200 && status < 300) {
        return res;
      } else if (status === 429) {
        const isGlobal = res.headers.has("X-RateLimit-Global");
        const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
        await onRateLimit(this.manager, {
          global: isGlobal,
          method,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: Number.POSITIVE_INFINITY,
          timeToReset: retryAfter,
          retryAfter,
          sublimitTimeout: 0,
          scope
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${Number.POSITIVE_INFINITY}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : None`,
          `  Scope          : ${scope}`
        ].join(`
`));
        await sleep(retryAfter);
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var import_async_queue = require_cjs2();
  var SequentialHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "SequentialHandler");
    }
    id;
    reset = -1;
    remaining = 1;
    limit = Number.POSITIVE_INFINITY;
    #asyncQueue = new import_async_queue.AsyncQueue;
    #sublimitedQueue = null;
    #sublimitPromise = null;
    #shiftSublimit = false;
    get inactive() {
      return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;
    }
    get globalLimited() {
      return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
    }
    get localLimited() {
      return this.remaining <= 0 && Date.now() < this.reset;
    }
    get limited() {
      return this.globalLimited || this.localLimited;
    }
    getTimeToReset(routeId) {
      const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
      return this.reset + offset - Date.now();
    }
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async globalDelayFor(time) {
      await sleep(time);
      this.manager.globalDelay = null;
    }
    async queueRequest(routeId, url, options, requestData) {
      let queue = this.#asyncQueue;
      let queueType = 0;
      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
        queue = this.#sublimitedQueue;
        queueType = 1;
      }
      await queue.wait({ signal: requestData.signal });
      if (queueType === 0) {
        if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
          queue = this.#sublimitedQueue;
          const wait = queue.wait();
          this.#asyncQueue.shift();
          await wait;
        } else if (this.#sublimitPromise) {
          await this.#sublimitPromise.promise;
        }
      }
      try {
        return await this.runRequest(routeId, url, options, requestData);
      } finally {
        queue.shift();
        if (this.#shiftSublimit) {
          this.#shiftSublimit = false;
          this.#sublimitedQueue?.shift();
        }
        if (this.#sublimitedQueue?.remaining === 0) {
          this.#sublimitPromise?.resolve();
          this.#sublimitedQueue = null;
        }
      }
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      while (this.limited) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        let delay;
        if (isGlobal) {
          const offset2 = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + offset2 - Date.now();
          if (!this.manager.globalDelay) {
            this.manager.globalDelay = this.globalDelayFor(timeout);
          }
          delay = this.manager.globalDelay;
        } else {
          limit2 = this.limit;
          timeout = this.getTimeToReset(routeId);
          delay = sleep(timeout);
        }
        const rateLimitData = {
          global: isGlobal,
          method: options.method ?? "get",
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: limit2,
          timeToReset: timeout,
          retryAfter: timeout,
          sublimitTimeout: 0,
          scope: "user"
        };
        this.manager.emit("rateLimited", rateLimitData);
        await onRateLimit(this.manager, rateLimitData);
        if (isGlobal) {
          this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
        } else {
          this.debug(`Waiting ${timeout}ms for rate limit to pass`);
        }
        await delay;
      }
      if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
        this.manager.globalReset = Date.now() + 1000;
        this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
      }
      this.manager.globalRemaining--;
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const limit = res.headers.get("X-RateLimit-Limit");
      const remaining = res.headers.get("X-RateLimit-Remaining");
      const reset = res.headers.get("X-RateLimit-Reset-After");
      const hash = res.headers.get("X-RateLimit-Bucket");
      const retry = res.headers.get("Retry-After");
      const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
      const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
      this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
      this.remaining = remaining ? Number(remaining) : 1;
      this.reset = reset ? Number(reset) * 1000 + Date.now() + offset : Date.now();
      if (retry)
        retryAfter = Number(retry) * 1000 + offset;
      if (hash && hash !== this.hash) {
        this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join(`
`));
        this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
      } else if (hash) {
        const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
        if (hashData) {
          hashData.lastAccess = Date.now();
        }
      }
      let sublimitTimeout = null;
      if (retryAfter > 0) {
        if (res.headers.has("X-RateLimit-Global")) {
          this.manager.globalRemaining = 0;
          this.manager.globalReset = Date.now() + retryAfter;
        } else if (!this.localLimited) {
          sublimitTimeout = retryAfter;
        }
      }
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (res.ok) {
        return res;
      } else if (status === 429) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        if (isGlobal) {
          const offset2 = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + offset2 - Date.now();
        } else {
          limit2 = this.limit;
          timeout = this.getTimeToReset(routeId);
        }
        await onRateLimit(this.manager, {
          global: isGlobal,
          method,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: limit2,
          timeToReset: timeout,
          retryAfter,
          sublimitTimeout: sublimitTimeout ?? 0,
          scope
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal.toString()}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${limit2}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`,
          `  Scope          : ${scope}`
        ].join(`
`));
        if (sublimitTimeout) {
          const firstSublimit = !this.#sublimitedQueue;
          if (firstSublimit) {
            this.#sublimitedQueue = new import_async_queue.AsyncQueue;
            this.#sublimitedQueue.wait();
            this.#asyncQueue.shift();
          }
          this.#sublimitPromise?.resolve();
          this.#sublimitPromise = null;
          await sleep(sublimitTimeout);
          let resolve;
          const promise = new Promise((res2) => resolve = res2);
          this.#sublimitPromise = { promise, resolve };
          if (firstSublimit) {
            await this.#asyncQueue.wait();
            this.#shiftSublimit = true;
          }
        }
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var REST = class _REST extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "REST");
    }
    agent = null;
    cdn;
    globalRemaining;
    globalDelay = null;
    globalReset = -1;
    hashes = new import_collection.Collection;
    handlers = new import_collection.Collection;
    #token = null;
    hashTimer;
    handlerTimer;
    options;
    constructor(options = {}) {
      super();
      this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn, options.mediaProxy ?? DefaultRestOptions.mediaProxy);
      this.options = { ...DefaultRestOptions, ...options };
      this.globalRemaining = Math.max(1, this.options.globalRequestsPerSecond);
      this.agent = options.agent ?? null;
      this.setupSweepers();
    }
    setupSweepers() {
      const validateMaxInterval = /* @__PURE__ */ __name((interval) => {
        if (interval > 14400000) {
          throw new Error("Cannot set an interval greater than 4 hours");
        }
      }, "validateMaxInterval");
      if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.hashSweepInterval);
        this.hashTimer = setInterval(() => {
          const sweptHashes = new import_collection.Collection;
          const currentDate = Date.now();
          this.hashes.sweep((val, key) => {
            if (val.lastAccess === -1)
              return false;
            const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
            if (shouldSweep) {
              sweptHashes.set(key, val);
              this.emit("restDebug", `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
            }
            return shouldSweep;
          });
          this.emit("hashSweep", sweptHashes);
        }, this.options.hashSweepInterval);
        this.hashTimer.unref?.();
      }
      if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.handlerSweepInterval);
        this.handlerTimer = setInterval(() => {
          const sweptHandlers = new import_collection.Collection;
          this.handlers.sweep((val, key) => {
            const { inactive } = val;
            if (inactive) {
              sweptHandlers.set(key, val);
              this.emit("restDebug", `Handler ${val.id} for ${key} swept due to being inactive`);
            }
            return inactive;
          });
          this.emit("handlerSweep", sweptHandlers);
        }, this.options.handlerSweepInterval);
        this.handlerTimer.unref?.();
      }
    }
    async get(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "GET" });
    }
    async delete(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "DELETE" });
    }
    async post(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "POST" });
    }
    async put(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PUT" });
    }
    async patch(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PATCH" });
    }
    async request(options) {
      const response = await this.queueRequest(options);
      return parseResponse(response);
    }
    setAgent(agent) {
      this.agent = agent;
      return this;
    }
    setToken(token) {
      this.#token = token;
      return this;
    }
    async queueRequest(request2) {
      const routeId = _REST.generateRouteData(request2.fullRoute, request2.method);
      const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
        value: `Global(${request2.method}:${routeId.bucketRoute})`,
        lastAccess: -1
      };
      const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
      const { url, fetchOptions } = await this.resolveRequest(request2);
      return handler.queueRequest(routeId, url, fetchOptions, {
        body: request2.body,
        files: request2.files,
        auth: request2.auth !== false,
        signal: request2.signal
      });
    }
    createHandler(hash, majorParameter) {
      const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
      this.handlers.set(queue.id, queue);
      return queue;
    }
    async resolveRequest(request2) {
      const { options } = this;
      let query = "";
      if (request2.query) {
        const resolvedQuery = request2.query.toString();
        if (resolvedQuery !== "") {
          query = `?${resolvedQuery}`;
        }
      }
      const headers = {
        ...this.options.headers,
        "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
      };
      if (request2.auth !== false) {
        if (!this.#token) {
          throw new Error("Expected token to be set for this request, but none was present");
        }
        headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;
      }
      if (request2.reason?.length) {
        headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
      }
      const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
      let finalBody;
      let additionalHeaders = {};
      if (request2.files?.length) {
        const formData = new FormData;
        for (const [index, file] of request2.files.entries()) {
          const fileKey = file.key ?? `files[${index}]`;
          if (isBufferLike(file.data)) {
            let contentType = file.contentType;
            if (!contentType) {
              const [parsedType] = (0, import_magic_bytes.filetypeinfo)(file.data);
              if (parsedType) {
                contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
              }
            }
            formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
          } else {
            formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
          }
        }
        if (request2.body != null) {
          if (request2.appendToFormData) {
            for (const [key, value] of Object.entries(request2.body)) {
              formData.append(key, value);
            }
          } else {
            formData.append("payload_json", JSON.stringify(request2.body));
          }
        }
        finalBody = formData;
      } else if (request2.body != null) {
        if (request2.passThroughBody) {
          finalBody = request2.body;
        } else {
          finalBody = JSON.stringify(request2.body);
          additionalHeaders = { "Content-Type": "application/json" };
        }
      }
      const method = request2.method.toUpperCase();
      const fetchOptions = {
        body: ["GET", "HEAD"].includes(method) ? null : finalBody,
        headers: { ...request2.headers, ...additionalHeaders, ...headers },
        method,
        dispatcher: request2.dispatcher ?? this.agent ?? undefined
      };
      return { url, fetchOptions };
    }
    clearHashSweeper() {
      clearInterval(this.hashTimer);
    }
    clearHandlerSweeper() {
      clearInterval(this.handlerTimer);
    }
    static generateRouteData(endpoint, method) {
      if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
        return {
          majorParameter: BurstHandlerMajorIdKey,
          bucketRoute: "/interactions/:id/:token/callback",
          original: endpoint
        };
      }
      const majorIdMatch = /(?:^\/webhooks\/(\d{17,19}\/[^/?]+))|(?:^\/(?:channels|guilds|webhooks)\/(\d{17,19}))/.exec(endpoint);
      const majorId = majorIdMatch?.[2] ?? majorIdMatch?.[1] ?? "global";
      const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction").replace(/\/webhooks\/:id\/[^/?]+/, "/webhooks/:id/:token");
      let exceptions = "";
      if (method === "DELETE" && baseRoute === "/channels/:id/messages/:id") {
        const id = /\d{17,19}$/.exec(endpoint)[0];
        const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
        if (Date.now() - timestamp > 1000 * 60 * 60 * 24 * 14) {
          exceptions += "/Delete Old Message";
        }
      }
      return {
        majorParameter: majorId,
        bucketRoute: baseRoute + exceptions,
        original: endpoint
      };
    }
  };
  var version = "2.6.0";
  globalThis.FormData ??= import_undici2.FormData;
  globalThis.Blob ??= import_node_buffer.Blob;
  setDefaultStrategy((0, import_util2.shouldUseGlobalFetchAndWebSocket)() ? fetch : makeRequest);
});

// ../../node_modules/discord.js/src/errors/ErrorCodes.js
var require_ErrorCodes = __commonJS((exports, module) => {
  var keys = [
    "ClientInvalidOption",
    "ClientInvalidProvidedShards",
    "ClientMissingIntents",
    "ClientNotReady",
    "TokenInvalid",
    "TokenMissing",
    "ApplicationCommandPermissionsTokenMissing",
    "WSCloseRequested",
    "WSConnectionExists",
    "WSNotOpen",
    "ManagerDestroyed",
    "BitFieldInvalid",
    "ShardingInvalid",
    "ShardingRequired",
    "InvalidIntents",
    "DisallowedIntents",
    "ShardingNoShards",
    "ShardingInProcess",
    "ShardingInvalidEvalBroadcast",
    "ShardingShardNotFound",
    "ShardingAlreadySpawned",
    "ShardingProcessExists",
    "ShardingWorkerExists",
    "ShardingReadyTimeout",
    "ShardingReadyDisconnected",
    "ShardingReadyDied",
    "ShardingNoChildExists",
    "ShardingShardMiscalculation",
    "ColorRange",
    "ColorConvert",
    "InviteOptionsMissingChannel",
    "ButtonLabel",
    "ButtonURL",
    "ButtonCustomId",
    "SelectMenuCustomId",
    "SelectMenuPlaceholder",
    "SelectOptionLabel",
    "SelectOptionValue",
    "SelectOptionDescription",
    "InteractionCollectorError",
    "FileNotFound",
    "UserBannerNotFetched",
    "UserNoDMChannel",
    "VoiceNotStageChannel",
    "VoiceStateNotOwn",
    "VoiceStateInvalidType",
    "ReqResourceType",
    "ImageFormat",
    "ImageSize",
    "MessageBulkDeleteType",
    "MessageContentType",
    "MessageNonceRequired",
    "MessageNonceType",
    "SplitMaxLen",
    "BanResolveId",
    "FetchBanResolveId",
    "PruneDaysType",
    "GuildChannelResolve",
    "GuildVoiceChannelResolve",
    "GuildChannelOrphan",
    "GuildChannelUnowned",
    "GuildOwned",
    "GuildMembersTimeout",
    "GuildSoundboardSoundsTimeout",
    "GuildUncachedMe",
    "ChannelNotCached",
    "StageChannelResolve",
    "GuildScheduledEventResolve",
    "FetchOwnerId",
    "InvalidType",
    "InvalidElement",
    "MessageThreadParent",
    "MessageExistingThread",
    "ThreadInvitableType",
    "WebhookMessage",
    "WebhookTokenUnavailable",
    "WebhookURLInvalid",
    "WebhookApplication",
    "MessageReferenceMissing",
    "EmojiType",
    "EmojiManaged",
    "MissingManageGuildExpressionsPermission",
    "MissingManageEmojisAndStickersPermission",
    "NotGuildSoundboardSound",
    "NotGuildSticker",
    "ReactionResolveUser",
    "VanityURL",
    "InviteResolveCode",
    "InviteNotFound",
    "DeleteGroupDMChannel",
    "FetchGroupDMChannel",
    "MemberFetchNonceLength",
    "GlobalCommandPermissions",
    "GuildUncachedEntityResolve",
    "InteractionAlreadyReplied",
    "InteractionNotReplied",
    "InteractionEphemeralReplied",
    "CommandInteractionOptionNotFound",
    "CommandInteractionOptionType",
    "CommandInteractionOptionEmpty",
    "CommandInteractionOptionNoSubcommand",
    "CommandInteractionOptionNoSubcommandGroup",
    "CommandInteractionOptionInvalidChannelType",
    "AutocompleteInteractionOptionNoFocusedOption",
    "ModalSubmitInteractionFieldNotFound",
    "ModalSubmitInteractionFieldType",
    "InvalidMissingScopes",
    "InvalidScopesWithPermissions",
    "NotImplemented",
    "SweepFilterReturn",
    "GuildForumMessageRequired",
    "EntitlementCreateInvalidOwner",
    "BulkBanUsersOptionEmpty",
    "PollAlreadyExpired"
  ];
  module.exports = Object.fromEntries(keys.map((key) => [key, key]));
});

// ../../node_modules/discord.js/src/errors/Messages.js
var require_Messages = __commonJS((exports, module) => {
  var DjsErrorCodes = require_ErrorCodes();
  var Messages = {
    [DjsErrorCodes.ClientInvalidOption]: (prop, must) => `The ${prop} option must be ${must}`,
    [DjsErrorCodes.ClientInvalidProvidedShards]: "None of the provided shards were valid.",
    [DjsErrorCodes.ClientMissingIntents]: "Valid intents must be provided for the Client.",
    [DjsErrorCodes.ClientNotReady]: (action) => `The client needs to be logged in to ${action}.`,
    [DjsErrorCodes.TokenInvalid]: "An invalid token was provided.",
    [DjsErrorCodes.TokenMissing]: "Request to use token, but token was unavailable to the client.",
    [DjsErrorCodes.ApplicationCommandPermissionsTokenMissing]: "Editing application command permissions requires an OAuth2 bearer token, but none was provided.",
    [DjsErrorCodes.WSCloseRequested]: "WebSocket closed due to user request.",
    [DjsErrorCodes.WSConnectionExists]: "There is already an existing WebSocket connection.",
    [DjsErrorCodes.WSNotOpen]: (data = "data") => `WebSocket not open to send ${data}`,
    [DjsErrorCodes.ManagerDestroyed]: "Manager was destroyed.",
    [DjsErrorCodes.BitFieldInvalid]: (bit) => `Invalid bitfield flag or number: ${bit}.`,
    [DjsErrorCodes.ShardingInvalid]: "Invalid shard settings were provided.",
    [DjsErrorCodes.ShardingRequired]: "This session would have handled too many guilds - Sharding is required.",
    [DjsErrorCodes.InvalidIntents]: "Invalid intent provided for WebSocket intents.",
    [DjsErrorCodes.DisallowedIntents]: "Privileged intent provided is not enabled or whitelisted.",
    [DjsErrorCodes.ShardingNoShards]: "No shards have been spawned.",
    [DjsErrorCodes.ShardingInProcess]: "Shards are still being spawned.",
    [DjsErrorCodes.ShardingInvalidEvalBroadcast]: "Script to evaluate must be a function",
    [DjsErrorCodes.ShardingShardNotFound]: (id) => `Shard ${id} could not be found.`,
    [DjsErrorCodes.ShardingAlreadySpawned]: (count) => `Already spawned ${count} shards.`,
    [DjsErrorCodes.ShardingProcessExists]: (id) => `Shard ${id} already has an active process.`,
    [DjsErrorCodes.ShardingWorkerExists]: (id) => `Shard ${id} already has an active worker.`,
    [DjsErrorCodes.ShardingReadyTimeout]: (id) => `Shard ${id}'s Client took too long to become ready.`,
    [DjsErrorCodes.ShardingReadyDisconnected]: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
    [DjsErrorCodes.ShardingReadyDied]: (id) => `Shard ${id}'s process exited before its Client became ready.`,
    [DjsErrorCodes.ShardingNoChildExists]: (id) => `Shard ${id} has no active process or worker.`,
    [DjsErrorCodes.ShardingShardMiscalculation]: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
    [DjsErrorCodes.ColorRange]: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
    [DjsErrorCodes.ColorConvert]: (color) => `Unable to convert "${color}" to a number.`,
    [DjsErrorCodes.InviteOptionsMissingChannel]: "A valid guild channel must be provided when GuildScheduledEvent is EXTERNAL.",
    [DjsErrorCodes.ButtonLabel]: "MessageButton label must be a string",
    [DjsErrorCodes.ButtonURL]: "MessageButton URL must be a string",
    [DjsErrorCodes.ButtonCustomId]: "MessageButton customId must be a string",
    [DjsErrorCodes.SelectMenuCustomId]: "MessageSelectMenu customId must be a string",
    [DjsErrorCodes.SelectMenuPlaceholder]: "MessageSelectMenu placeholder must be a string",
    [DjsErrorCodes.SelectOptionLabel]: "MessageSelectOption label must be a string",
    [DjsErrorCodes.SelectOptionValue]: "MessageSelectOption value must be a string",
    [DjsErrorCodes.SelectOptionDescription]: "MessageSelectOption description must be a string",
    [DjsErrorCodes.InteractionCollectorError]: (reason) => `Collector received no interactions before ending with reason: ${reason}`,
    [DjsErrorCodes.FileNotFound]: (file) => `File could not be found: ${file}`,
    [DjsErrorCodes.UserBannerNotFetched]: "You must fetch this user's banner before trying to generate its URL!",
    [DjsErrorCodes.UserNoDMChannel]: "No DM Channel exists!",
    [DjsErrorCodes.VoiceNotStageChannel]: "You are only allowed to do this in stage channels.",
    [DjsErrorCodes.VoiceStateNotOwn]: "You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.",
    [DjsErrorCodes.VoiceStateInvalidType]: (name) => `${name} must be a boolean.`,
    [DjsErrorCodes.ReqResourceType]: "The resource must be a string, Buffer or a valid file stream.",
    [DjsErrorCodes.ImageFormat]: (format) => `Invalid image format: ${format}`,
    [DjsErrorCodes.ImageSize]: (size) => `Invalid image size: ${size}`,
    [DjsErrorCodes.MessageBulkDeleteType]: "The messages must be an Array, Collection, or number.",
    [DjsErrorCodes.MessageContentType]: "Message content must be a string.",
    [DjsErrorCodes.MessageNonceRequired]: "Message nonce is required when enforceNonce is true.",
    [DjsErrorCodes.MessageNonceType]: "Message nonce must be an integer or a string.",
    [DjsErrorCodes.SplitMaxLen]: "Chunk exceeds the max length and contains no split characters.",
    [DjsErrorCodes.BanResolveId]: (ban = false) => `Couldn't resolve the user id to ${ban ? "ban" : "unban"}.`,
    [DjsErrorCodes.FetchBanResolveId]: "Couldn't resolve the user id to fetch the ban.",
    [DjsErrorCodes.PruneDaysType]: "Days must be a number",
    [DjsErrorCodes.GuildChannelResolve]: "Could not resolve channel to a guild channel.",
    [DjsErrorCodes.GuildVoiceChannelResolve]: "Could not resolve channel to a guild voice channel.",
    [DjsErrorCodes.GuildChannelOrphan]: "Could not find a parent to this guild channel.",
    [DjsErrorCodes.GuildChannelUnowned]: "The fetched channel does not belong to this manager's guild.",
    [DjsErrorCodes.GuildOwned]: "Guild is owned by the client.",
    [DjsErrorCodes.GuildMembersTimeout]: "Members didn't arrive in time.",
    [DjsErrorCodes.GuildSoundboardSoundsTimeout]: "Soundboard sounds didn't arrive in time.",
    [DjsErrorCodes.GuildUncachedMe]: "The client user as a member of this guild is uncached.",
    [DjsErrorCodes.ChannelNotCached]: "Could not find the channel where this message came from in the cache!",
    [DjsErrorCodes.StageChannelResolve]: "Could not resolve channel to a stage channel.",
    [DjsErrorCodes.GuildScheduledEventResolve]: "Could not resolve the guild scheduled event.",
    [DjsErrorCodes.FetchOwnerId]: (type) => `Couldn't resolve the ${type} ownerId to fetch the ${type} ${type === "group DM" ? "owner" : "member"}.`,
    [DjsErrorCodes.InvalidType]: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
    [DjsErrorCodes.InvalidElement]: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,
    [DjsErrorCodes.MessageThreadParent]: "The message was not sent in a guild text or news channel",
    [DjsErrorCodes.MessageExistingThread]: "The message already has a thread",
    [DjsErrorCodes.ThreadInvitableType]: (type) => `Invitable cannot be edited on ${type}`,
    [DjsErrorCodes.WebhookMessage]: "The message was not sent by a webhook.",
    [DjsErrorCodes.WebhookTokenUnavailable]: "This action requires a webhook token, but none is available.",
    [DjsErrorCodes.WebhookURLInvalid]: "The provided webhook URL is not valid.",
    [DjsErrorCodes.WebhookApplication]: "This message webhook belongs to an application and cannot be fetched.",
    [DjsErrorCodes.MessageReferenceMissing]: "The message does not reference another message",
    [DjsErrorCodes.EmojiType]: "Emoji must be a string or GuildEmoji/ReactionEmoji",
    [DjsErrorCodes.EmojiManaged]: "Emoji is managed and has no Author.",
    [DjsErrorCodes.MissingManageGuildExpressionsPermission]: (guild) => `Client must have Manage Guild Expressions permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.MissingManageEmojisAndStickersPermission]: (guild) => `Client must have Manage Emojis and Stickers permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.NotGuildSoundboardSound]: (action) => `Soundboard sound is a default (non-guild) soundboard sound and can't be ${action}.`,
    [DjsErrorCodes.NotGuildSticker]: "Sticker is a standard (non-guild) sticker and has no author.",
    [DjsErrorCodes.ReactionResolveUser]: "Couldn't resolve the user id to remove from the reaction.",
    [DjsErrorCodes.VanityURL]: "This guild does not have the vanity URL feature enabled.",
    [DjsErrorCodes.InviteResolveCode]: "Could not resolve the code to fetch the invite.",
    [DjsErrorCodes.InviteNotFound]: "Could not find the requested invite.",
    [DjsErrorCodes.DeleteGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot delete them",
    [DjsErrorCodes.FetchGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot fetch them",
    [DjsErrorCodes.MemberFetchNonceLength]: "Nonce length must not exceed 32 characters.",
    [DjsErrorCodes.GlobalCommandPermissions]: "Permissions for global commands may only be fetched or modified by providing a GuildResolvable " + "or from a guild's application command manager.",
    [DjsErrorCodes.GuildUncachedEntityResolve]: (type) => `Cannot resolve ${type} from an arbitrary guild, provide an id instead`,
    [DjsErrorCodes.InteractionAlreadyReplied]: "The reply to this interaction has already been sent or deferred.",
    [DjsErrorCodes.InteractionNotReplied]: "The reply to this interaction has not been sent or deferred.",
    [DjsErrorCodes.InteractionEphemeralReplied]: "Ephemeral responses cannot be deleted.",
    [DjsErrorCodes.CommandInteractionOptionNotFound]: (name) => `Required option "${name}" not found.`,
    [DjsErrorCodes.CommandInteractionOptionType]: (name, type, expected) => `Option "${name}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.CommandInteractionOptionEmpty]: (name, type) => `Required option "${name}" is of type: ${type}; expected a non-empty value.`,
    [DjsErrorCodes.CommandInteractionOptionNoSubcommand]: "No subcommand specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionNoSubcommandGroup]: "No subcommand group specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionInvalidChannelType]: (name, type, expected) => `The type of channel of the option "${name}" is: ${type}; expected ${expected}.`,
    [DjsErrorCodes.AutocompleteInteractionOptionNoFocusedOption]: "No focused option for autocomplete interaction.",
    [DjsErrorCodes.ModalSubmitInteractionFieldNotFound]: (customId) => `Required field with custom id "${customId}" not found.`,
    [DjsErrorCodes.ModalSubmitInteractionFieldType]: (customId, type, expected) => `Field with custom id "${customId}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.InvalidMissingScopes]: "At least one valid scope must be provided for the invite",
    [DjsErrorCodes.InvalidScopesWithPermissions]: "Permissions cannot be set without the bot scope.",
    [DjsErrorCodes.NotImplemented]: (what, name) => `Method ${what} not implemented on ${name}.`,
    [DjsErrorCodes.SweepFilterReturn]: "The return value of the sweepFilter function was not false or a Function",
    [DjsErrorCodes.GuildForumMessageRequired]: "You must provide a message to create a guild forum thread",
    [DjsErrorCodes.EntitlementCreateInvalidOwner]: "You must provide either a guild or a user to create an entitlement, but not both",
    [DjsErrorCodes.BulkBanUsersOptionEmpty]: 'Option "users" array or collection is empty',
    [DjsErrorCodes.PollAlreadyExpired]: "This poll has already expired."
  };
  module.exports = Messages;
});

// ../../node_modules/discord.js/src/errors/DJSError.js
var require_DJSError = __commonJS((exports, module) => {
  var ErrorCodes = require_ErrorCodes();
  var Messages = require_Messages();
  function makeDiscordjsError(Base) {
    return class DiscordjsError extends Base {
      constructor(code, ...args) {
        super(message(code, args));
        this.code = code;
        Error.captureStackTrace?.(this, DiscordjsError);
      }
      get name() {
        return `${super.name} [${this.code}]`;
      }
    };
  }
  function message(code, args) {
    if (!(code in ErrorCodes))
      throw new Error("Error code must be a valid DiscordjsErrorCodes");
    const msg = Messages[code];
    if (!msg)
      throw new Error(`No message associated with error code: ${code}.`);
    if (typeof msg === "function")
      return msg(...args);
    if (!args?.length)
      return msg;
    args.unshift(msg);
    return String(...args);
  }
  module.exports = {
    DiscordjsError: makeDiscordjsError(Error),
    DiscordjsTypeError: makeDiscordjsError(TypeError),
    DiscordjsRangeError: makeDiscordjsError(RangeError)
  };
});

// ../../node_modules/discord.js/src/errors/index.js
var require_errors = __commonJS((exports, module) => {
  module.exports = require_DJSError();
  module.exports.ErrorCodes = require_ErrorCodes();
  module.exports.Messages = require_Messages();
});

// ../../node_modules/lodash.snakecase/index.js
var require_lodash = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsDingbatRange = "\\u2700-\\u27bf";
  var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
  var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
  var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
  var rsPunctuationRange = "\\u2000-\\u206f";
  var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
  var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['\u2019]";
  var rsBreak = "[" + rsBreakRange + "]";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var rsDigits = "\\d+";
  var rsDingbat = "[" + rsDingbatRange + "]";
  var rsLower = "[" + rsLowerRange + "]";
  var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsUpper = "[" + rsUpperRange + "]";
  var rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
  var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
  var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
  var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    "\xC0": "A",
    "\xC1": "A",
    "\xC2": "A",
    "\xC3": "A",
    "\xC4": "A",
    "\xC5": "A",
    "\xE0": "a",
    "\xE1": "a",
    "\xE2": "a",
    "\xE3": "a",
    "\xE4": "a",
    "\xE5": "a",
    "\xC7": "C",
    "\xE7": "c",
    "\xD0": "D",
    "\xF0": "d",
    "\xC8": "E",
    "\xC9": "E",
    "\xCA": "E",
    "\xCB": "E",
    "\xE8": "e",
    "\xE9": "e",
    "\xEA": "e",
    "\xEB": "e",
    "\xCC": "I",
    "\xCD": "I",
    "\xCE": "I",
    "\xCF": "I",
    "\xEC": "i",
    "\xED": "i",
    "\xEE": "i",
    "\xEF": "i",
    "\xD1": "N",
    "\xF1": "n",
    "\xD2": "O",
    "\xD3": "O",
    "\xD4": "O",
    "\xD5": "O",
    "\xD6": "O",
    "\xD8": "O",
    "\xF2": "o",
    "\xF3": "o",
    "\xF4": "o",
    "\xF5": "o",
    "\xF6": "o",
    "\xF8": "o",
    "\xD9": "U",
    "\xDA": "U",
    "\xDB": "U",
    "\xDC": "U",
    "\xF9": "u",
    "\xFA": "u",
    "\xFB": "u",
    "\xFC": "u",
    "\xDD": "Y",
    "\xFD": "y",
    "\xFF": "y",
    "\xC6": "Ae",
    "\xE6": "ae",
    "\xDE": "Th",
    "\xFE": "th",
    "\xDF": "ss",
    "\u0100": "A",
    "\u0102": "A",
    "\u0104": "A",
    "\u0101": "a",
    "\u0103": "a",
    "\u0105": "a",
    "\u0106": "C",
    "\u0108": "C",
    "\u010A": "C",
    "\u010C": "C",
    "\u0107": "c",
    "\u0109": "c",
    "\u010B": "c",
    "\u010D": "c",
    "\u010E": "D",
    "\u0110": "D",
    "\u010F": "d",
    "\u0111": "d",
    "\u0112": "E",
    "\u0114": "E",
    "\u0116": "E",
    "\u0118": "E",
    "\u011A": "E",
    "\u0113": "e",
    "\u0115": "e",
    "\u0117": "e",
    "\u0119": "e",
    "\u011B": "e",
    "\u011C": "G",
    "\u011E": "G",
    "\u0120": "G",
    "\u0122": "G",
    "\u011D": "g",
    "\u011F": "g",
    "\u0121": "g",
    "\u0123": "g",
    "\u0124": "H",
    "\u0126": "H",
    "\u0125": "h",
    "\u0127": "h",
    "\u0128": "I",
    "\u012A": "I",
    "\u012C": "I",
    "\u012E": "I",
    "\u0130": "I",
    "\u0129": "i",
    "\u012B": "i",
    "\u012D": "i",
    "\u012F": "i",
    "\u0131": "i",
    "\u0134": "J",
    "\u0135": "j",
    "\u0136": "K",
    "\u0137": "k",
    "\u0138": "k",
    "\u0139": "L",
    "\u013B": "L",
    "\u013D": "L",
    "\u013F": "L",
    "\u0141": "L",
    "\u013A": "l",
    "\u013C": "l",
    "\u013E": "l",
    "\u0140": "l",
    "\u0142": "l",
    "\u0143": "N",
    "\u0145": "N",
    "\u0147": "N",
    "\u014A": "N",
    "\u0144": "n",
    "\u0146": "n",
    "\u0148": "n",
    "\u014B": "n",
    "\u014C": "O",
    "\u014E": "O",
    "\u0150": "O",
    "\u014D": "o",
    "\u014F": "o",
    "\u0151": "o",
    "\u0154": "R",
    "\u0156": "R",
    "\u0158": "R",
    "\u0155": "r",
    "\u0157": "r",
    "\u0159": "r",
    "\u015A": "S",
    "\u015C": "S",
    "\u015E": "S",
    "\u0160": "S",
    "\u015B": "s",
    "\u015D": "s",
    "\u015F": "s",
    "\u0161": "s",
    "\u0162": "T",
    "\u0164": "T",
    "\u0166": "T",
    "\u0163": "t",
    "\u0165": "t",
    "\u0167": "t",
    "\u0168": "U",
    "\u016A": "U",
    "\u016C": "U",
    "\u016E": "U",
    "\u0170": "U",
    "\u0172": "U",
    "\u0169": "u",
    "\u016B": "u",
    "\u016D": "u",
    "\u016F": "u",
    "\u0171": "u",
    "\u0173": "u",
    "\u0174": "W",
    "\u0175": "w",
    "\u0176": "Y",
    "\u0177": "y",
    "\u0178": "Y",
    "\u0179": "Z",
    "\u017B": "Z",
    "\u017D": "Z",
    "\u017A": "z",
    "\u017C": "z",
    "\u017E": "z",
    "\u0132": "IJ",
    "\u0133": "ij",
    "\u0152": "Oe",
    "\u0153": "oe",
    "\u0149": "'n",
    "\u017F": "ss"
  };
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  var snakeCase = createCompounder(function(result, word, index) {
    return result + (index ? "_" : "") + word.toLowerCase();
  });
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;
    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  module.exports = snakeCase;
});

// ../../node_modules/@discordjs/collection/dist/index.js
var require_dist6 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersect(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (this.has(key) && Object.is(value, this.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    subtract(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key) || !Object.is(value, other.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    sorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.values()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "1.5.3";
});

// ../../node_modules/discord.js/src/util/Colors.js
var require_Colors = __commonJS((exports, module) => {
  module.exports = {
    Default: 0,
    White: 16777215,
    Aqua: 1752220,
    Green: 5763719,
    Blue: 3447003,
    Yellow: 16705372,
    Purple: 10181046,
    LuminousVividPink: 15277667,
    Fuchsia: 15418782,
    Gold: 15844367,
    Orange: 15105570,
    Red: 15548997,
    Grey: 9807270,
    Navy: 3426654,
    DarkAqua: 1146986,
    DarkGreen: 2067276,
    DarkBlue: 2123412,
    DarkPurple: 7419530,
    DarkVividPink: 11342935,
    DarkGold: 12745742,
    DarkOrange: 11027200,
    DarkRed: 10038562,
    DarkGrey: 9936031,
    DarkerGrey: 8359053,
    LightGrey: 12370112,
    DarkNavy: 2899536,
    Blurple: 5793266,
    Greyple: 10070709,
    DarkButNotBlack: 2895667,
    NotQuiteBlack: 2303786
  };
});

// ../../node_modules/discord.js/src/util/BitField.js
var require_BitField = __commonJS((exports, module) => {
  var { DiscordjsRangeError, ErrorCodes } = require_errors();

  class BitField {
    static Flags = {};
    static DefaultBit = 0;
    constructor(bits = this.constructor.DefaultBit) {
      this.bitfield = this.constructor.resolve(bits);
    }
    any(bit) {
      return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;
    }
    equals(bit) {
      return this.bitfield === this.constructor.resolve(bit);
    }
    has(bit) {
      bit = this.constructor.resolve(bit);
      return (this.bitfield & bit) === bit;
    }
    missing(bits, ...hasParams) {
      return new this.constructor(bits).remove(this).toArray(...hasParams);
    }
    freeze() {
      return Object.freeze(this);
    }
    add(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield | total);
      this.bitfield |= total;
      return this;
    }
    remove(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield & ~total);
      this.bitfield &= ~total;
      return this;
    }
    serialize(...hasParams) {
      const serialized = {};
      for (const [flag, bit] of Object.entries(this.constructor.Flags)) {
        if (isNaN(flag))
          serialized[flag] = this.has(bit, ...hasParams);
      }
      return serialized;
    }
    toArray(...hasParams) {
      return [...this[Symbol.iterator](...hasParams)];
    }
    toJSON() {
      return typeof this.bitfield === "number" ? this.bitfield : this.bitfield.toString();
    }
    valueOf() {
      return this.bitfield;
    }
    *[Symbol.iterator](...hasParams) {
      for (const bitName of Object.keys(this.constructor.Flags)) {
        if (isNaN(bitName) && this.has(bitName, ...hasParams))
          yield bitName;
      }
    }
    static resolve(bit) {
      const { DefaultBit } = this;
      if (typeof DefaultBit === typeof bit && bit >= DefaultBit)
        return bit;
      if (bit instanceof BitField)
        return bit.bitfield;
      if (Array.isArray(bit)) {
        return bit.map((bit_) => this.resolve(bit_)).reduce((prev, bit_) => prev | bit_, DefaultBit);
      }
      if (typeof bit === "string") {
        if (!isNaN(bit))
          return typeof DefaultBit === "bigint" ? BigInt(bit) : Number(bit);
        if (this.Flags[bit] !== undefined)
          return this.Flags[bit];
      }
      throw new DiscordjsRangeError(ErrorCodes.BitFieldInvalid, bit);
    }
  }
  module.exports = BitField;
});

// ../../node_modules/discord.js/src/util/AttachmentFlagsBitField.js
var require_AttachmentFlagsBitField = __commonJS((exports, module) => {
  var { AttachmentFlags } = require_v106();
  var BitField = require_BitField();

  class AttachmentFlagsBitField extends BitField {
    static Flags = AttachmentFlags;
  }
  module.exports = AttachmentFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/Attachment.js
var require_Attachment = __commonJS((exports, module) => {
  var AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  var { basename, flatten } = require_Util();

  class Attachment {
    constructor(data) {
      this.attachment = data.url;
      this.name = data.filename;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("size" in data) {
        this.size = data.size;
      }
      if ("url" in data) {
        this.url = data.url;
      }
      if ("proxy_url" in data) {
        this.proxyURL = data.proxy_url;
      }
      if ("height" in data) {
        this.height = data.height;
      } else {
        this.height ??= null;
      }
      if ("width" in data) {
        this.width = data.width;
      } else {
        this.width ??= null;
      }
      if ("content_type" in data) {
        this.contentType = data.content_type;
      } else {
        this.contentType ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      this.ephemeral = data.ephemeral ?? false;
      if ("duration_secs" in data) {
        this.duration = data.duration_secs;
      } else {
        this.duration ??= null;
      }
      if ("waveform" in data) {
        this.waveform = data.waveform;
      } else {
        this.waveform ??= null;
      }
      if ("flags" in data) {
        this.flags = new AttachmentFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new AttachmentFlagsBitField().freeze();
      }
      if ("title" in data) {
        this.title = data.title;
      } else {
        this.title ??= null;
      }
    }
    get spoiler() {
      return basename(this.url ?? this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = Attachment;
});

// ../../node_modules/@discordjs/formatters/dist/index.js
var require_dist7 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Faces: () => Faces,
    GuildNavigationMentions: () => GuildNavigationMentions,
    HeadingLevel: () => HeadingLevel,
    TimestampStyles: () => TimestampStyles,
    applicationDirectory: () => applicationDirectory,
    blockQuote: () => blockQuote,
    bold: () => bold,
    channelLink: () => channelLink,
    channelMention: () => channelMention,
    chatInputApplicationCommandMention: () => chatInputApplicationCommandMention,
    codeBlock: () => codeBlock,
    escapeBold: () => escapeBold,
    escapeBulletedList: () => escapeBulletedList,
    escapeCodeBlock: () => escapeCodeBlock,
    escapeEscape: () => escapeEscape,
    escapeHeading: () => escapeHeading,
    escapeInlineCode: () => escapeInlineCode,
    escapeItalic: () => escapeItalic,
    escapeMarkdown: () => escapeMarkdown,
    escapeMaskedLink: () => escapeMaskedLink,
    escapeNumberedList: () => escapeNumberedList,
    escapeSpoiler: () => escapeSpoiler,
    escapeStrikethrough: () => escapeStrikethrough,
    escapeUnderline: () => escapeUnderline,
    formatEmoji: () => formatEmoji,
    heading: () => heading,
    hideLinkEmbed: () => hideLinkEmbed,
    hyperlink: () => hyperlink,
    inlineCode: () => inlineCode,
    italic: () => italic,
    messageLink: () => messageLink,
    orderedList: () => orderedList,
    quote: () => quote,
    roleMention: () => roleMention,
    spoiler: () => spoiler,
    strikethrough: () => strikethrough,
    subtext: () => subtext,
    time: () => time,
    underline: () => underline,
    underscore: () => underscore,
    unorderedList: () => unorderedList,
    userMention: () => userMention,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  function escapeMarkdown(text, options = {}) {
    const {
      codeBlock: codeBlock2 = true,
      inlineCode: inlineCode2 = true,
      bold: bold2 = true,
      italic: italic2 = true,
      underline: underline2 = true,
      strikethrough: strikethrough2 = true,
      spoiler: spoiler2 = true,
      codeBlockContent = true,
      inlineCodeContent = true,
      escape: escape2 = true,
      heading: heading2 = false,
      bulletedList = false,
      numberedList = false,
      maskedLink = false
    } = options;
    if (!codeBlockContent) {
      return text.split("```").map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          inlineCode: inlineCode2,
          bold: bold2,
          italic: italic2,
          underline: underline2,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          inlineCodeContent,
          escape: escape2,
          heading: heading2,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(codeBlock2 ? "\\`\\`\\`" : "```");
    }
    if (!inlineCodeContent) {
      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          codeBlock: codeBlock2,
          bold: bold2,
          italic: italic2,
          underline: underline2,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          escape: escape2,
          heading: heading2,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(inlineCode2 ? "\\`" : "`");
    }
    let res = text;
    if (escape2)
      res = escapeEscape(res);
    if (inlineCode2)
      res = escapeInlineCode(res);
    if (codeBlock2)
      res = escapeCodeBlock(res);
    if (italic2)
      res = escapeItalic(res);
    if (bold2)
      res = escapeBold(res);
    if (underline2)
      res = escapeUnderline(res);
    if (strikethrough2)
      res = escapeStrikethrough(res);
    if (spoiler2)
      res = escapeSpoiler(res);
    if (heading2)
      res = escapeHeading(res);
    if (bulletedList)
      res = escapeBulletedList(res);
    if (numberedList)
      res = escapeNumberedList(res);
    if (maskedLink)
      res = escapeMaskedLink(res);
    return res;
  }
  __name(escapeMarkdown, "escapeMarkdown");
  function escapeCodeBlock(text) {
    return text.replaceAll("```", "\\`\\`\\`");
  }
  __name(escapeCodeBlock, "escapeCodeBlock");
  function escapeInlineCode(text) {
    return text.replaceAll(/(?<=^|[^`])``?(?=[^`]|$)/g, (match) => match.length === 2 ? "\\`\\`" : "\\`");
  }
  __name(escapeInlineCode, "escapeInlineCode");
  function escapeItalic(text) {
    let idx = 0;
    const newText = text.replaceAll(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (_, match) => {
      if (match === "**")
        return ++idx % 2 ? `\\*${match}` : `${match}\\*`;
      return `\\*${match}`;
    });
    idx = 0;
    return newText.replaceAll(/(?<=^|[^_])(?<!<a?:.+|https?:\/\/\S+)_(?!:\d+>)([^_]|__|$)/g, (_, match) => {
      if (match === "__")
        return ++idx % 2 ? `\\_${match}` : `${match}\\_`;
      return `\\_${match}`;
    });
  }
  __name(escapeItalic, "escapeItalic");
  function escapeBold(text) {
    let idx = 0;
    return text.replaceAll(/\*\*(\*)?/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
      return "\\*\\*";
    });
  }
  __name(escapeBold, "escapeBold");
  function escapeUnderline(text) {
    let idx = 0;
    return text.replaceAll(/(?<!<a?:.+|https?:\/\/\S+)__(_)?(?!:\d+>)/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
      return "\\_\\_";
    });
  }
  __name(escapeUnderline, "escapeUnderline");
  function escapeStrikethrough(text) {
    return text.replaceAll("~~", "\\~\\~");
  }
  __name(escapeStrikethrough, "escapeStrikethrough");
  function escapeSpoiler(text) {
    return text.replaceAll("||", "\\|\\|");
  }
  __name(escapeSpoiler, "escapeSpoiler");
  function escapeEscape(text) {
    return text.replaceAll("\\", "\\\\");
  }
  __name(escapeEscape, "escapeEscape");
  function escapeHeading(text) {
    return text.replaceAll(/^( {0,2})([*-] )?( *)(#{1,3} )/gm, "$1$2$3\\$4");
  }
  __name(escapeHeading, "escapeHeading");
  function escapeBulletedList(text) {
    return text.replaceAll(/^( *)([*-])( +)/gm, "$1\\$2$3");
  }
  __name(escapeBulletedList, "escapeBulletedList");
  function escapeNumberedList(text) {
    return text.replaceAll(/^( *\d+)\./gm, "$1\\.");
  }
  __name(escapeNumberedList, "escapeNumberedList");
  function escapeMaskedLink(text) {
    return text.replaceAll(/\[.+]\(.+\)/gm, "\\$&");
  }
  __name(escapeMaskedLink, "escapeMaskedLink");
  function codeBlock(language, content) {
    return content === undefined ? `\`\`\`
${language}
\`\`\`` : `\`\`\`${language}
${content}
\`\`\``;
  }
  __name(codeBlock, "codeBlock");
  function inlineCode(content) {
    return `\`${content}\``;
  }
  __name(inlineCode, "inlineCode");
  function italic(content) {
    return `_${content}_`;
  }
  __name(italic, "italic");
  function bold(content) {
    return `**${content}**`;
  }
  __name(bold, "bold");
  function underscore(content) {
    return underline(content);
  }
  __name(underscore, "underscore");
  function underline(content) {
    return `__${content}__`;
  }
  __name(underline, "underline");
  function strikethrough(content) {
    return `~~${content}~~`;
  }
  __name(strikethrough, "strikethrough");
  function quote(content) {
    return `> ${content}`;
  }
  __name(quote, "quote");
  function blockQuote(content) {
    return `>>> ${content}`;
  }
  __name(blockQuote, "blockQuote");
  function hideLinkEmbed(url) {
    return `<${url}>`;
  }
  __name(hideLinkEmbed, "hideLinkEmbed");
  function hyperlink(content, url, title) {
    return title ? `[${content}](${url} "${title}")` : `[${content}](${url})`;
  }
  __name(hyperlink, "hyperlink");
  function spoiler(content) {
    return `||${content}||`;
  }
  __name(spoiler, "spoiler");
  function userMention(userId) {
    return `<@${userId}>`;
  }
  __name(userMention, "userMention");
  function channelMention(channelId) {
    return `<#${channelId}>`;
  }
  __name(channelMention, "channelMention");
  function roleMention(roleId) {
    return `<@&${roleId}>`;
  }
  __name(roleMention, "roleMention");
  function chatInputApplicationCommandMention(commandName, subcommandGroupName, subcommandName, commandId) {
    if (commandId !== undefined) {
      return `</${commandName} ${subcommandGroupName} ${subcommandName}:${commandId}>`;
    }
    if (subcommandName !== undefined) {
      return `</${commandName} ${subcommandGroupName}:${subcommandName}>`;
    }
    return `</${commandName}:${subcommandGroupName}>`;
  }
  __name(chatInputApplicationCommandMention, "chatInputApplicationCommandMention");
  function formatEmoji(emojiIdOrOptions, animated) {
    const options = typeof emojiIdOrOptions === "string" ? {
      id: emojiIdOrOptions,
      animated: animated ?? false
    } : emojiIdOrOptions;
    const { id, animated: isAnimated, name: emojiName } = options;
    return `<${isAnimated ? "a" : ""}:${emojiName ?? "_"}:${id}>`;
  }
  __name(formatEmoji, "formatEmoji");
  function channelLink(channelId, guildId) {
    return `https://discord.com/channels/${guildId ?? "@me"}/${channelId}`;
  }
  __name(channelLink, "channelLink");
  function messageLink(channelId, messageId, guildId) {
    return `${guildId === undefined ? channelLink(channelId) : channelLink(channelId, guildId)}/${messageId}`;
  }
  __name(messageLink, "messageLink");
  var HeadingLevel = /* @__PURE__ */ ((HeadingLevel2) => {
    HeadingLevel2[HeadingLevel2["One"] = 1] = "One";
    HeadingLevel2[HeadingLevel2["Two"] = 2] = "Two";
    HeadingLevel2[HeadingLevel2["Three"] = 3] = "Three";
    return HeadingLevel2;
  })(HeadingLevel || {});
  function heading(content, level) {
    switch (level) {
      case 3:
        return `### ${content}`;
      case 2:
        return `## ${content}`;
      default:
        return `# ${content}`;
    }
  }
  __name(heading, "heading");
  function listCallback(element, startNumber, depth = 0) {
    if (Array.isArray(element)) {
      return element.map((element2) => listCallback(element2, startNumber, depth + 1)).join(`
`);
    }
    return `${"  ".repeat(depth - 1)}${startNumber ? `${startNumber}.` : "-"} ${element}`;
  }
  __name(listCallback, "listCallback");
  function orderedList(list, startNumber = 1) {
    return listCallback(list, Math.max(startNumber, 1));
  }
  __name(orderedList, "orderedList");
  function unorderedList(list) {
    return listCallback(list);
  }
  __name(unorderedList, "unorderedList");
  function subtext(content) {
    return `-# ${content}`;
  }
  __name(subtext, "subtext");
  function time(timeOrSeconds, style) {
    if (typeof timeOrSeconds !== "number") {
      timeOrSeconds = Math.floor((timeOrSeconds?.getTime() ?? Date.now()) / 1000);
    }
    return typeof style === "string" ? `<t:${timeOrSeconds}:${style}>` : `<t:${timeOrSeconds}>`;
  }
  __name(time, "time");
  function applicationDirectory(applicationId, skuId) {
    const url = `https://discord.com/application-directory/${applicationId}/store`;
    return skuId ? `${url}/${skuId}` : url;
  }
  __name(applicationDirectory, "applicationDirectory");
  var TimestampStyles = {
    ShortTime: "t",
    LongTime: "T",
    ShortDate: "d",
    LongDate: "D",
    ShortDateTime: "f",
    LongDateTime: "F",
    RelativeTime: "R"
  };
  var Faces = /* @__PURE__ */ ((Faces2) => {
    Faces2["Shrug"] = "\xAF\\_(\u30C4)_/\xAF";
    Faces2["Tableflip"] = "(\u256F\xB0\u25A1\xB0)\u256F\uFE35 \u253B\u2501\u253B";
    Faces2["Unflip"] = "\u252C\u2500\u252C\u30CE( \xBA _ \xBA\u30CE)";
    return Faces2;
  })(Faces || {});
  var GuildNavigationMentions = /* @__PURE__ */ ((GuildNavigationMentions2) => {
    GuildNavigationMentions2["Browse"] = "<id:browse>";
    GuildNavigationMentions2["Customize"] = "<id:customize>";
    GuildNavigationMentions2["Guide"] = "<id:guide>";
    return GuildNavigationMentions2;
  })(GuildNavigationMentions || {});
  var version = "0.6.1";
});

// ../../node_modules/discord.js/src/structures/Base.js
var require_Base = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class Base {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
    _patch(data) {
      return data;
    }
    _update(data) {
      const clone = this._clone();
      this._patch(data);
      return clone;
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = Base;
});

// ../../node_modules/discord.js/src/util/ChannelFlagsBitField.js
var require_ChannelFlagsBitField = __commonJS((exports, module) => {
  var { ChannelFlags } = require_v106();
  var BitField = require_BitField();

  class ChannelFlagsBitField extends BitField {
    static Flags = ChannelFlags;
  }
  module.exports = ChannelFlagsBitField;
});

// ../../node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS((exports) => {
  var { ChannelType, MessageType, ComponentType, ImageFormat, StickerFormatType } = require_v106();
  exports.MaxBulkDeletableMessageAge = 1209600000;
  exports.SweeperKeys = [
    "autoModerationRules",
    "applicationCommands",
    "bans",
    "emojis",
    "entitlements",
    "invites",
    "guildMembers",
    "messages",
    "presences",
    "reactions",
    "stageInstances",
    "stickers",
    "threadMembers",
    "threads",
    "users",
    "voiceStates"
  ];
  exports.NonSystemMessageTypes = [
    MessageType.Default,
    MessageType.Reply,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand
  ];
  exports.GuildTextBasedChannelTypes = [
    ChannelType.GuildText,
    ChannelType.GuildAnnouncement,
    ChannelType.AnnouncementThread,
    ChannelType.PublicThread,
    ChannelType.PrivateThread,
    ChannelType.GuildVoice,
    ChannelType.GuildStageVoice
  ];
  exports.TextBasedChannelTypes = [...exports.GuildTextBasedChannelTypes, ChannelType.DM, ChannelType.GroupDM];
  exports.SendableChannels = [...exports.GuildTextBasedChannelTypes, ChannelType.DM];
  exports.ThreadChannelTypes = [ChannelType.AnnouncementThread, ChannelType.PublicThread, ChannelType.PrivateThread];
  exports.VoiceBasedChannelTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  exports.SelectMenuTypes = [
    ComponentType.StringSelect,
    ComponentType.UserSelect,
    ComponentType.RoleSelect,
    ComponentType.MentionableSelect,
    ComponentType.ChannelSelect
  ];
  exports.UndeletableMessageTypes = [
    MessageType.RecipientAdd,
    MessageType.RecipientRemove,
    MessageType.Call,
    MessageType.ChannelNameChange,
    MessageType.ChannelIconChange,
    MessageType.ThreadStarterMessage
  ];
  exports.DeletableMessageTypes = [
    MessageType.AutoModerationAction,
    MessageType.ChannelFollowAdd,
    MessageType.ChannelPinnedMessage,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand,
    MessageType.Default,
    MessageType.GuildBoost,
    MessageType.GuildBoostTier1,
    MessageType.GuildBoostTier2,
    MessageType.GuildBoostTier3,
    MessageType.GuildInviteReminder,
    MessageType.InteractionPremiumUpsell,
    MessageType.Reply,
    MessageType.RoleSubscriptionPurchase,
    MessageType.StageEnd,
    MessageType.StageRaiseHand,
    MessageType.StageSpeaker,
    MessageType.StageStart,
    MessageType.StageTopic,
    MessageType.ThreadCreated,
    MessageType.UserJoin
  ];
  exports.StickerFormatExtensionMap = {
    [StickerFormatType.PNG]: ImageFormat.PNG,
    [StickerFormatType.APNG]: ImageFormat.PNG,
    [StickerFormatType.Lottie]: ImageFormat.Lottie,
    [StickerFormatType.GIF]: ImageFormat.GIF
  };
  exports.HolographicStyle = {
    Primary: 11127295,
    Secondary: 16759788,
    Tertiary: 16761760
  };
});

// ../../node_modules/discord.js/src/structures/BaseChannel.js
var require_BaseChannel = __commonJS((exports) => {
  var { channelLink, channelMention } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { ThreadChannelTypes } = require_Constants();

  class BaseChannel extends Base {
    constructor(client, data, immediatePatch = true) {
      super(client);
      this.type = data.type;
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("flags" in data) {
        this.flags = new ChannelFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new ChannelFlagsBitField().freeze();
      }
      this.id = data.id;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.isDMBased() ? channelLink(this.id) : channelLink(this.id, this.guildId);
    }
    get partial() {
      return false;
    }
    toString() {
      return channelMention(this.id);
    }
    async delete() {
      await this.client.rest.delete(Routes.channel(this.id));
      return this;
    }
    fetch(force = true) {
      return this.client.channels.fetch(this.id, { force });
    }
    isThread() {
      return ThreadChannelTypes.includes(this.type);
    }
    isTextBased() {
      return "messages" in this;
    }
    isDMBased() {
      return [ChannelType.DM, ChannelType.GroupDM].includes(this.type);
    }
    isVoiceBased() {
      return "bitrate" in this;
    }
    isThreadOnly() {
      return "availableTags" in this;
    }
    isSendable() {
      return "send" in this;
    }
    toJSON(...props) {
      return super.toJSON({ createdTimestamp: true }, ...props);
    }
  }
  exports.BaseChannel = BaseChannel;
});

// ../../node_modules/discord.js/src/managers/BaseManager.js
var require_BaseManager = __commonJS((exports, module) => {
  class BaseManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
  }
  module.exports = BaseManager;
});

// ../../node_modules/discord.js/src/managers/DataManager.js
var require_DataManager = __commonJS((exports, module) => {
  var BaseManager = require_BaseManager();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class DataManager extends BaseManager {
    constructor(client, holds) {
      super(client);
      Object.defineProperty(this, "holds", { value: holds });
    }
    get cache() {
      throw new DiscordjsError(ErrorCodes.NotImplemented, "get cache", this.constructor.name);
    }
    resolve(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance;
      if (typeof idOrInstance === "string")
        return this.cache.get(idOrInstance) ?? null;
      return null;
    }
    resolveId(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance.id;
      if (typeof idOrInstance === "string")
        return idOrInstance;
      return null;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = DataManager;
});

// ../../node_modules/discord.js/src/util/Symbols.js
var require_Symbols = __commonJS((exports) => {
  exports.MakeCacheOverrideSymbol = Symbol("djs.managers.makeCacheOverride");
});

// ../../node_modules/discord.js/src/managers/CachedManager.js
var require_CachedManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class CachedManager extends DataManager {
    constructor(client, holds, iterable) {
      super(client, holds);
      Object.defineProperty(this, "_cache", {
        value: this.client.options.makeCache(this.constructor[MakeCacheOverrideSymbol] ?? this.constructor, this.holds, this.constructor)
      });
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    get cache() {
      return this._cache;
    }
    _add(data, cache = true, { id, extras = [] } = {}) {
      const existing = this.cache.get(id ?? data.id);
      if (existing) {
        if (cache) {
          existing._patch(data);
          return existing;
        }
        const clone = existing._clone();
        clone._patch(data);
        return clone;
      }
      const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
      if (cache)
        this.cache.set(id ?? entry.id, entry);
      return entry;
    }
  }
  module.exports = CachedManager;
});

// ../../node_modules/discord.js/src/util/PermissionsBitField.js
var require_PermissionsBitField = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BitField = require_BitField();

  class PermissionsBitField extends BitField {
    static Flags = PermissionFlagsBits;
    static All = Object.values(PermissionFlagsBits).reduce((all, p) => all | p, 0n);
    static Default = BigInt(104324673);
    static StageModerator = PermissionFlagsBits.ManageChannels | PermissionFlagsBits.MuteMembers | PermissionFlagsBits.MoveMembers;
    static DefaultBit = BigInt(0);
    missing(bits, checkAdmin = true) {
      return checkAdmin && this.has(PermissionFlagsBits.Administrator) ? [] : super.missing(bits);
    }
    any(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.any(permission);
    }
    has(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.has(permission);
    }
    toArray() {
      return super.toArray(false);
    }
  }
  module.exports = PermissionsBitField;
});

// ../../node_modules/discord.js/src/util/RoleFlagsBitField.js
var require_RoleFlagsBitField = __commonJS((exports, module) => {
  var { RoleFlags } = require_v106();
  var BitField = require_BitField();

  class RoleFlagsBitField extends BitField {
    static Flags = RoleFlags;
  }
  module.exports = RoleFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS((exports) => {
  var { roleMention } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var PermissionsBitField = require_PermissionsBitField();
  var RoleFlagsBitField = require_RoleFlagsBitField();

  class Role extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.icon = null;
      this.unicodeEmoji = null;
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("color" in data) {
        this.color = data.color;
      }
      if ("colors" in data) {
        this.colors = {
          primaryColor: data.colors.primary_color,
          secondaryColor: data.colors.secondary_color,
          tertiaryColor: data.colors.tertiary_color
        };
      }
      if ("hoist" in data) {
        this.hoist = data.hoist;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("permissions" in data) {
        this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("mentionable" in data) {
        this.mentionable = data.mentionable;
      }
      if ("icon" in data)
        this.icon = data.icon;
      if ("unicode_emoji" in data)
        this.unicodeEmoji = data.unicode_emoji;
      if ("flags" in data) {
        this.flags = new RoleFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new RoleFlagsBitField().freeze();
      }
      this.tags = data.tags ? {} : null;
      if (data.tags) {
        if ("bot_id" in data.tags) {
          this.tags.botId = data.tags.bot_id;
        }
        if ("integration_id" in data.tags) {
          this.tags.integrationId = data.tags.integration_id;
        }
        if ("premium_subscriber" in data.tags) {
          this.tags.premiumSubscriberRole = true;
        }
        if ("subscription_listing_id" in data.tags) {
          this.tags.subscriptionListingId = data.tags.subscription_listing_id;
        }
        if ("available_for_purchase" in data.tags) {
          this.tags.availableForPurchase = true;
        }
        if ("guild_connections" in data.tags) {
          this.tags.guildConnections = true;
        }
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get hexColor() {
      return `#${this.colors.primaryColor.toString(16).padStart(6, "0")}`;
    }
    get members() {
      return this.id === this.guild.id ? this.guild.members.cache.clone() : this.guild.members.cache.filter((member) => member._roles.includes(this.id));
    }
    get editable() {
      if (this.managed)
        return false;
      const clientMember = this.guild.members.resolve(this.client.user);
      if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles))
        return false;
      return clientMember.roles.highest.comparePositionTo(this) > 0;
    }
    get position() {
      return this.guild.roles.cache.reduce((acc, role) => acc + (this.rawPosition === role.rawPosition ? BigInt(this.id) < BigInt(role.id) : this.rawPosition > role.rawPosition), 0);
    }
    comparePositionTo(role) {
      return this.guild.roles.comparePositions(this, role);
    }
    edit(options) {
      return this.guild.roles.edit(this, options);
    }
    permissionsIn(channel, checkAdmin = true) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.rolePermissions(this, checkAdmin);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    async setColor(color, reason) {
      return this.edit({ color, reason });
    }
    async setColors(colors, reason) {
      return this.edit({ colors, reason });
    }
    setHoist(hoist = true, reason) {
      return this.edit({ hoist, reason });
    }
    setPermissions(permissions, reason) {
      return this.edit({ permissions, reason });
    }
    setMentionable(mentionable = true, reason) {
      return this.edit({ mentionable, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setUnicodeEmoji(unicodeEmoji, reason) {
      return this.edit({ unicodeEmoji, reason });
    }
    setPosition(position, options = {}) {
      return this.guild.roles.setPosition(this, position, options);
    }
    async delete(reason) {
      await this.guild.roles.delete(this.id, reason);
      return this;
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);
    }
    equals(role) {
      return role && this.id === role.id && this.name === role.name && this.colors.primaryColor === role.colors.primaryColor && this.colors.secondaryColor === role.colors.secondaryColor && this.colors.tertiaryColor === role.colors.tertiaryColor && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;
    }
    toString() {
      if (this.id === this.guild.id)
        return "@everyone";
      return roleMention(this.id);
    }
    toJSON() {
      return {
        ...super.toJSON({ createdTimestamp: true }),
        permissions: this.permissions.toJSON()
      };
    }
  }
  exports.Role = Role;
});

// ../../node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS((exports, module) => {
  var { OverwriteType } = require_v106();
  var Base = require_Base();
  var { Role } = require_Role();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var PermissionsBitField = require_PermissionsBitField();

  class PermissionOverwrites extends Base {
    constructor(client, data, channel) {
      super(client);
      Object.defineProperty(this, "channel", { value: channel });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("deny" in data) {
        this.deny = new PermissionsBitField(BigInt(data.deny)).freeze();
      }
      if ("allow" in data) {
        this.allow = new PermissionsBitField(BigInt(data.allow)).freeze();
      }
    }
    async edit(options, reason) {
      await this.channel.permissionOverwrites.upsert(this.id, options, { type: this.type, reason }, this);
      return this;
    }
    async delete(reason) {
      await this.channel.permissionOverwrites.delete(this.id, reason);
      return this;
    }
    toJSON() {
      return {
        id: this.id,
        type: this.type,
        allow: this.allow,
        deny: this.deny
      };
    }
    static resolveOverwriteOptions(options, { allow, deny } = {}) {
      allow = new PermissionsBitField(allow);
      deny = new PermissionsBitField(deny);
      for (const [perm, value] of Object.entries(options)) {
        if (value === true) {
          allow.add(perm);
          deny.remove(perm);
        } else if (value === false) {
          allow.remove(perm);
          deny.add(perm);
        } else if (value === null) {
          allow.remove(perm);
          deny.remove(perm);
        }
      }
      return { allow, deny };
    }
    static resolve(overwrite, guild) {
      if (overwrite instanceof this)
        return overwrite.toJSON();
      if (typeof overwrite.id === "string" && overwrite.type in OverwriteType) {
        return {
          id: overwrite.id,
          type: overwrite.type,
          allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
          deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
        };
      }
      const userOrRole = guild.roles.resolve(overwrite.id) ?? guild.client.users.resolve(overwrite.id);
      if (!userOrRole) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "cached User or Role");
      }
      const type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      return {
        id: userOrRole.id,
        type,
        allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
        deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
      };
    }
  }
  module.exports = PermissionOverwrites;
});

// ../../node_modules/discord.js/src/managers/PermissionOverwriteManager.js
var require_PermissionOverwriteManager = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { Collection } = require_dist6();
  var { OverwriteType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var PermissionOverwrites = require_PermissionOverwrites();
  var { Role } = require_Role();
  var cacheWarningEmitted = false;

  class PermissionOverwriteManager extends CachedManager {
    constructor(channel, iterable) {
      super(channel.client, PermissionOverwrites);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.channel = channel;
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.channel] });
    }
    async set(overwrites, reason) {
      if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "overwrites", "Array or Collection of Permission Overwrites", true);
      }
      return this.channel.edit({ permissionOverwrites: overwrites, reason });
    }
    async upsert(userOrRole, options, overwriteOptions = {}, existing) {
      let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      let { type, reason } = overwriteOptions;
      if (typeof type !== "number") {
        userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);
        if (!userOrRole)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
        type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      }
      const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);
      await this.client.rest.put(Routes.channelPermission(this.channel.id, userOrRoleId), {
        body: { id: userOrRoleId, type, allow, deny },
        reason
      });
      return this.channel;
    }
    create(userOrRole, options, overwriteOptions) {
      return this.upsert(userOrRole, options, overwriteOptions);
    }
    edit(userOrRole, options, overwriteOptions) {
      const existing = this.cache.get(this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole));
      return this.upsert(userOrRole, options, overwriteOptions, existing);
    }
    async delete(userOrRole, reason) {
      const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      if (!userOrRoleId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
      await this.client.rest.delete(Routes.channelPermission(this.channel.id, userOrRoleId), { reason });
      return this.channel;
    }
  }
  module.exports = PermissionOverwriteManager;
});

// ../../node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS((exports, module) => {
  var { Snowflake } = require_cjs();
  var { PermissionFlagsBits, ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var PermissionOverwriteManager = require_PermissionOverwriteManager();
  var { VoiceBasedChannelTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();
  var { getSortableGroupTypes } = require_Util();

  class GuildChannel extends BaseChannel {
    constructor(guild, data, client, immediatePatch = true) {
      super(client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.permissionOverwrites = new PermissionOverwriteManager(this);
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("permission_overwrites" in data) {
        this.permissionOverwrites.cache.clear();
        for (const overwrite of data.permission_overwrites) {
          this.permissionOverwrites._add(overwrite);
        }
      }
    }
    _clone() {
      const clone = super._clone();
      clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());
      return clone;
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    get permissionsLocked() {
      if (!this.parent)
        return null;
      const overwriteIds = new Set([
        ...this.permissionOverwrites.cache.keys(),
        ...this.parent.permissionOverwrites.cache.keys()
      ]);
      return [...overwriteIds].every((key) => {
        const channelVal = this.permissionOverwrites.cache.get(key);
        const parentVal = this.parent.permissionOverwrites.cache.get(key);
        if (!channelVal && parentVal.deny.bitfield === PermissionsBitField.DefaultBit && parentVal.allow.bitfield === PermissionsBitField.DefaultBit || !parentVal && channelVal.deny.bitfield === PermissionsBitField.DefaultBit && channelVal.allow.bitfield === PermissionsBitField.DefaultBit) {
          return true;
        }
        return channelVal !== undefined && parentVal !== undefined && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;
      });
    }
    get position() {
      const selfIsCategory = this.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(this.type);
      let count = 0;
      for (const channel of this.guild.channels.cache.values()) {
        if (!types.includes(channel.type))
          continue;
        if (!selfIsCategory && channel.parentId !== this.parentId)
          continue;
        if (this.rawPosition === channel.rawPosition) {
          if (Snowflake.compare(channel.id, this.id) === -1)
            count++;
        } else if (this.rawPosition > channel.rawPosition) {
          count++;
        }
      }
      return count;
    }
    permissionsFor(memberOrRole, checkAdmin = true) {
      const member = this.guild.members.resolve(memberOrRole);
      if (member)
        return this.memberPermissions(member, checkAdmin);
      const role = this.guild.roles.resolve(memberOrRole);
      return role && this.rolePermissions(role, checkAdmin);
    }
    overwritesFor(member, verified = false, roles = null) {
      if (!verified)
        member = this.guild.members.resolve(member);
      if (!member)
        return [];
      roles ??= member.roles.cache;
      const roleOverwrites = [];
      let memberOverwrites;
      let everyoneOverwrites;
      for (const overwrite of this.permissionOverwrites.cache.values()) {
        if (overwrite.id === this.guild.id) {
          everyoneOverwrites = overwrite;
        } else if (roles.has(overwrite.id)) {
          roleOverwrites.push(overwrite);
        } else if (overwrite.id === member.id) {
          memberOverwrites = overwrite;
        }
      }
      return {
        everyone: everyoneOverwrites,
        roles: roleOverwrites,
        member: memberOverwrites
      };
    }
    memberPermissions(member, checkAdmin) {
      if (checkAdmin && member.id === this.guild.ownerId) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const roles = member.roles.cache;
      const permissions = new PermissionsBitField(roles.map((role) => role.permissions));
      if (checkAdmin && permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const overwrites = this.overwritesFor(member, true, roles);
      return permissions.remove(overwrites.everyone?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.everyone?.allow ?? PermissionsBitField.DefaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : PermissionsBitField.DefaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : PermissionsBitField.DefaultBit).remove(overwrites.member?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.member?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    rolePermissions(role, checkAdmin) {
      if (checkAdmin && role.permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const basePermissions = new PermissionsBitField([role.permissions, role.guild.roles.everyone.permissions]);
      const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);
      const roleOverwrites = this.permissionOverwrites.cache.get(role.id);
      return basePermissions.remove(everyoneOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(everyoneOverwrites?.allow ?? PermissionsBitField.DefaultBit).remove(roleOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(roleOverwrites?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    async lockPermissions() {
      if (!this.parent)
        throw new DiscordjsError(ErrorCodes.GuildChannelOrphan);
      const permissionOverwrites = this.parent.permissionOverwrites.cache.map((overwrite) => overwrite.toJSON());
      return this.edit({ permissionOverwrites });
    }
    get members() {
      return this.guild.members.cache.filter((member) => this.permissionsFor(member).has(PermissionFlagsBits.ViewChannel, false));
    }
    edit(options) {
      return this.guild.channels.edit(this, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setParent(channel, { lockPermissions = true, reason } = {}) {
      return this.edit({
        parent: channel ?? null,
        lockPermissions,
        reason
      });
    }
    setPosition(position, options = {}) {
      return this.guild.channels.setPosition(this, position, options);
    }
    clone(options = {}) {
      return this.guild.channels.create({
        name: options.name ?? this.name,
        permissionOverwrites: this.permissionOverwrites.cache,
        topic: this.topic,
        type: this.type,
        nsfw: this.nsfw,
        parent: this.parent,
        bitrate: this.bitrate,
        userLimit: this.userLimit,
        rateLimitPerUser: this.rateLimitPerUser,
        position: this.rawPosition,
        reason: null,
        ...options
      });
    }
    equals(channel) {
      let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
      if (equal) {
        if (this.permissionOverwrites && channel.permissionOverwrites) {
          equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);
        } else {
          equal = !this.permissionOverwrites && !channel.permissionOverwrites;
        }
      }
      return equal;
    }
    get deletable() {
      return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;
    }
    get manageable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now())
        return false;
      const bitfield = VoiceBasedChannelTypes.includes(this.type) ? PermissionFlagsBits.ManageChannels | PermissionFlagsBits.Connect : PermissionFlagsBits.ViewChannel | PermissionFlagsBits.ManageChannels;
      return permissions.has(bitfield, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
  }
  module.exports = GuildChannel;
});

// ../../node_modules/discord.js/src/util/SKUFlagsBitField.js
var require_SKUFlagsBitField = __commonJS((exports) => {
  var { SKUFlags } = require_v106();
  var BitField = require_BitField();

  class SKUFlagsBitField extends BitField {
    static Flags = SKUFlags;
  }
  exports.SKUFlagsBitField = SKUFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/SKU.js
var require_SKU = __commonJS((exports) => {
  var Base = require_Base();
  var { SKUFlagsBitField } = require_SKUFlagsBitField();

  class SKU extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.type = data.type;
      this.applicationId = data.application_id;
      this.name = data.name;
      this.slug = data.slug;
      this.flags = new SKUFlagsBitField(data.flags).freeze();
    }
  }
  exports.SKU = SKU;
});

// ../../node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS((exports, module) => {
  var { parse } = __require("path");
  var process2 = __require("process");
  var { Collection } = require_dist6();
  var { ChannelType, RouteBases, Routes } = require_v106();
  var { fetch: fetch2 } = __require("undici");
  var Colors = require_Colors();
  var { DiscordjsError, DiscordjsRangeError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var isObject = (d) => typeof d === "object" && d !== null;
  var deprecationEmittedForUserFetchFlags = false;
  var deprecationEmittedForRemoveThreadMember = false;
  function flatten(obj, ...props) {
    if (!isObject(obj))
      return obj;
    const objProps = Object.keys(obj).filter((key) => !key.startsWith("_")).map((key) => ({ [key]: true }));
    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
    const out = {};
    for (let [prop, newProp] of Object.entries(props)) {
      if (!newProp)
        continue;
      newProp = newProp === true ? prop : newProp;
      const element = obj[prop];
      const elemIsObj = isObject(element);
      const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
      const hasToJSON = elemIsObj && typeof element.toJSON === "function";
      if (element instanceof Collection)
        out[newProp] = Array.from(element.keys());
      else if (valueOf instanceof Collection)
        out[newProp] = Array.from(valueOf.keys());
      else if (Array.isArray(element))
        out[newProp] = element.map((elm) => elm.toJSON?.() ?? flatten(elm));
      else if (typeof valueOf !== "object")
        out[newProp] = valueOf;
      else if (hasToJSON)
        out[newProp] = element.toJSON();
      else if (typeof element === "object")
        out[newProp] = flatten(element);
      else if (!elemIsObj)
        out[newProp] = element;
    }
    return out;
  }
  async function fetchRecommendedShardCount(token, { guildsPerShard = 1000, multipleOf = 1 } = {}) {
    if (!token)
      throw new DiscordjsError(ErrorCodes.TokenMissing);
    const response = await fetch2(RouteBases.api + Routes.gatewayBot(), {
      method: "GET",
      headers: { Authorization: `Bot ${token.replace(/^Bot\s*/i, "")}` }
    });
    if (!response.ok) {
      if (response.status === 401)
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      throw response;
    }
    const { shards } = await response.json();
    return Math.ceil(shards * (1000 / guildsPerShard) / multipleOf) * multipleOf;
  }
  function parseEmoji(text) {
    if (text.includes("%"))
      text = decodeURIComponent(text);
    if (!text.includes(":"))
      return { animated: false, name: text, id: undefined };
    const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
    return match && { animated: Boolean(match[1]), name: match[2], id: match[3] };
  }
  function resolvePartialEmoji(emoji) {
    if (!emoji)
      return null;
    if (typeof emoji === "string")
      return /^\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);
    const { id, name, animated } = emoji;
    if (!id && !name)
      return null;
    return { id, name, animated: Boolean(animated) };
  }
  function makeError(obj) {
    const err = new Error(obj.message);
    err.name = obj.name;
    err.stack = obj.stack;
    return err;
  }
  function makePlainError(err) {
    return {
      name: err.name,
      message: err.message,
      stack: err.stack
    };
  }
  var TextSortableGroupTypes = [
    ChannelType.GuildText,
    ChannelType.GuildAnnouncement,
    ChannelType.GuildForum,
    ChannelType.GuildMedia
  ];
  var VoiceSortableGroupTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  var CategorySortableGroupTypes = [ChannelType.GuildCategory];
  function getSortableGroupTypes(type) {
    switch (type) {
      case ChannelType.GuildText:
      case ChannelType.GuildAnnouncement:
      case ChannelType.GuildForum:
      case ChannelType.GuildMedia:
        return TextSortableGroupTypes;
      case ChannelType.GuildVoice:
      case ChannelType.GuildStageVoice:
        return VoiceSortableGroupTypes;
      case ChannelType.GuildCategory:
        return CategorySortableGroupTypes;
      default:
        return [type];
    }
  }
  function moveElementInArray(array, element, newIndex, offset = false) {
    const index = array.indexOf(element);
    newIndex = (offset ? index : 0) + newIndex;
    if (newIndex > -1 && newIndex < array.length) {
      const removedElement = array.splice(index, 1)[0];
      array.splice(newIndex, 0, removedElement);
    }
    return array.indexOf(element);
  }
  function verifyString(data, error = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {
    if (typeof data !== "string")
      throw new error(errorMessage);
    if (!allowEmpty && data.length === 0)
      throw new error(errorMessage);
    return data;
  }
  function resolveColor(color) {
    let resolvedColor;
    if (typeof color === "string") {
      if (color === "Random")
        return Math.floor(Math.random() * (16777215 + 1));
      if (color === "Default")
        return 0;
      if (/^#?[\da-f]{6}$/i.test(color))
        return parseInt(color.replace("#", ""), 16);
      resolvedColor = Colors[color];
    } else if (Array.isArray(color)) {
      resolvedColor = (color[0] << 16) + (color[1] << 8) + color[2];
    } else {
      resolvedColor = color;
    }
    if (!Number.isInteger(resolvedColor)) {
      throw new DiscordjsTypeError(ErrorCodes.ColorConvert, color);
    }
    if (resolvedColor < 0 || resolvedColor > 16777215) {
      throw new DiscordjsRangeError(ErrorCodes.ColorRange);
    }
    return resolvedColor;
  }
  function discordSort(collection) {
    const isGuildChannel = collection.first() instanceof GuildChannel;
    return collection.sorted(isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id)));
  }
  async function setPosition(item, position, relative, sorted, client, route, reason) {
    let updatedItems = [...sorted.values()];
    moveElementInArray(updatedItems, item, position, relative);
    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
    await client.rest.patch(route, { body: updatedItems, reason });
    return updatedItems;
  }
  function basename(path, ext) {
    const res = parse(path);
    return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
  }
  function cleanContent(str, channel) {
    return str.replaceAll(/<(?:(?<type>@[!&]?|#)|(?:\/(?<commandName>[-_\p{L}\p{N}\p{sc=Deva}\p{sc=Thai} ]+):)|(?:a?:(?<emojiName>[\w]+):))(?<id>\d{17,19})>/gu, (match, type, commandName, emojiName, id) => {
      if (commandName)
        return `/${commandName}`;
      if (emojiName)
        return `:${emojiName}:`;
      switch (type) {
        case "@":
        case "@!": {
          const member = channel.guild?.members.cache.get(id);
          if (member) {
            return `@${member.displayName}`;
          }
          const user = channel.client.users.cache.get(id);
          return user ? `@${user.displayName}` : match;
        }
        case "@&": {
          if (channel.type === ChannelType.DM)
            return match;
          const role = channel.guild.roles.cache.get(id);
          return role ? `@${role.name}` : match;
        }
        case "#": {
          const mentionedChannel = channel.client.channels.cache.get(id);
          return mentionedChannel ? `#${mentionedChannel.name}` : match;
        }
        default: {
          return match;
        }
      }
    });
  }
  function cleanCodeBlockContent(text) {
    return text.replaceAll("```", "`\u200B``");
  }
  function parseWebhookURL(url) {
    const matches = url.match(/https?:\/\/(?:ptb\.|canary\.)?discord\.com\/api(?:\/v\d{1,2})?\/webhooks\/(\d{17,19})\/([\w-]{68})/i);
    if (!matches || matches.length <= 2)
      return null;
    const [, id, token] = matches;
    return {
      id,
      token
    };
  }
  function transformResolved({ client, guild, channel }, { members, users, channels, roles, messages, attachments } = {}) {
    const result = {};
    if (members) {
      result.members = new Collection;
      for (const [id, member] of Object.entries(members)) {
        const user = users[id];
        result.members.set(id, guild?.members._add({ user, ...member }) ?? member);
      }
    }
    if (users) {
      result.users = new Collection;
      for (const user of Object.values(users)) {
        result.users.set(user.id, client.users._add(user));
      }
    }
    if (roles) {
      result.roles = new Collection;
      for (const role of Object.values(roles)) {
        result.roles.set(role.id, guild?.roles._add(role) ?? role);
      }
    }
    if (channels) {
      result.channels = new Collection;
      for (const apiChannel of Object.values(channels)) {
        result.channels.set(apiChannel.id, client.channels._add(apiChannel, guild) ?? apiChannel);
      }
    }
    if (messages) {
      result.messages = new Collection;
      for (const message of Object.values(messages)) {
        result.messages.set(message.id, channel?.messages?._add(message) ?? message);
      }
    }
    if (attachments) {
      result.attachments = new Collection;
      for (const attachment of Object.values(attachments)) {
        const patched = new Attachment(attachment);
        result.attachments.set(attachment.id, patched);
      }
    }
    return result;
  }
  function resolveSKUId(resolvable) {
    if (typeof resolvable === "string")
      return resolvable;
    if (resolvable instanceof SKU)
      return resolvable.id;
    return null;
  }
  function emitDeprecationWarningForUserFetchFlags(name) {
    if (deprecationEmittedForUserFetchFlags)
      return;
    process2.emitWarning(`${name}#fetchFlags() is deprecated. Use ${name}#fetch() instead.`);
    deprecationEmittedForUserFetchFlags = true;
  }
  function emitDeprecationWarningForRemoveThreadMember(name) {
    if (deprecationEmittedForRemoveThreadMember)
      return;
    process2.emitWarning(`The reason parameter of ${name}#remove() is deprecated as Discord does not parse them. It will be removed in the next major version.`);
    deprecationEmittedForRemoveThreadMember = true;
  }
  module.exports = {
    flatten,
    fetchRecommendedShardCount,
    parseEmoji,
    resolvePartialEmoji,
    makeError,
    makePlainError,
    getSortableGroupTypes,
    moveElementInArray,
    verifyString,
    resolveColor,
    discordSort,
    setPosition,
    basename,
    cleanContent,
    cleanCodeBlockContent,
    parseWebhookURL,
    transformResolved,
    resolveSKUId,
    emitDeprecationWarningForUserFetchFlags,
    emitDeprecationWarningForRemoveThreadMember
  };
  var Attachment = require_Attachment();
  var GuildChannel = require_GuildChannel();
  var { SKU } = require_SKU();
});

// ../../node_modules/discord.js/src/util/Transformers.js
var require_Transformers = __commonJS((exports, module) => {
  var { isJSONEncodable } = require_dist();
  var snakeCase = require_lodash();
  var { resolvePartialEmoji } = require_Util();
  function toSnakeCase(obj) {
    if (typeof obj !== "object" || !obj)
      return obj;
    if (obj instanceof Date)
      return obj;
    if (isJSONEncodable(obj))
      return toSnakeCase(obj.toJSON());
    if (Array.isArray(obj))
      return obj.map(toSnakeCase);
    return Object.fromEntries(Object.entries(obj).map(([key, value]) => [
      snakeCase(key),
      key === "emoji" && typeof value === "string" ? resolvePartialEmoji(value) : toSnakeCase(value)
    ]));
  }
  function _transformAPIAutoModerationAction(autoModerationAction) {
    return {
      type: autoModerationAction.type,
      metadata: {
        durationSeconds: autoModerationAction.metadata.duration_seconds ?? null,
        channelId: autoModerationAction.metadata.channel_id ?? null,
        customMessage: autoModerationAction.metadata.custom_message ?? null
      }
    };
  }
  function _transformAPIMessageInteractionMetadata(client, messageInteractionMetadata) {
    return {
      id: messageInteractionMetadata.id,
      type: messageInteractionMetadata.type,
      user: client.users._add(messageInteractionMetadata.user),
      authorizingIntegrationOwners: messageInteractionMetadata.authorizing_integration_owners,
      originalResponseMessageId: messageInteractionMetadata.original_response_message_id ?? null,
      interactedMessageId: messageInteractionMetadata.interacted_message_id ?? null,
      triggeringInteractionMetadata: messageInteractionMetadata.triggering_interaction_metadata ? _transformAPIMessageInteractionMetadata(client, messageInteractionMetadata.triggering_interaction_metadata) : null
    };
  }
  function _transformGuildScheduledEventRecurrenceRule(recurrenceRule) {
    return {
      start: new Date(recurrenceRule.startAt).toISOString(),
      frequency: recurrenceRule.frequency,
      interval: recurrenceRule.interval,
      by_weekday: recurrenceRule.byWeekday,
      by_n_weekday: recurrenceRule.byNWeekday,
      by_month: recurrenceRule.byMonth,
      by_month_day: recurrenceRule.byMonthDay
    };
  }
  function _transformAPIIncidentsData(data) {
    return {
      invitesDisabledUntil: data.invites_disabled_until ? new Date(data.invites_disabled_until) : null,
      dmsDisabledUntil: data.dms_disabled_until ? new Date(data.dms_disabled_until) : null,
      dmSpamDetectedAt: data.dm_spam_detected_at ? new Date(data.dm_spam_detected_at) : null,
      raidDetectedAt: data.raid_detected_at ? new Date(data.raid_detected_at) : null
    };
  }
  function _transformCollectibles(collectibles) {
    if (!collectibles.nameplate)
      return { nameplate: null };
    return {
      nameplate: {
        skuId: collectibles.nameplate.sku_id,
        asset: collectibles.nameplate.asset,
        label: collectibles.nameplate.label,
        palette: collectibles.nameplate.palette
      }
    };
  }
  module.exports = {
    toSnakeCase,
    _transformAPIAutoModerationAction,
    _transformAPIMessageInteractionMetadata,
    _transformGuildScheduledEventRecurrenceRule,
    _transformAPIIncidentsData,
    _transformCollectibles
  };
});

// ../../node_modules/discord.js/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    $schema: "https://json.schemastore.org/package.json",
    name: "discord.js",
    version: "14.22.1",
    description: "A powerful library for interacting with the Discord API",
    main: "./src/index.js",
    types: "./typings/index.d.ts",
    exports: {
      ".": {
        import: {
          types: "./typings/index.d.mts",
          default: "./src/index.js"
        },
        require: {
          types: "./typings/index.d.ts",
          default: "./src/index.js"
        }
      }
    },
    directories: {
      lib: "src",
      test: "test"
    },
    files: [
      "src",
      "typings/*.d.ts",
      "typings/*.d.mts"
    ],
    contributors: [
      "Crawl <icrawltogo@gmail.com>",
      "Amish Shah <amishshah.2k@gmail.com>",
      "Vlad Frangu <me@vladfrangu.dev>",
      "SpaceEEC <spaceeec@yahoo.com>",
      "Aura Rom\xE1n <kyradiscord@gmail.com>"
    ],
    license: "Apache-2.0",
    keywords: [
      "discord",
      "api",
      "bot",
      "client",
      "node",
      "discordapp"
    ],
    repository: {
      type: "git",
      url: "https://github.com/discordjs/discord.js.git",
      directory: "packages/discord.js"
    },
    bugs: {
      url: "https://github.com/discordjs/discord.js/issues"
    },
    homepage: "https://discord.js.org",
    funding: "https://github.com/discordjs/discord.js?sponsor",
    dependencies: {
      "@discordjs/builders": "^1.11.2",
      "@discordjs/collection": "1.5.3",
      "@discordjs/formatters": "^0.6.1",
      "@discordjs/ws": "^1.2.3",
      "@sapphire/snowflake": "3.5.3",
      "discord-api-types": "^0.38.16",
      "fast-deep-equal": "3.1.3",
      "lodash.snakecase": "4.1.1",
      "magic-bytes.js": "^1.10.0",
      tslib: "^2.6.3",
      undici: "6.21.3",
      "@discordjs/util": "^1.1.1",
      "@discordjs/rest": "^2.6.0"
    },
    devDependencies: {
      "@favware/cliff-jumper": "^4.1.0",
      "@types/node": "^16.18.105",
      "@typescript-eslint/eslint-plugin": "^8.2.0",
      "@typescript-eslint/parser": "^8.2.0",
      "cross-env": "^7.0.3",
      dtslint: "4.2.1",
      eslint: "^8.57.0",
      "eslint-formatter-pretty": "^5.0.0",
      jest: "29.7.0",
      prettier: "^3.3.3",
      tsd: "^0.31.1",
      tslint: "6.1.3",
      turbo: "^2.0.14",
      typescript: "~5.5.4",
      "@discordjs/api-extractor": "^7.38.1",
      "@discordjs/docgen": "^0.12.1",
      "@discordjs/scripts": "^0.1.0"
    },
    engines: {
      node: ">=18"
    },
    publishConfig: {
      provenance: true
    },
    scripts: {
      test: "pnpm run docs:test && pnpm run test:typescript",
      "test:typescript": "tsc --noEmit && tsd",
      lint: "prettier --check . && tslint typings/index.d.ts && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --format=pretty src typings",
      format: "prettier --write . && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --fix --format=pretty src",
      fmt: "pnpm run format",
      docs: 'docgen -i "./src/*.js" "./src/**/*.js" -c ./docs/index.json -r ../../ -o ./docs/docs.json && pnpm run docs:new',
      "docs:test": 'docgen -i "./src/*.js" "./src/**/*.js" -c ./docs/index.json -r ../../',
      "docs:new": "api-extractor run --local --minify && generate-split-documentation",
      changelog: "git cliff --prepend ./CHANGELOG.md -u -c ./cliff.toml -r ../../ --include-path 'packages/discord.js/*'",
      release: "cliff-jumper"
    }
  };
});

// ../../node_modules/discord.js/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class LimitedCollection extends Collection {
    constructor(options = {}, iterable) {
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      const { maxSize = Infinity, keepOverLimit = null } = options;
      if (typeof maxSize !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "maxSize", "number");
      }
      if (keepOverLimit !== null && typeof keepOverLimit !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "keepOverLimit", "function");
      }
      super(iterable);
      this.maxSize = maxSize;
      this.keepOverLimit = keepOverLimit;
    }
    set(key, value) {
      if (this.maxSize === 0 && !this.keepOverLimit?.(value, key, this))
        return this;
      if (this.size >= this.maxSize && !this.has(key)) {
        for (const [k, v] of this.entries()) {
          const keep = this.keepOverLimit?.(v, k, this) ?? false;
          if (!keep) {
            this.delete(k);
            break;
          }
        }
      }
      return super.set(key, value);
    }
    static get [Symbol.species]() {
      return Collection;
    }
  }
  module.exports = LimitedCollection;
});

// ../../node_modules/discord.js/src/util/Options.js
var require_Options = __commonJS((exports, module) => {
  var { DefaultRestOptions, DefaultUserAgentAppendix } = require_dist5();
  var { toSnakeCase } = require_Transformers();
  var { version } = require_package();

  class Options extends null {
    static userAgentAppendix = `discord.js/${version} ${DefaultUserAgentAppendix}`.trimEnd();
    static createDefault() {
      return {
        closeTimeout: 5000,
        waitGuildTimeout: 15000,
        shardCount: 1,
        makeCache: this.cacheWithLimits(this.DefaultMakeCacheSettings),
        partials: [],
        failIfNotExists: true,
        enforceNonce: false,
        presence: {},
        sweepers: this.DefaultSweeperSettings,
        ws: {
          large_threshold: 50,
          version: 10
        },
        rest: {
          ...DefaultRestOptions,
          userAgentAppendix: this.userAgentAppendix
        },
        jsonTransformer: toSnakeCase
      };
    }
    static cacheWithLimits(settings = {}) {
      const { Collection } = require_dist6();
      const LimitedCollection = require_LimitedCollection();
      return (managerType, _, manager) => {
        const setting = settings[manager.name] ?? settings[managerType.name];
        if (setting == null) {
          return new Collection;
        }
        if (typeof setting === "number") {
          if (setting === Infinity) {
            return new Collection;
          }
          return new LimitedCollection({ maxSize: setting });
        }
        const noLimit = setting.maxSize == null || setting.maxSize === Infinity;
        if (noLimit) {
          return new Collection;
        }
        return new LimitedCollection(setting);
      };
    }
    static cacheEverything() {
      const { Collection } = require_dist6();
      return () => new Collection;
    }
    static get DefaultMakeCacheSettings() {
      return {
        MessageManager: 200
      };
    }
    static get DefaultSweeperSettings() {
      return {
        threads: {
          interval: 3600,
          lifetime: 14400
        }
      };
    }
  }
  module.exports = Options;
});

// ../../node_modules/discord.js/src/client/BaseClient.js
var require_BaseClient = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var { REST } = require_dist5();
  var { Routes } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var Options = require_Options();
  var { flatten } = require_Util();

  class BaseClient extends EventEmitter {
    constructor(options = {}) {
      super({ captureRejections: true });
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      const defaultOptions = Options.createDefault();
      this.options = {
        ...defaultOptions,
        ...options,
        presence: {
          ...defaultOptions.presence,
          ...options.presence
        },
        sweepers: {
          ...defaultOptions.sweepers,
          ...options.sweepers
        },
        ws: {
          ...defaultOptions.ws,
          ...options.ws
        },
        rest: {
          ...defaultOptions.rest,
          ...options.rest,
          userAgentAppendix: options.rest?.userAgentAppendix ? `${Options.userAgentAppendix} ${options.rest.userAgentAppendix}` : Options.userAgentAppendix
        }
      };
      this.rest = new REST(this.options.rest);
    }
    destroy() {
      this.rest.clearHashSweeper();
      this.rest.clearHandlerSweeper();
    }
    async deleteWebhook(id, { token, reason } = {}) {
      await this.rest.delete(Routes.webhook(id, token), { auth: !token, reason });
    }
    incrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners - 1);
      }
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
    async[Symbol.asyncDispose]() {
      await this.destroy();
    }
  }
  module.exports = BaseClient;
});

// ../../node_modules/discord.js/src/util/Enums.js
var require_Enums = __commonJS((exports, module) => {
  function createEnum(keys) {
    const obj = {};
    for (const [index, key] of keys.entries()) {
      if (key === null)
        continue;
      obj[key] = index;
      obj[index] = key;
    }
    return obj;
  }
  module.exports = { createEnum };
});

// ../../node_modules/discord.js/src/util/Partials.js
var require_Partials = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "User",
    "Channel",
    "GuildMember",
    "Message",
    "Reaction",
    "GuildScheduledEvent",
    "ThreadMember",
    "SoundboardSound"
  ]);
});

// ../../node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS((exports, module) => {
  var Partials = require_Partials();

  class GenericAction {
    constructor(client) {
      this.client = client;
    }
    handle(data) {
      return data;
    }
    getPayload(data, manager, id, partialType, cache) {
      return this.client.options.partials.includes(partialType) ? manager._add(data, cache) : manager.cache.get(id);
    }
    getChannel(data) {
      const payloadData = {};
      const id = data.channel_id ?? data.id;
      if (!("recipients" in data)) {
        const recipient = data.author ?? data.user ?? { id: data.user_id };
        if (recipient.id !== this.client.user.id)
          payloadData.recipients = [recipient];
      }
      if (id !== undefined)
        payloadData.id = id;
      return data[this.client.actions.injectedChannel] ?? this.getPayload({ ...data, ...payloadData }, this.client.channels, id, Partials.Channel);
    }
    getMessage(data, channel, cache) {
      const id = data.message_id ?? data.id;
      return data[this.client.actions.injectedMessage] ?? this.getPayload({
        id,
        channel_id: channel.id,
        guild_id: data.guild_id ?? channel.guild?.id
      }, channel.messages, id, Partials.Message, cache);
    }
    getReaction(data, message, user) {
      const id = data.emoji.id ?? decodeURIComponent(data.emoji.name);
      return this.getPayload({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user?.id === this.client.user.id
      }, message.reactions, id, Partials.Reaction);
    }
    getMember(data, guild) {
      return this.getPayload(data, guild.members, data.user.id, Partials.GuildMember);
    }
    getUser(data) {
      const id = data.user_id;
      return data[this.client.actions.injectedUser] ?? this.getPayload({ id }, this.client.users, id, Partials.User);
    }
    getUserFromMember(data) {
      if (data.guild_id && data.member?.user) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (guild) {
          return guild.members._add(data.member).user;
        } else {
          return this.client.users._add(data.member.user);
        }
      }
      return this.getUser(data);
    }
    getScheduledEvent(data, guild) {
      const id = data.guild_scheduled_event_id ?? data.id;
      return this.getPayload({ id, guild_id: data.guild_id ?? guild.id }, guild.scheduledEvents, id, Partials.GuildScheduledEvent);
    }
    getThreadMember(id, manager) {
      return this.getPayload({ user_id: id }, manager, id, Partials.ThreadMember, false);
    }
    getSoundboardSound(data, guild) {
      return this.getPayload(data, guild.soundboardSounds, data.sound_id, Partials.SoundboardSound);
    }
    spreadInjectedData(data) {
      return Object.fromEntries(Object.getOwnPropertySymbols(data).map((symbol) => [symbol, data[symbol]]));
    }
  }
  module.exports = GenericAction;
});

// ../../node_modules/discord.js/src/util/Events.js
var require_Events = __commonJS((exports, module) => {
  module.exports = {
    ApplicationCommandPermissionsUpdate: "applicationCommandPermissionsUpdate",
    AutoModerationActionExecution: "autoModerationActionExecution",
    AutoModerationRuleCreate: "autoModerationRuleCreate",
    AutoModerationRuleDelete: "autoModerationRuleDelete",
    AutoModerationRuleUpdate: "autoModerationRuleUpdate",
    CacheSweep: "cacheSweep",
    ChannelCreate: "channelCreate",
    ChannelDelete: "channelDelete",
    ChannelPinsUpdate: "channelPinsUpdate",
    ChannelUpdate: "channelUpdate",
    ClientReady: "clientReady",
    Debug: "debug",
    EntitlementCreate: "entitlementCreate",
    EntitlementUpdate: "entitlementUpdate",
    EntitlementDelete: "entitlementDelete",
    Error: "error",
    GuildAuditLogEntryCreate: "guildAuditLogEntryCreate",
    GuildAvailable: "guildAvailable",
    GuildBanAdd: "guildBanAdd",
    GuildBanRemove: "guildBanRemove",
    GuildCreate: "guildCreate",
    GuildDelete: "guildDelete",
    GuildEmojiCreate: "emojiCreate",
    GuildEmojiDelete: "emojiDelete",
    GuildEmojiUpdate: "emojiUpdate",
    GuildIntegrationsUpdate: "guildIntegrationsUpdate",
    GuildMemberAdd: "guildMemberAdd",
    GuildMemberAvailable: "guildMemberAvailable",
    GuildMemberRemove: "guildMemberRemove",
    GuildMembersChunk: "guildMembersChunk",
    GuildMemberUpdate: "guildMemberUpdate",
    GuildRoleCreate: "roleCreate",
    GuildRoleDelete: "roleDelete",
    GuildRoleUpdate: "roleUpdate",
    GuildScheduledEventCreate: "guildScheduledEventCreate",
    GuildScheduledEventDelete: "guildScheduledEventDelete",
    GuildScheduledEventUpdate: "guildScheduledEventUpdate",
    GuildScheduledEventUserAdd: "guildScheduledEventUserAdd",
    GuildScheduledEventUserRemove: "guildScheduledEventUserRemove",
    GuildSoundboardSoundCreate: "guildSoundboardSoundCreate",
    GuildSoundboardSoundDelete: "guildSoundboardSoundDelete",
    GuildSoundboardSoundsUpdate: "guildSoundboardSoundsUpdate",
    GuildSoundboardSoundUpdate: "guildSoundboardSoundUpdate",
    GuildStickerCreate: "stickerCreate",
    GuildStickerDelete: "stickerDelete",
    GuildStickerUpdate: "stickerUpdate",
    GuildUnavailable: "guildUnavailable",
    GuildUpdate: "guildUpdate",
    InteractionCreate: "interactionCreate",
    Invalidated: "invalidated",
    InviteCreate: "inviteCreate",
    InviteDelete: "inviteDelete",
    MessageBulkDelete: "messageDeleteBulk",
    MessageCreate: "messageCreate",
    MessageDelete: "messageDelete",
    MessagePollVoteAdd: "messagePollVoteAdd",
    MessagePollVoteRemove: "messagePollVoteRemove",
    MessageReactionAdd: "messageReactionAdd",
    MessageReactionRemove: "messageReactionRemove",
    MessageReactionRemoveAll: "messageReactionRemoveAll",
    MessageReactionRemoveEmoji: "messageReactionRemoveEmoji",
    MessageUpdate: "messageUpdate",
    PresenceUpdate: "presenceUpdate",
    SoundboardSounds: "soundboardSounds",
    Raw: "raw",
    ShardDisconnect: "shardDisconnect",
    ShardError: "shardError",
    ShardReady: "shardReady",
    ShardReconnecting: "shardReconnecting",
    ShardResume: "shardResume",
    StageInstanceCreate: "stageInstanceCreate",
    StageInstanceDelete: "stageInstanceDelete",
    StageInstanceUpdate: "stageInstanceUpdate",
    SubscriptionCreate: "subscriptionCreate",
    SubscriptionUpdate: "subscriptionUpdate",
    SubscriptionDelete: "subscriptionDelete",
    ThreadCreate: "threadCreate",
    ThreadDelete: "threadDelete",
    ThreadListSync: "threadListSync",
    ThreadMembersUpdate: "threadMembersUpdate",
    ThreadMemberUpdate: "threadMemberUpdate",
    ThreadUpdate: "threadUpdate",
    TypingStart: "typingStart",
    UserUpdate: "userUpdate",
    VoiceChannelEffectSend: "voiceChannelEffectSend",
    VoiceServerUpdate: "voiceServerUpdate",
    VoiceStateUpdate: "voiceStateUpdate",
    Warn: "warn",
    WebhooksUpdate: "webhooksUpdate"
  };
});

// ../../node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js
var require_ApplicationCommandPermissionsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ApplicationCommandPermissionsUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      client.emit(Events.ApplicationCommandPermissionsUpdate, {
        permissions: data.permissions,
        id: data.id,
        guildId: data.guild_id,
        applicationId: data.application_id
      });
    }
  }
  module.exports = ApplicationCommandPermissionsUpdateAction;
});

// ../../node_modules/discord.js/src/structures/AutoModerationActionExecution.js
var require_AutoModerationActionExecution = __commonJS((exports, module) => {
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationActionExecution {
    constructor(data, guild) {
      this.guild = guild;
      this.action = _transformAPIAutoModerationAction(data.action);
      this.ruleId = data.rule_id;
      this.ruleTriggerType = data.rule_trigger_type;
      this.userId = data.user_id;
      this.channelId = data.channel_id ?? null;
      this.messageId = data.message_id ?? null;
      this.alertSystemMessageId = data.alert_system_message_id ?? null;
      this.content = data.content;
      this.matchedKeyword = data.matched_keyword ?? null;
      this.matchedContent = data.matched_content ?? null;
    }
    get autoModerationRule() {
      return this.guild.autoModerationRules.cache.get(this.ruleId) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get user() {
      return this.guild.client.users.cache.get(this.userId) ?? null;
    }
    get member() {
      return this.guild.members.cache.get(this.userId) ?? null;
    }
  }
  module.exports = AutoModerationActionExecution;
});

// ../../node_modules/discord.js/src/client/actions/AutoModerationActionExecution.js
var require_AutoModerationActionExecution2 = __commonJS((exports, module) => {
  var Action = require_Action();
  var AutoModerationActionExecution = require_AutoModerationActionExecution();
  var Events = require_Events();

  class AutoModerationActionExecutionAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        client.emit(Events.AutoModerationActionExecution, new AutoModerationActionExecution(data, guild));
      }
      return {};
    }
  }
  module.exports = AutoModerationActionExecutionAction;
});

// ../../node_modules/discord.js/src/client/actions/AutoModerationRuleCreate.js
var require_AutoModerationRuleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleCreateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleCreate, autoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/AutoModerationRuleDelete.js
var require_AutoModerationRuleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleDeleteAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules.cache.get(data.id);
        if (autoModerationRule) {
          guild.autoModerationRules.cache.delete(autoModerationRule.id);
          client.emit(Events.AutoModerationRuleDelete, autoModerationRule);
        }
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/AutoModerationRuleUpdate.js
var require_AutoModerationRuleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleUpdateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldAutoModerationRule = guild.autoModerationRules.cache.get(data.id)?._clone() ?? null;
        const newAutoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleUpdate, oldAutoModerationRule, newAutoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const channel = client.channels._add(data);
      if (!existing && channel) {
        client.emit(Events.ChannelCreate, channel);
      }
      return { channel };
    }
  }
  module.exports = ChannelCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.id);
      if (channel) {
        client.channels._remove(channel.id);
        client.emit(Events.ChannelDelete, channel);
      }
    }
  }
  module.exports = ChannelDeleteAction;
});

// ../../node_modules/discord.js/src/managers/CategoryChannelChildManager.js
var require_CategoryChannelChildManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var GuildChannel = require_GuildChannel();

  class CategoryChannelChildManager extends DataManager {
    constructor(channel) {
      super(channel.client, GuildChannel);
      this.channel = channel;
    }
    get cache() {
      return this.guild.channels.cache.filter((channel) => channel.parentId === this.channel.id);
    }
    get guild() {
      return this.channel.guild;
    }
    create(options) {
      return this.guild.channels.create({
        ...options,
        parent: this.channel.id
      });
    }
  }
  module.exports = CategoryChannelChildManager;
});

// ../../node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var CategoryChannelChildManager = require_CategoryChannelChildManager();

  class CategoryChannel extends GuildChannel {
    get children() {
      return new CategoryChannelChildManager(this);
    }
  }
  module.exports = CategoryChannel;
});

// ../../node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("timers");
  var { Collection } = require_dist6();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { flatten } = require_Util();

  class Collector extends EventEmitter {
    constructor(client, options = {}) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.filter = options.filter ?? (() => true);
      this.options = options;
      this.collected = new Collection;
      this.ended = false;
      this._timeout = null;
      this._idletimeout = null;
      this._endReason = null;
      if (typeof this.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.filter", "function");
      }
      this.handleCollect = this.handleCollect.bind(this);
      this.handleDispose = this.handleDispose.bind(this);
      if (options.time)
        this._timeout = setTimeout2(() => this.stop("time"), options.time).unref();
      if (options.idle)
        this._idletimeout = setTimeout2(() => this.stop("idle"), options.idle).unref();
      this.lastCollectedTimestamp = null;
    }
    get lastCollectedAt() {
      return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);
    }
    async handleCollect(...args) {
      const collectedId = await this.collect(...args);
      if (collectedId) {
        const filterResult = await this.filter(...args, this.collected);
        if (filterResult) {
          this.collected.set(collectedId, args[0]);
          this.emit("collect", ...args);
          this.lastCollectedTimestamp = Date.now();
          if (this._idletimeout) {
            clearTimeout2(this._idletimeout);
            this._idletimeout = setTimeout2(() => this.stop("idle"), this.options.idle).unref();
          }
        } else {
          this.emit("ignore", ...args);
        }
      }
      this.checkEnd();
    }
    async handleDispose(...args) {
      if (!this.options.dispose)
        return;
      const dispose = this.dispose(...args);
      if (!dispose || !await this.filter(...args) || !this.collected.has(dispose))
        return;
      this.collected.delete(dispose);
      this.emit("dispose", ...args);
      this.checkEnd();
    }
    get next() {
      return new Promise((resolve, reject) => {
        if (this.ended) {
          reject(this.collected);
          return;
        }
        const cleanup = () => {
          this.removeListener("collect", onCollect);
          this.removeListener("end", onEnd);
        };
        const onCollect = (item) => {
          cleanup();
          resolve(item);
        };
        const onEnd = () => {
          cleanup();
          reject(this.collected);
        };
        this.on("collect", onCollect);
        this.on("end", onEnd);
      });
    }
    stop(reason = "user") {
      if (this.ended)
        return;
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = null;
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = null;
      }
      this._endReason = reason;
      this.ended = true;
      this.emit("end", this.collected, reason);
    }
    resetTimer({ time, idle } = {}) {
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = setTimeout2(() => this.stop("time"), time ?? this.options.time).unref();
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = setTimeout2(() => this.stop("idle"), idle ?? this.options.idle).unref();
      }
    }
    checkEnd() {
      const reason = this.endReason;
      if (reason)
        this.stop(reason);
      return Boolean(reason);
    }
    async* [Symbol.asyncIterator]() {
      const queue = [];
      const onCollect = (...item) => queue.push(item);
      this.on("collect", onCollect);
      try {
        while (queue.length || !this.ended) {
          if (queue.length) {
            yield queue.shift();
          } else {
            await new Promise((resolve) => {
              const tick = () => {
                this.removeListener("collect", tick);
                this.removeListener("end", tick);
                return resolve();
              };
              this.on("collect", tick);
              this.on("end", tick);
            });
          }
        }
      } finally {
        this.removeListener("collect", onCollect);
      }
    }
    toJSON() {
      return flatten(this);
    }
    get endReason() {
      return this._endReason;
    }
    collect() {}
    dispose() {}
  }
  module.exports = Collector;
});

// ../../node_modules/discord.js/src/structures/InteractionCollector.js
var require_InteractionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Collector = require_Collector();
  var Events = require_Events();

  class InteractionCollector extends Collector {
    constructor(client, options = {}) {
      super(client, options);
      this.messageId = options.message?.id ?? options.interactionResponse?.interaction.message?.id ?? null;
      this.messageInteractionId = options.interactionResponse?.id ?? null;
      this.channelId = options.interactionResponse?.interaction.channelId ?? options.message?.channelId ?? options.message?.channel_id ?? this.client.channels.resolveId(options.channel);
      this.guildId = options.interactionResponse?.interaction.guildId ?? options.message?.guildId ?? options.message?.guild_id ?? this.client.guilds.resolveId(options.channel?.guild) ?? this.client.guilds.resolveId(options.guild);
      this.interactionType = options.interactionType ?? null;
      this.componentType = options.componentType ?? null;
      this.users = new Collection;
      this.total = 0;
      this.client.incrementMaxListeners();
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.messageId))
          this.stop("messageDelete");
      };
      if (this.messageId || this.messageInteractionId) {
        this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
        this.client.on(Events.MessageDelete, this._handleMessageDeletion);
        this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      }
      if (this.channelId) {
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      }
      if (this.guildId) {
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      }
      this.client.on(Events.InteractionCreate, this.handleCollect);
      this.once("end", () => {
        this.client.removeListener(Events.InteractionCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (interaction) => {
        this.total++;
        this.users.set(interaction.user.id, interaction.user);
      });
    }
    collect(interaction) {
      if (this.interactionType && interaction.type !== this.interactionType)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interactionMetadata?.id && interaction.message.interactionMetadata.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    dispose(interaction) {
      if (this.type && interaction.type !== this.type)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interactionMetadata?.id && interaction.message.interactionMetadata.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxComponents && this.collected.size >= this.options.maxComponents)
        return "componentLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.messageId) {
        this.stop("messageDelete");
      }
      if (message.interactionMetadata?.id === this.messageInteractionId) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channelId || channel.threads?.cache.has(this.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.guildId) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = InteractionCollector;
});

// ../../node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS((exports, module) => {
  var Collector = require_Collector();
  var Events = require_Events();

  class MessageCollector extends Collector {
    constructor(channel, options = {}) {
      super(channel.client, options);
      this.channel = channel;
      this.received = 0;
      const bulkDeleteListener = (messages) => {
        for (const message of messages.values())
          this.handleDispose(message);
      };
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageCreate, this.handleCollect);
      this.client.on(Events.MessageDelete, this.handleDispose);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this.handleDispose);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
    }
    collect(message) {
      if (message.channelId !== this.channel.id)
        return null;
      this.received++;
      return message.id;
    }
    dispose(message) {
      return message.channelId === this.channel.id ? message.id : null;
    }
    get endReason() {
      if (this.options.max && this.collected.size >= this.options.max)
        return "limit";
      if (this.options.maxProcessed && this.received === this.options.maxProcessed)
        return "processedLimit";
      return super.endReason;
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channel.id || channel.id === this.channel.parentId) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channel.id) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.channel.guild?.id) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = MessageCollector;
});

// ../../node_modules/discord.js/src/structures/GuildScheduledEvent.js
var require_GuildScheduledEvent = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var { GuildScheduledEventStatus, GuildScheduledEventEntityType, RouteBases } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class GuildScheduledEvent extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.guildId = data.guild_id;
      this._patch(data);
    }
    _patch(data) {
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      } else {
        this.creatorId ??= null;
      }
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if ("scheduled_start_time" in data) {
        this.scheduledStartTimestamp = Date.parse(data.scheduled_start_time);
      } else {
        this.scheduledStartTimestamp ??= null;
      }
      if ("scheduled_end_time" in data) {
        this.scheduledEndTimestamp = data.scheduled_end_time ? Date.parse(data.scheduled_end_time) : null;
      } else {
        this.scheduledEndTimestamp ??= null;
      }
      if ("privacy_level" in data) {
        this.privacyLevel = data.privacy_level;
      } else {
        this.privacyLevel ??= null;
      }
      if ("status" in data) {
        this.status = data.status;
      } else {
        this.status ??= null;
      }
      if ("entity_type" in data) {
        this.entityType = data.entity_type;
      } else {
        this.entityType ??= null;
      }
      if ("entity_id" in data) {
        this.entityId = data.entity_id;
      } else {
        this.entityId ??= null;
      }
      if ("user_count" in data) {
        this.userCount = data.user_count;
      } else {
        this.userCount ??= null;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      } else {
        this.creator ??= this.client.users.resolve(this.creatorId);
      }
      if ("entity_metadata" in data) {
        if (data.entity_metadata) {
          this.entityMetadata = {
            location: data.entity_metadata.location ?? this.entityMetadata?.location ?? null
          };
        } else {
          this.entityMetadata = null;
        }
      } else {
        this.entityMetadata ??= null;
      }
      if ("image" in data) {
        this.image = data.image;
      } else {
        this.image ??= null;
      }
      if ("recurrence_rule" in data) {
        this.recurrenceRule = data.recurrence_rule && {
          startTimestamp: Date.parse(data.recurrence_rule.start),
          get startAt() {
            return new Date(this.startTimestamp);
          },
          endTimestamp: data.recurrence_rule.end && Date.parse(data.recurrence_rule.end),
          get endAt() {
            return this.endTimestamp && new Date(this.endTimestamp);
          },
          frequency: data.recurrence_rule.frequency,
          interval: data.recurrence_rule.interval,
          byWeekday: data.recurrence_rule.by_weekday,
          byNWeekday: data.recurrence_rule.by_n_weekday,
          byMonth: data.recurrence_rule.by_month,
          byMonthDay: data.recurrence_rule.by_month_day,
          byYearDay: data.recurrence_rule.by_year_day,
          count: data.recurrence_rule.count
        };
      } else {
        this.recurrenceRule ??= null;
      }
    }
    get partial() {
      return this.name === null;
    }
    coverImageURL(options = {}) {
      return this.image && this.client.rest.cdn.guildScheduledEventCover(this.id, this.image, options);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get scheduledStartAt() {
      return this.scheduledStartTimestamp && new Date(this.scheduledStartTimestamp);
    }
    get scheduledEndAt() {
      return this.scheduledEndTimestamp && new Date(this.scheduledEndTimestamp);
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.scheduledEvent}/${this.guildId}/${this.id}`;
    }
    async createInviteURL(options) {
      let channelId = this.channelId;
      if (this.entityType === GuildScheduledEventEntityType.External) {
        if (!options?.channel)
          throw new DiscordjsError(ErrorCodes.InviteOptionsMissingChannel);
        channelId = this.guild.channels.resolveId(options.channel);
        if (!channelId)
          throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      }
      const invite = await this.guild.invites.create(channelId, options);
      return `${RouteBases.invite}/${invite.code}?event=${this.id}`;
    }
    edit(options) {
      return this.guild.scheduledEvents.edit(this.id, options);
    }
    fetch(force = true) {
      return this.guild.scheduledEvents.fetch({ guildScheduledEvent: this.id, force });
    }
    async delete() {
      await this.guild.scheduledEvents.delete(this.id);
      return this;
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setScheduledStartTime(scheduledStartTime, reason) {
      return this.edit({ scheduledStartTime, reason });
    }
    setScheduledEndTime(scheduledEndTime, reason) {
      return this.edit({ scheduledEndTime, reason });
    }
    setDescription(description, reason) {
      return this.edit({ description, reason });
    }
    setStatus(status, reason) {
      return this.edit({ status, reason });
    }
    setLocation(location, reason) {
      return this.edit({ entityMetadata: { location }, reason });
    }
    fetchSubscribers(options) {
      return this.guild.scheduledEvents.fetchSubscribers(this.id, options);
    }
    toString() {
      return this.url;
    }
    isActive() {
      return this.status === GuildScheduledEventStatus.Active;
    }
    isCanceled() {
      return this.status === GuildScheduledEventStatus.Canceled;
    }
    isCompleted() {
      return this.status === GuildScheduledEventStatus.Completed;
    }
    isScheduled() {
      return this.status === GuildScheduledEventStatus.Scheduled;
    }
  }
  exports.GuildScheduledEvent = GuildScheduledEvent;
});

// ../../node_modules/discord.js/src/structures/interfaces/Application.js
var require_Application = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();

  class Application extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
      if ("terms_of_service_url" in data) {
        this.termsOfServiceURL = data.terms_of_service_url;
      } else {
        this.termsOfServiceURL ??= null;
      }
      if ("privacy_policy_url" in data) {
        this.privacyPolicyURL = data.privacy_policy_url;
      } else {
        this.privacyPolicyURL ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("verify_key" in data) {
        this.verifyKey = data.verify_key;
      } else {
        this.verifyKey ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.appIcon(this.id, this.icon, options);
    }
    coverURL(options = {}) {
      return this.cover && this.client.rest.cdn.appIcon(this.id, this.cover, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Application;
});

// ../../node_modules/discord.js/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS((exports, module) => {
  var Application = require_Application();

  class IntegrationApplication extends Application {
    _patch(data) {
      super._patch(data);
      if ("bot" in data) {
        this.bot = this.client.users._add(data.bot);
      } else {
        this.bot ??= null;
      }
      if ("terms_of_service_url" in data) {
        this.termsOfServiceURL = data.terms_of_service_url;
      } else {
        this.termsOfServiceURL ??= null;
      }
      if ("privacy_policy_url" in data) {
        this.privacyPolicyURL = data.privacy_policy_url;
      } else {
        this.privacyPolicyURL ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("hook" in data) {
        this.hook = data.hook;
      } else {
        this.hook ??= null;
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("verify_key" in data) {
        this.verifyKey = data.verify_key;
      } else {
        this.verifyKey ??= null;
      }
    }
  }
  module.exports = IntegrationApplication;
});

// ../../node_modules/discord.js/src/structures/InviteStageInstance.js
var require_InviteStageInstance = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Base = require_Base();

  class InviteStageInstance extends Base {
    constructor(client, data, channelId, guildId) {
      super(client);
      this.channelId = channelId;
      this.guildId = guildId;
      this.members = new Collection;
      this._patch(data);
    }
    _patch(data) {
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("participant_count" in data) {
        this.participantCount = data.participant_count;
      }
      if ("speaker_count" in data) {
        this.speakerCount = data.speaker_count;
      }
      this.members.clear();
      for (const rawMember of data.members) {
        const member = this.guild.members._add(rawMember);
        this.members.set(member.id, member);
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
  }
  module.exports = InviteStageInstance;
});

// ../../node_modules/discord.js/src/structures/BaseGuild.js
var require_BaseGuild = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var { Routes, GuildFeature } = require_v106();
  var Base = require_Base();

  class BaseGuild extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.name = data.name;
      this.icon = data.icon;
      this.features = data.features;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get nameAcronym() {
      return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
    }
    get partnered() {
      return this.features.includes(GuildFeature.Partnered);
    }
    get verified() {
      return this.features.includes(GuildFeature.Verified);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guild(this.id), {
        query: makeURLSearchParams({ with_counts: true })
      });
      return this.client.guilds._add(data);
    }
    toString() {
      return this.name;
    }
  }
  module.exports = BaseGuild;
});

// ../../node_modules/discord.js/src/structures/AnonymousGuild.js
var require_AnonymousGuild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();

  class AnonymousGuild extends BaseGuild {
    constructor(client, data, immediatePatch = true) {
      super(client, data);
      if (immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("features" in data)
        this.features = data.features;
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("verification_level" in data) {
        this.verificationLevel = data.verification_level;
      }
      if ("vanity_url_code" in data) {
        this.vanityURLCode = data.vanity_url_code;
      }
      if ("nsfw_level" in data) {
        this.nsfwLevel = data.nsfw_level;
      }
      if ("premium_subscription_count" in data) {
        this.premiumSubscriptionCount = data.premium_subscription_count;
      } else {
        this.premiumSubscriptionCount ??= null;
      }
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
  }
  module.exports = AnonymousGuild;
});

// ../../node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS((exports) => {
  var process2 = __require("process");
  var { formatEmoji } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var deprecationEmittedForURL = false;

  class Emoji extends Base {
    constructor(client, emoji) {
      super(client);
      this.animated = emoji.animated ?? null;
      this.name = emoji.name ?? null;
      this.id = emoji.id ?? null;
    }
    get identifier() {
      if (this.id)
        return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
      return encodeURIComponent(this.name);
    }
    imageURL(options) {
      return this.id && this.client.rest.cdn.emoji(this.id, options);
    }
    get url() {
      if (!deprecationEmittedForURL) {
        process2.emitWarning("The Emoji#url getter is deprecated. Use Emoji#imageURL() instead.", "DeprecationWarning");
        deprecationEmittedForURL = true;
      }
      return this.imageURL({ extension: this.animated ? "gif" : "png" });
    }
    get createdTimestamp() {
      return this.id && DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return this.id && new Date(this.createdTimestamp);
    }
    toString() {
      return this.id ? formatEmoji({ animated: this.animated, id: this.id, name: this.name }) : this.name;
    }
    toJSON() {
      const json = super.toJSON({
        guild: "guildId",
        createdTimestamp: true,
        identifier: true
      });
      json.imageURL = this.imageURL();
      return json;
    }
  }
  exports.Emoji = Emoji;
});

// ../../node_modules/discord.js/src/structures/WelcomeChannel.js
var require_WelcomeChannel = __commonJS((exports, module) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class WelcomeChannel extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description;
      this._emoji = {
        name: data.emoji_name,
        id: data.emoji_id
      };
      this.channelId = data.channel_id;
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get emoji() {
      return this.client.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
  }
  module.exports = WelcomeChannel;
});

// ../../node_modules/discord.js/src/structures/WelcomeScreen.js
var require_WelcomeScreen = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { GuildFeature } = require_v106();
  var Base = require_Base();
  var WelcomeChannel = require_WelcomeChannel();

  class WelcomeScreen extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description ?? null;
      this.welcomeChannels = new Collection;
      for (const channel of data.welcome_channels) {
        const welcomeChannel = new WelcomeChannel(this.guild, channel);
        this.welcomeChannels.set(welcomeChannel.channelId, welcomeChannel);
      }
    }
    get enabled() {
      return this.guild.features.includes(GuildFeature.WelcomeScreenEnabled);
    }
  }
  module.exports = WelcomeScreen;
});

// ../../node_modules/discord.js/src/structures/InviteGuild.js
var require_InviteGuild = __commonJS((exports, module) => {
  var AnonymousGuild = require_AnonymousGuild();
  var WelcomeScreen = require_WelcomeScreen();

  class InviteGuild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data);
      this.welcomeScreen = data.welcome_screen !== undefined ? new WelcomeScreen(this, data.welcome_screen) : null;
    }
  }
  module.exports = InviteGuild;
});

// ../../node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS((exports, module) => {
  var { RouteBases, Routes, PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var IntegrationApplication = require_IntegrationApplication();
  var InviteStageInstance = require_InviteStageInstance();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class Invite extends Base {
    static InvitesPattern = /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this.type = data.type;
      this._patch(data);
    }
    _patch(data) {
      const InviteGuild = require_InviteGuild();
      this.guild ??= null;
      if (data.guild) {
        this.guild = this.client.guilds.cache.get(data.guild.id) ?? new InviteGuild(this.client, data.guild);
      }
      if ("code" in data) {
        this.code = data.code;
      }
      if ("approximate_presence_count" in data) {
        this.presenceCount = data.approximate_presence_count;
      } else {
        this.presenceCount ??= null;
      }
      if ("approximate_member_count" in data) {
        this.memberCount = data.approximate_member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("temporary" in data) {
        this.temporary = data.temporary ?? null;
      } else {
        this.temporary ??= null;
      }
      if ("max_age" in data) {
        this.maxAge = data.max_age;
      } else {
        this.maxAge ??= null;
      }
      if ("uses" in data) {
        this.uses = data.uses;
      } else {
        this.uses ??= null;
      }
      if ("max_uses" in data) {
        this.maxUses = data.max_uses;
      } else {
        this.maxUses ??= null;
      }
      if ("inviter_id" in data) {
        this.inviterId = data.inviter_id;
      } else {
        this.inviterId ??= null;
      }
      if ("inviter" in data) {
        this.client.users._add(data.inviter);
        this.inviterId = data.inviter.id;
      }
      if ("target_user" in data) {
        this.targetUser = this.client.users._add(data.target_user);
      } else {
        this.targetUser ??= null;
      }
      if ("target_application" in data) {
        this.targetApplication = new IntegrationApplication(this.client, data.target_application);
      } else {
        this.targetApplication ??= null;
      }
      if ("target_type" in data) {
        this.targetType = data.target_type;
      } else {
        this.targetType ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("channel" in data) {
        this.channel = this.client.channels._add(data.channel, this.guild, { cache: false }) ?? this.client.channels.resolve(this.channelId);
        this.channelId ??= data.channel.id;
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      } else {
        this.createdTimestamp ??= null;
      }
      if ("expires_at" in data) {
        this._expiresTimestamp = data.expires_at && Date.parse(data.expires_at);
      } else {
        this._expiresTimestamp ??= null;
      }
      if ("stage_instance" in data) {
        this.stageInstance = new InviteStageInstance(this.client, data.stage_instance, this.channel.id, this.guild.id);
      } else {
        this.stageInstance ??= null;
      }
      if ("guild_scheduled_event" in data) {
        this.guildScheduledEvent = new GuildScheduledEvent(this.client, data.guild_scheduled_event);
      } else {
        this.guildScheduledEvent ??= null;
      }
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get deletable() {
      const guild = this.guild;
      if (!guild || !this.client.guilds.cache.has(guild.id))
        return false;
      if (!guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return Boolean(this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageChannels, false) || guild.members.me.permissions.has(PermissionFlagsBits.ManageGuild));
    }
    get expiresTimestamp() {
      return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1000 : null);
    }
    get expiresAt() {
      return this.expiresTimestamp && new Date(this.expiresTimestamp);
    }
    get inviter() {
      return this.inviterId && this.client.users.resolve(this.inviterId);
    }
    get url() {
      return `${RouteBases.invite}/${this.code}`;
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.invite(this.code), { reason });
      return this;
    }
    toString() {
      return this.url;
    }
    toJSON() {
      return super.toJSON({
        url: true,
        expiresTimestamp: true,
        presenceCount: false,
        memberCount: false,
        uses: false,
        channel: "channelId",
        inviter: "inviterId",
        guild: "guildId"
      });
    }
    valueOf() {
      return this.code;
    }
  }
  module.exports = Invite;
});

// ../../node_modules/discord.js/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("timers");
  var { RouteBases, Routes } = require_v106();
  var Base = require_Base();
  var { resolveImage } = require_DataResolver();
  var Events = require_Events();

  class GuildTemplate extends Base {
    static GuildTemplatesPattern = /discord(?:app)?\.(?:com\/template|new)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      if ("code" in data) {
        this.code = data.code;
      }
      if ("name" in data) {
        this.name = data.name;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("usage_count" in data) {
        this.usageCount = data.usage_count;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      }
      if ("updated_at" in data) {
        this.updatedTimestamp = Date.parse(data.updated_at);
      }
      if ("source_guild_id" in data) {
        this.guildId = data.source_guild_id;
      }
      if ("serialized_source_guild" in data) {
        this.serializedGuild = data.serialized_source_guild;
      }
      this.unSynced = "is_dirty" in data ? Boolean(data.is_dirty) : null;
      return this;
    }
    async createGuild(name, icon) {
      const { client } = this;
      const data = await client.rest.post(Routes.template(this.code), {
        body: {
          name,
          icon: await resolveImage(icon)
        }
      });
      if (client.guilds.cache.has(data.id))
        return client.guilds.cache.get(data.id);
      return new Promise((resolve) => {
        const resolveGuild = (guild) => {
          client.off(Events.GuildCreate, handleGuild);
          client.decrementMaxListeners();
          resolve(guild);
        };
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            resolveGuild(guild);
          }
        };
        client.incrementMaxListeners();
        client.on(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => resolveGuild(client.guilds._add(data)), 1e4).unref();
      });
    }
    async edit({ name, description } = {}) {
      const data = await this.client.rest.patch(Routes.guildTemplate(this.guildId, this.code), {
        body: { name, description }
      });
      return this._patch(data);
    }
    async delete() {
      await this.client.rest.delete(Routes.guildTemplate(this.guildId, this.code));
      return this;
    }
    async sync() {
      const data = await this.client.rest.put(Routes.guildTemplate(this.guildId, this.code));
      return this._patch(data);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get updatedAt() {
      return new Date(this.updatedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.template}/${this.code}`;
    }
    toString() {
      return this.code;
    }
  }
  module.exports = GuildTemplate;
});

// ../../node_modules/discord.js/src/util/DataResolver.js
var require_DataResolver = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("buffer");
  var fs = __require("fs/promises");
  var path = __require("path");
  var { fetch: fetch2 } = __require("undici");
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var Invite = require_Invite();
  function resolveCode(data, regex) {
    return regex.exec(data)?.[1] ?? data;
  }
  function resolveInviteCode(data) {
    return resolveCode(data, Invite.InvitesPattern);
  }
  function resolveGuildTemplateCode(data) {
    const GuildTemplate = require_GuildTemplate();
    return resolveCode(data, GuildTemplate.GuildTemplatesPattern);
  }
  async function resolveFile(resource) {
    if (Buffer2.isBuffer(resource))
      return { data: resource };
    if (typeof resource[Symbol.asyncIterator] === "function") {
      const buffers = [];
      for await (const data of resource)
        buffers.push(Buffer2.from(data));
      return { data: Buffer2.concat(buffers) };
    }
    if (typeof resource === "string") {
      if (/^https?:\/\//.test(resource)) {
        const res = await fetch2(resource);
        return { data: Buffer2.from(await res.arrayBuffer()), contentType: res.headers.get("content-type") };
      }
      const file = path.resolve(resource);
      const stats = await fs.stat(file);
      if (!stats.isFile())
        throw new DiscordjsError(ErrorCodes.FileNotFound, file);
      return { data: await fs.readFile(file) };
    }
    throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
  }
  function resolveBase64(data, contentType = "image/jpg") {
    if (Buffer2.isBuffer(data))
      return `data:${contentType};base64,${data.toString("base64")}`;
    return data;
  }
  async function resolveImage(image) {
    if (!image)
      return null;
    if (typeof image === "string" && image.startsWith("data:")) {
      return image;
    }
    const file = await resolveFile(image);
    return resolveBase64(file.data);
  }
  module.exports = { resolveCode, resolveInviteCode, resolveGuildTemplateCode, resolveImage, resolveBase64, resolveFile };
});

// ../../node_modules/discord.js/src/util/MessageFlagsBitField.js
var require_MessageFlagsBitField = __commonJS((exports, module) => {
  var { MessageFlags } = require_v106();
  var BitField = require_BitField();

  class MessageFlagsBitField extends BitField {
    static Flags = MessageFlags;
  }
  module.exports = MessageFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/BaseInteraction.js
var require_BaseInteraction = __commonJS((exports, module) => {
  var { deprecate } = __require("util");
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var { InteractionType, ApplicationCommandType, ComponentType } = require_v106();
  var Base = require_Base();
  var { SelectMenuTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();

  class BaseInteraction extends Base {
    constructor(client, data) {
      super(client);
      this.type = data.type;
      this.id = data.id;
      Object.defineProperty(this, "token", { value: data.token });
      this.applicationId = data.application_id;
      this.channelId = data.channel?.id ?? null;
      this.guildId = data.guild_id ?? null;
      this.user = this.client.users._add(data.user ?? data.member.user);
      this.member = data.member ? this.guild?.members._add(data.member) ?? data.member : null;
      this.version = data.version;
      this.appPermissions = new PermissionsBitField(data.app_permissions).freeze();
      this.memberPermissions = data.member?.permissions ? new PermissionsBitField(data.member.permissions).freeze() : null;
      this.locale = data.locale;
      this.guildLocale = data.guild_locale ?? null;
      this.entitlements = data.entitlements.reduce((coll, entitlement) => coll.set(entitlement.id, this.client.application.entitlements._add(entitlement)), new Collection);
      this.authorizingIntegrationOwners = data.authorizing_integration_owners;
      this.context = data.context ?? null;
      this.attachmentSizeLimit = data.attachment_size_limit;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get channel() {
      return this.client.channels.cache.get(this.channelId) ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    inGuild() {
      return Boolean(this.guildId && this.member);
    }
    inCachedGuild() {
      return Boolean(this.guild && this.member);
    }
    inRawGuild() {
      return Boolean(this.guildId && !this.guild && this.member);
    }
    isAutocomplete() {
      return this.type === InteractionType.ApplicationCommandAutocomplete;
    }
    isCommand() {
      return this.type === InteractionType.ApplicationCommand;
    }
    isChatInputCommand() {
      return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.ChatInput;
    }
    isContextMenuCommand() {
      return this.type === InteractionType.ApplicationCommand && [ApplicationCommandType.User, ApplicationCommandType.Message].includes(this.commandType);
    }
    isPrimaryEntryPointCommand() {
      return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.PrimaryEntryPoint;
    }
    isMessageComponent() {
      return this.type === InteractionType.MessageComponent;
    }
    isModalSubmit() {
      return this.type === InteractionType.ModalSubmit;
    }
    isUserContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.User;
    }
    isMessageContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.Message;
    }
    isButton() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.Button;
    }
    isSelectMenu() {
      return this.isStringSelectMenu();
    }
    isAnySelectMenu() {
      return this.type === InteractionType.MessageComponent && SelectMenuTypes.includes(this.componentType);
    }
    isStringSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.StringSelect;
    }
    isUserSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.UserSelect;
    }
    isRoleSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.RoleSelect;
    }
    isChannelSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.ChannelSelect;
    }
    isMentionableSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.MentionableSelect;
    }
    isRepliable() {
      return ![InteractionType.Ping, InteractionType.ApplicationCommandAutocomplete].includes(this.type);
    }
  }
  BaseInteraction.prototype.isSelectMenu = deprecate(BaseInteraction.prototype.isSelectMenu, "BaseInteraction#isSelectMenu() is deprecated. Use BaseInteraction#isStringSelectMenu() instead.");
  module.exports = BaseInteraction;
});

// ../../node_modules/discord.js/src/structures/ApplicationRoleConnectionMetadata.js
var require_ApplicationRoleConnectionMetadata = __commonJS((exports) => {
  class ApplicationRoleConnectionMetadata {
    constructor(data) {
      this.name = data.name;
      this.nameLocalizations = data.name_localizations ?? null;
      this.description = data.description;
      this.descriptionLocalizations = data.description_localizations ?? null;
      this.key = data.key;
      this.type = data.type;
    }
  }
  exports.ApplicationRoleConnectionMetadata = ApplicationRoleConnectionMetadata;
});

// ../../node_modules/discord.js/src/structures/TeamMember.js
var require_TeamMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class TeamMember extends Base {
    constructor(team, data) {
      super(team.client);
      this.team = team;
      this._patch(data);
    }
    _patch(data) {
      if ("permissions" in data) {
        this.permissions = data.permissions;
      }
      if ("membership_state" in data) {
        this.membershipState = data.membership_state;
      }
      if ("user" in data) {
        this.user = this.client.users._add(data.user);
      }
      if ("role" in data) {
        this.role = data.role;
      }
    }
    get id() {
      return this.user.id;
    }
    toString() {
      return this.user.toString();
    }
  }
  module.exports = TeamMember;
});

// ../../node_modules/discord.js/src/structures/Team.js
var require_Team = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var TeamMember = require_TeamMember();

  class Team extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
      if ("owner_user_id" in data) {
        this.ownerId = data.owner_user_id;
      } else {
        this.ownerId ??= null;
      }
      this.members = new Collection;
      for (const memberData of data.members) {
        const member = new TeamMember(this, memberData);
        this.members.set(member.id, member);
      }
    }
    get owner() {
      return this.members.get(this.ownerId) ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.teamIcon(this.id, this.icon, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Team;
});

// ../../node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js
var require_ApplicationCommandPermissionsManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes } = require_v106();
  var BaseManager = require_BaseManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();

  class ApplicationCommandPermissionsManager extends BaseManager {
    constructor(manager) {
      super(manager.client);
      this.manager = manager;
      this.guild = manager.guild ?? null;
      this.guildId = manager.guildId ?? manager.guild?.id ?? null;
      this.commandId = manager.id ?? null;
    }
    permissionsPath(guildId, commandId) {
      if (commandId) {
        return Routes.applicationCommandPermissions(this.client.application.id, guildId, commandId);
      }
      return Routes.guildApplicationCommandsPermissions(this.client.application.id, guildId);
    }
    async fetch({ guild, command } = {}) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (commandId) {
        const data2 = await this.client.rest.get(this.permissionsPath(guildId, commandId));
        return data2.permissions;
      }
      const data = await this.client.rest.get(this.permissionsPath(guildId));
      return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection);
    }
    async set({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      if (!commandId) {
        commandId = this.client.user.id;
      }
      const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {
        body: { permissions },
        auth: false,
        headers: { Authorization: `Bearer ${token}` }
      });
      return data.permissions;
    }
    async add({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      let existingPermissions = [];
      try {
        existingPermissions = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const newPermissions = permissions.slice();
      for (const existingPermission of existingPermissions) {
        if (!newPermissions.some((newPermission) => newPermission.id === existingPermission.id)) {
          newPermissions.push(existingPermission);
        }
      }
      return this.set({ guild: guildId, command: commandId, permissions: newPermissions, token });
    }
    async remove({ guild, command, users, roles, channels, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!users && !roles && !channels) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "users OR roles OR channels", "Array or Resolvable", true);
      }
      let resolvedUserIds = [];
      if (Array.isArray(users)) {
        for (const user of users) {
          const userId = this.client.users.resolveId(user);
          if (!userId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", user);
          resolvedUserIds.push(userId);
        }
      }
      let resolvedRoleIds = [];
      if (Array.isArray(roles)) {
        for (const role of roles) {
          if (typeof role === "string") {
            resolvedRoleIds.push(role);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          const roleId = this.guild.roles.resolveId(role);
          if (!roleId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", role);
          resolvedRoleIds.push(roleId);
        }
      }
      let resolvedChannelIds = [];
      if (Array.isArray(channels)) {
        for (const channel of channels) {
          if (typeof channel === "string") {
            resolvedChannelIds.push(channel);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "channels");
          const channelId = this.guild.channels.resolveId(channel);
          if (!channelId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "channels", channel);
          resolvedChannelIds.push(channelId);
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const permissions = existing.filter((perm) => {
        switch (perm.type) {
          case ApplicationCommandPermissionType.Role:
            return !resolvedRoleIds.includes(perm.id);
          case ApplicationCommandPermissionType.User:
            return !resolvedUserIds.includes(perm.id);
          case ApplicationCommandPermissionType.Channel:
            return !resolvedChannelIds.includes(perm.id);
        }
        return true;
      });
      return this.set({ guild: guildId, command: commandId, permissions, token });
    }
    async has({ guild, command, permissionId, permissionType }) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      if (!permissionId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
      }
      let resolvedId = permissionId;
      if (typeof permissionId !== "string") {
        resolvedId = this.client.users.resolveId(permissionId);
        if (!resolvedId) {
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          resolvedId = this.guild.roles.resolveId(permissionId);
        }
        if (!resolvedId) {
          resolvedId = this.guild.channels.resolveId(permissionId);
        }
        if (!resolvedId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      return existing.some((perm) => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);
    }
    _validateOptions(guild, command) {
      const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
      if (!guildId)
        throw new DiscordjsError(ErrorCodes.GlobalCommandPermissions);
      let commandId = this.commandId;
      if (command && !commandId) {
        commandId = this.manager.resolveId?.(command);
        if (!commandId && this.guild) {
          commandId = this.guild.commands.resolveId(command);
        }
        commandId ??= this.client.application?.commands.resolveId(command);
        if (!commandId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable", true);
        }
      }
      return { guildId, commandId };
    }
  }
  module.exports = ApplicationCommandPermissionsManager;
});

// ../../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// ../../node_modules/discord.js/src/structures/ApplicationCommand.js
var require_ApplicationCommand = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var { ApplicationCommandOptionType } = require_v106();
  var isEqual = require_fast_deep_equal();
  var Base = require_Base();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommand extends Base {
    constructor(client, data, guild, guildId) {
      super(client);
      this.id = data.id;
      this.applicationId = data.application_id;
      this.guild = guild ?? null;
      this.guildId = guild?.id ?? guildId ?? null;
      this.permissions = new ApplicationCommandPermissionsManager(this);
      this.type = data.type;
      this.nsfw = data.nsfw ?? false;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("name_localizations" in data) {
        this.nameLocalizations = data.name_localizations;
      } else {
        this.nameLocalizations ??= null;
      }
      if ("name_localized" in data) {
        this.nameLocalized = data.name_localized;
      } else {
        this.nameLocalized ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("description_localizations" in data) {
        this.descriptionLocalizations = data.description_localizations;
      } else {
        this.descriptionLocalizations ??= null;
      }
      if ("description_localized" in data) {
        this.descriptionLocalized = data.description_localized;
      } else {
        this.descriptionLocalized ??= null;
      }
      if ("options" in data) {
        this.options = data.options.map((option) => this.constructor.transformOption(option, true));
      } else {
        this.options ??= [];
      }
      if ("default_member_permissions" in data) {
        this.defaultMemberPermissions = data.default_member_permissions ? new PermissionsBitField(BigInt(data.default_member_permissions)).freeze() : null;
      } else {
        this.defaultMemberPermissions ??= null;
      }
      if ("dm_permission" in data) {
        this.dmPermission = data.dm_permission;
      } else {
        this.dmPermission ??= null;
      }
      if ("integration_types" in data) {
        this.integrationTypes = data.integration_types;
      } else {
        this.integrationTypes ??= null;
      }
      if ("contexts" in data) {
        this.contexts = data.contexts;
      } else {
        this.contexts ??= null;
      }
      if ("handler" in data) {
        this.handler = data.handler;
      } else {
        this.handler ??= null;
      }
      if ("version" in data) {
        this.version = data.version;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get manager() {
      return (this.guild ?? this.client.application).commands;
    }
    edit(data) {
      return this.manager.edit(this, data, this.guildId);
    }
    setName(name) {
      return this.edit({ name });
    }
    setNameLocalizations(nameLocalizations) {
      return this.edit({ nameLocalizations });
    }
    setDescription(description) {
      return this.edit({ description });
    }
    setDescriptionLocalizations(descriptionLocalizations) {
      return this.edit({ descriptionLocalizations });
    }
    setDefaultMemberPermissions(defaultMemberPermissions) {
      return this.edit({ defaultMemberPermissions });
    }
    setDMPermission(dmPermission = true) {
      return this.edit({ dmPermission });
    }
    setOptions(options) {
      return this.edit({ options });
    }
    delete() {
      return this.manager.delete(this, this.guildId);
    }
    equals(command, enforceOptionOrder = false) {
      if (command.id && this.id !== command.id)
        return false;
      let defaultMemberPermissions = null;
      let dmPermission = command.dmPermission ?? command.dm_permission;
      if ("default_member_permissions" in command) {
        defaultMemberPermissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield : null;
      }
      if ("defaultMemberPermissions" in command) {
        defaultMemberPermissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield : null;
      }
      if (command.name !== this.name || "description" in command && command.description !== this.description || "version" in command && command.version !== this.version || command.type && command.type !== this.type || "nsfw" in command && command.nsfw !== this.nsfw || (command.options?.length ?? 0) !== (this.options?.length ?? 0) || defaultMemberPermissions !== (this.defaultMemberPermissions?.bitfield ?? null) || dmPermission !== undefined && dmPermission !== this.dmPermission || !isEqual(command.nameLocalizations ?? command.name_localizations ?? {}, this.nameLocalizations ?? {}) || !isEqual(command.descriptionLocalizations ?? command.description_localizations ?? {}, this.descriptionLocalizations ?? {}) || !isEqual(command.integrationTypes ?? command.integration_types ?? [], this.integrationTypes ?? []) || !isEqual(command.contexts ?? [], this.contexts ?? []) || "handler" in command && command.handler !== this.handler) {
        return false;
      }
      if (command.options) {
        return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);
      }
      return true;
    }
    static optionsEqual(existing, options, enforceOptionOrder = false) {
      if (existing.length !== options.length)
        return false;
      if (enforceOptionOrder) {
        return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));
      }
      const newOptions = new Map(options.map((option) => [option.name, option]));
      for (const option of existing) {
        const foundOption = newOptions.get(option.name);
        if (!foundOption || !this._optionEquals(option, foundOption))
          return false;
      }
      return true;
    }
    static _optionEquals(existing, option, enforceOptionOrder = false) {
      if (option.name !== existing.name || option.type !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? ([ApplicationCommandOptionType.Subcommand, ApplicationCommandOptionType.SubcommandGroup].includes(option.type) ? undefined : false)) !== existing.required || option.choices?.length !== existing.choices?.length || option.options?.length !== existing.options?.length || (option.channelTypes ?? option.channel_types)?.length !== existing.channelTypes?.length || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue || (option.minLength ?? option.min_length) !== existing.minLength || (option.maxLength ?? option.max_length) !== existing.maxLength || !isEqual(option.nameLocalizations ?? option.name_localizations ?? {}, existing.nameLocalizations ?? {}) || !isEqual(option.descriptionLocalizations ?? option.description_localizations ?? {}, existing.descriptionLocalizations ?? {})) {
        return false;
      }
      if (existing.choices) {
        if (enforceOptionOrder && !existing.choices.every((choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value && isEqual(choice.nameLocalizations ?? {}, option.choices[index].nameLocalizations ?? option.choices[index].name_localizations ?? {}))) {
          return false;
        }
        if (!enforceOptionOrder) {
          const newChoices = new Map(option.choices.map((choice) => [choice.name, choice]));
          for (const choice of existing.choices) {
            const foundChoice = newChoices.get(choice.name);
            if (!foundChoice || foundChoice.value !== choice.value)
              return false;
          }
        }
      }
      if (existing.channelTypes) {
        const newTypes = option.channelTypes ?? option.channel_types;
        for (const type of existing.channelTypes) {
          if (!newTypes.includes(type))
            return false;
        }
      }
      if (existing.options) {
        return this.optionsEqual(existing.options, option.options, enforceOptionOrder);
      }
      return true;
    }
    static transformOption(option, received) {
      const channelTypesKey = received ? "channelTypes" : "channel_types";
      const minValueKey = received ? "minValue" : "min_value";
      const maxValueKey = received ? "maxValue" : "max_value";
      const minLengthKey = received ? "minLength" : "min_length";
      const maxLengthKey = received ? "maxLength" : "max_length";
      const nameLocalizationsKey = received ? "nameLocalizations" : "name_localizations";
      const nameLocalizedKey = received ? "nameLocalized" : "name_localized";
      const descriptionLocalizationsKey = received ? "descriptionLocalizations" : "description_localizations";
      const descriptionLocalizedKey = received ? "descriptionLocalized" : "description_localized";
      return {
        type: option.type,
        name: option.name,
        [nameLocalizationsKey]: option.nameLocalizations ?? option.name_localizations,
        [nameLocalizedKey]: option.nameLocalized ?? option.name_localized,
        description: option.description,
        [descriptionLocalizationsKey]: option.descriptionLocalizations ?? option.description_localizations,
        [descriptionLocalizedKey]: option.descriptionLocalized ?? option.description_localized,
        required: option.required ?? (option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup ? undefined : false),
        autocomplete: option.autocomplete,
        choices: option.choices?.map((choice) => ({
          name: choice.name,
          [nameLocalizedKey]: choice.nameLocalized ?? choice.name_localized,
          [nameLocalizationsKey]: choice.nameLocalizations ?? choice.name_localizations,
          value: choice.value
        })),
        options: option.options?.map((opt) => this.transformOption(opt, received)),
        [channelTypesKey]: option.channelTypes ?? option.channel_types,
        [minValueKey]: option.minValue ?? option.min_value,
        [maxValueKey]: option.maxValue ?? option.max_value,
        [minLengthKey]: option.minLength ?? option.min_length,
        [maxLengthKey]: option.maxLength ?? option.max_length
      };
    }
  }
  module.exports = ApplicationCommand;
});

// ../../node_modules/discord.js/src/managers/ApplicationCommandManager.js
var require_ApplicationCommandManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { isJSONEncodable } = require_dist();
  var { Routes } = require_v106();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var ApplicationCommand = require_ApplicationCommand();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommandManager extends CachedManager {
    constructor(client, iterable) {
      super(client, ApplicationCommand, iterable);
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
    _add(data, cache, guildId) {
      return super._add(data, cache, { extras: [this.guild, guildId] });
    }
    commandPath({ id, guildId } = {}) {
      if (this.guild ?? guildId) {
        if (id) {
          return Routes.applicationGuildCommand(this.client.application.id, this.guild?.id ?? guildId, id);
        }
        return Routes.applicationGuildCommands(this.client.application.id, this.guild?.id ?? guildId);
      }
      if (id) {
        return Routes.applicationCommand(this.client.application.id, id);
      }
      return Routes.applicationCommands(this.client.application.id);
    }
    async fetch(id, { guildId, cache = true, force = false, locale, withLocalizations } = {}) {
      if (typeof id === "object") {
        ({ guildId, cache = true, locale, withLocalizations } = id);
      } else if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const command = await this.client.rest.get(this.commandPath({ id, guildId }));
        return this._add(command, cache);
      }
      const data = await this.client.rest.get(this.commandPath({ guildId }), {
        headers: {
          "X-Discord-Locale": locale
        },
        query: makeURLSearchParams({ with_localizations: withLocalizations })
      });
      return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection);
    }
    async create(command, guildId) {
      const data = await this.client.rest.post(this.commandPath({ guildId }), {
        body: this.constructor.transformCommand(command)
      });
      return this._add(data, true, guildId);
    }
    async set(commands, guildId) {
      const data = await this.client.rest.put(this.commandPath({ guildId }), {
        body: commands.map((command) => this.constructor.transformCommand(command))
      });
      return data.reduce((collection, command) => collection.set(command.id, this._add(command, true, guildId)), new Collection);
    }
    async edit(command, data, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      const patched = await this.client.rest.patch(this.commandPath({ id, guildId }), {
        body: this.constructor.transformCommand(data)
      });
      return this._add(patched, true, guildId);
    }
    async delete(command, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      await this.client.rest.delete(this.commandPath({ id, guildId }));
      const cached = this.cache.get(id);
      this.cache.delete(id);
      return cached ?? null;
    }
    static transformCommand(command) {
      if (isJSONEncodable(command))
        return command.toJSON();
      let default_member_permissions;
      if ("default_member_permissions" in command) {
        default_member_permissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield.toString() : command.default_member_permissions;
      }
      if ("defaultMemberPermissions" in command) {
        default_member_permissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield.toString() : command.defaultMemberPermissions;
      }
      return {
        name: command.name,
        name_localizations: command.nameLocalizations ?? command.name_localizations,
        description: command.description,
        nsfw: command.nsfw,
        description_localizations: command.descriptionLocalizations ?? command.description_localizations,
        type: command.type,
        options: command.options?.map((option) => ApplicationCommand.transformOption(option)),
        default_member_permissions,
        dm_permission: command.dmPermission ?? command.dm_permission,
        integration_types: command.integrationTypes ?? command.integration_types,
        contexts: command.contexts,
        handler: command.handler
      };
    }
  }
  module.exports = ApplicationCommandManager;
});

// ../../node_modules/discord.js/src/structures/ApplicationEmoji.js
var require_ApplicationEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class ApplicationEmoji extends Emoji {
    constructor(client, data, application) {
      super(client, data);
      this.application = application;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data)
        this.name = data.name;
      if (data.user) {
        this.author = this.client.users._add(data.user);
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("require_colons" in data) {
        this.requiresColons = data.require_colons;
      }
      if ("available" in data) {
        this.available = data.available;
      }
    }
    fetchAuthor() {
      return this.application.emojis.fetchAuthor(this);
    }
    edit(options) {
      return this.application.emojis.edit(this.id, options);
    }
    setName(name) {
      return this.edit({ name });
    }
    async delete() {
      await this.application.emojis.delete(this.id);
      return this;
    }
    equals(other) {
      if (other instanceof ApplicationEmoji) {
        return other.animated === this.animated && other.id === this.id && other.name === this.name && other.managed === this.managed && other.requiresColons === this.requiresColons && other.available === this.available;
      }
      return other.id === this.id && other.name === this.name;
    }
  }
  module.exports = ApplicationEmoji;
});

// ../../node_modules/discord.js/src/managers/ApplicationEmojiManager.js
var require_ApplicationEmojiManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var ApplicationEmoji = require_ApplicationEmoji();
  var { resolveImage } = require_DataResolver();

  class ApplicationEmojiManager extends CachedManager {
    constructor(application, iterable) {
      super(application.client, ApplicationEmoji, iterable);
      this.application = application;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.application] });
    }
    async create({ attachment, name }) {
      attachment = await resolveImage(attachment);
      if (!attachment)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      const body = { image: attachment, name };
      const emoji = await this.client.rest.post(Routes.applicationEmojis(this.application.id), { body });
      return this._add(emoji);
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const emoji = await this.client.rest.get(Routes.applicationEmoji(this.application.id, id));
        return this._add(emoji, cache);
      }
      const { items: data } = await this.client.rest.get(Routes.applicationEmojis(this.application.id));
      const emojis = new Collection;
      for (const emoji of data)
        emojis.set(emoji.id, this._add(emoji, cache));
      return emojis;
    }
    async delete(emoji) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      await this.client.rest.delete(Routes.applicationEmoji(this.application.id, id));
    }
    async edit(emoji, options) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const newData = await this.client.rest.patch(Routes.applicationEmoji(this.application.id, id), {
        body: {
          name: options.name
        }
      });
      const existing = this.cache.get(id);
      if (existing) {
        existing._patch(newData);
        return existing;
      }
      return this._add(newData);
    }
    async fetchAuthor(emoji) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const data = await this.client.rest.get(Routes.applicationEmoji(this.application.id, id));
      return this._add(data).author;
    }
  }
  module.exports = ApplicationEmojiManager;
});

// ../../node_modules/discord.js/src/structures/Entitlement.js
var require_Entitlement = __commonJS((exports) => {
  var Base = require_Base();

  class Entitlement extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this._patch(data);
    }
    _patch(data) {
      if ("sku_id" in data) {
        this.skuId = data.sku_id;
      }
      if ("user_id" in data) {
        this.userId = data.user_id;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      }
      if ("type" in data) {
        this.type = data.type;
      }
      if ("deleted" in data) {
        this.deleted = data.deleted;
      }
      if ("starts_at" in data) {
        this.startsTimestamp = data.starts_at ? Date.parse(data.starts_at) : null;
      } else {
        this.startsTimestamp ??= null;
      }
      if ("ends_at" in data) {
        this.endsTimestamp = data.ends_at ? Date.parse(data.ends_at) : null;
      } else {
        this.endsTimestamp ??= null;
      }
      if ("consumed" in data) {
        this.consumed = data.consumed;
      } else {
        this.consumed ??= false;
      }
    }
    get guild() {
      if (!this.guildId)
        return null;
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    get startsAt() {
      return this.startsTimestamp && new Date(this.startsTimestamp);
    }
    get endsAt() {
      return this.endsTimestamp && new Date(this.endsTimestamp);
    }
    isActive() {
      return !this.deleted && (!this.endsTimestamp || this.endsTimestamp > Date.now());
    }
    isTest() {
      return this.startsTimestamp === null;
    }
    isUserSubscription() {
      return this.guildId === null;
    }
    isGuildSubscription() {
      return this.guildId !== null;
    }
    fetchUser() {
      return this.client.users.fetch(this.userId);
    }
    async consume() {
      await this.client.application.entitlements.consume(this.id);
    }
  }
  exports.Entitlement = Entitlement;
});

// ../../node_modules/discord.js/src/managers/EntitlementManager.js
var require_EntitlementManager = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes, EntitlementOwnerType } = require_v106();
  var CachedManager = require_CachedManager();
  var { ErrorCodes, DiscordjsTypeError } = require_errors();
  var { Entitlement } = require_Entitlement();
  var { resolveSKUId } = require_Util();

  class EntitlementManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Entitlement, iterable);
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany(options);
      const { entitlement, cache, force } = options;
      const resolvedEntitlement = this.resolveId(entitlement ?? options);
      if (resolvedEntitlement) {
        return this._fetchSingle({ entitlement: resolvedEntitlement, cache, force });
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ entitlement, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(entitlement);
        if (existing) {
          return existing;
        }
      }
      const data = await this.client.rest.get(Routes.entitlement(this.client.application.id, entitlement));
      return this._add(data, cache);
    }
    async _fetchMany({ limit, guild, user, skus, excludeEnded, excludeDeleted, cache, before, after } = {}) {
      const query = makeURLSearchParams({
        limit,
        guild_id: guild && this.client.guilds.resolveId(guild),
        user_id: user && this.client.users.resolveId(user),
        sku_ids: skus?.map((sku) => resolveSKUId(sku)).join(","),
        exclude_ended: excludeEnded,
        exclude_deleted: excludeDeleted,
        before,
        after
      });
      const entitlements = await this.client.rest.get(Routes.entitlements(this.client.application.id), { query });
      return entitlements.reduce((coll, entitlement) => coll.set(entitlement.id, this._add(entitlement, cache)), new Collection);
    }
    async createTest({ sku, guild, user }) {
      const skuId = resolveSKUId(sku);
      if (!skuId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sku", "SKUResolvable");
      if (guild && user || !guild && !user) {
        throw new DiscordjsTypeError(ErrorCodes.EntitlementCreateInvalidOwner);
      }
      const resolved = guild ? this.client.guilds.resolveId(guild) : this.client.users.resolveId(user);
      if (!resolved) {
        const name = guild ? "guild" : "user";
        const type = guild ? "GuildResolvable" : "UserResolvable";
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, name, type);
      }
      const entitlement = await this.client.rest.post(Routes.entitlements(this.client.application.id), {
        body: {
          sku_id: skuId,
          owner_id: resolved,
          owner_type: guild ? EntitlementOwnerType.Guild : EntitlementOwnerType.User
        }
      });
      return new Entitlement(this.client, entitlement);
    }
    async deleteTest(entitlement) {
      const resolved = this.resolveId(entitlement);
      if (!resolved)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "entitlement", "EntitlementResolvable");
      await this.client.rest.delete(Routes.entitlement(this.client.application.id, resolved));
    }
    async consume(entitlementId) {
      await this.client.rest.post(Routes.consumeEntitlement(this.client.application.id, entitlementId));
    }
  }
  exports.EntitlementManager = EntitlementManager;
});

// ../../node_modules/discord.js/src/structures/Subscription.js
var require_Subscription = __commonJS((exports) => {
  var Base = require_Base();

  class Subscription extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.userId = data.user_id;
      this._patch(data);
    }
    _patch(data) {
      this.skuIds = data.sku_ids;
      this.entitlementIds = data.entitlement_ids;
      this.currentPeriodStartTimestamp = Date.parse(data.current_period_start);
      this.currentPeriodEndTimestamp = Date.parse(data.current_period_end);
      this.status = data.status;
      if ("renewal_sku_ids" in data) {
        this.renewalSkuIds = data.renewal_sku_ids;
      }
      if ("canceled_at" in data) {
        this.canceledTimestamp = data.canceled_at ? Date.parse(data.canceled_at) : null;
      } else {
        this.canceledTimestamp ??= null;
      }
      if ("country" in data) {
        this.country = data.country;
      } else {
        this.country ??= null;
      }
    }
    get canceledAt() {
      return this.canceledTimestamp && new Date(this.canceledTimestamp);
    }
    get currentPeriodStartAt() {
      return new Date(this.currentPeriodStartTimestamp);
    }
    get currentPeriodEndAt() {
      return new Date(this.currentPeriodEndTimestamp);
    }
  }
  exports.Subscription = Subscription;
});

// ../../node_modules/discord.js/src/managers/SubscriptionManager.js
var require_SubscriptionManager = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Subscription } = require_Subscription();
  var { resolveSKUId } = require_Util();

  class SubscriptionManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Subscription, iterable);
    }
    async fetch(options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const { after, before, cache, limit, sku, subscriptionId, user } = options;
      const skuId = resolveSKUId(sku);
      if (!skuId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sku", "SKUResolvable");
      if (subscriptionId) {
        const subscription = await this.client.rest.get(Routes.skuSubscription(skuId, subscriptionId));
        return this._add(subscription, cache);
      }
      const query = makeURLSearchParams({
        limit,
        user_id: this.client.users.resolveId(user) ?? undefined,
        sku_id: skuId,
        before,
        after
      });
      const subscriptions = await this.client.rest.get(Routes.skuSubscriptions(skuId), { query });
      return subscriptions.reduce((coll, subscription) => coll.set(subscription.id, this._add(subscription, cache)), new Collection);
    }
  }
  exports.SubscriptionManager = SubscriptionManager;
});

// ../../node_modules/discord.js/src/util/ApplicationFlagsBitField.js
var require_ApplicationFlagsBitField = __commonJS((exports, module) => {
  var { ApplicationFlags } = require_v106();
  var BitField = require_BitField();

  class ApplicationFlagsBitField extends BitField {
    static Flags = ApplicationFlags;
  }
  module.exports = ApplicationFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/ClientApplication.js
var require_ClientApplication = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var { ApplicationRoleConnectionMetadata } = require_ApplicationRoleConnectionMetadata();
  var { SKU } = require_SKU();
  var Team = require_Team();
  var Application = require_Application();
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationEmojiManager = require_ApplicationEmojiManager();
  var { EntitlementManager } = require_EntitlementManager();
  var { SubscriptionManager } = require_SubscriptionManager();
  var ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  var { resolveImage } = require_DataResolver();
  var PermissionsBitField = require_PermissionsBitField();

  class ClientApplication extends Application {
    constructor(client, data) {
      super(client, data);
      this.commands = new ApplicationCommandManager(this.client);
      this.emojis = new ApplicationEmojiManager(this);
      this.entitlements = new EntitlementManager(this.client);
      this.subscriptions = new SubscriptionManager(this.client);
    }
    _patch(data) {
      super._patch(data);
      this.tags = data.tags ?? [];
      if ("install_params" in data) {
        this.installParams = {
          scopes: data.install_params.scopes,
          permissions: new PermissionsBitField(data.install_params.permissions).freeze()
        };
      } else {
        this.installParams ??= null;
      }
      if ("integration_types_config" in data) {
        this.integrationTypesConfig = Object.fromEntries(Object.entries(data.integration_types_config).map(([key, config]) => {
          let oauth2InstallParams = null;
          if (config.oauth2_install_params) {
            oauth2InstallParams = {
              scopes: config.oauth2_install_params.scopes,
              permissions: new PermissionsBitField(config.oauth2_install_params.permissions).freeze()
            };
          }
          const context = {
            oauth2InstallParams
          };
          return [key, context];
        }));
      } else {
        this.integrationTypesConfig ??= null;
      }
      if ("custom_install_url" in data) {
        this.customInstallURL = data.custom_install_url;
      } else {
        this.customInstallURL = null;
      }
      if ("flags" in data) {
        this.flags = new ApplicationFlagsBitField(data.flags).freeze();
      }
      if ("approximate_guild_count" in data) {
        this.approximateGuildCount = data.approximate_guild_count;
      } else {
        this.approximateGuildCount ??= null;
      }
      if ("approximate_user_install_count" in data) {
        this.approximateUserInstallCount = data.approximate_user_install_count;
      } else {
        this.approximateUserInstallCount ??= null;
      }
      if ("approximate_user_authorization_count" in data) {
        this.approximateUserAuthorizationCount = data.approximate_user_authorization_count;
      } else {
        this.approximateUserAuthorizationCount ??= null;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("bot_require_code_grant" in data) {
        this.botRequireCodeGrant = data.bot_require_code_grant;
      } else {
        this.botRequireCodeGrant ??= null;
      }
      if ("bot" in data) {
        this.bot = this.client.users._add(data.bot);
      } else {
        this.bot ??= null;
      }
      if ("bot_public" in data) {
        this.botPublic = data.bot_public;
      } else {
        this.botPublic ??= null;
      }
      if ("interactions_endpoint_url" in data) {
        this.interactionsEndpointURL = data.interactions_endpoint_url;
      } else {
        this.interactionsEndpointURL ??= null;
      }
      if ("role_connections_verification_url" in data) {
        this.roleConnectionsVerificationURL = data.role_connections_verification_url;
      } else {
        this.roleConnectionsVerificationURL ??= null;
      }
      if ("event_webhooks_url" in data) {
        this.eventWebhooksURL = data.event_webhooks_url;
      } else {
        this.eventWebhooksURL ??= null;
      }
      if ("event_webhooks_status" in data) {
        this.eventWebhooksStatus = data.event_webhooks_status;
      } else {
        this.eventWebhooksStatus ??= null;
      }
      if ("event_webhooks_types" in data) {
        this.eventWebhooksTypes = data.event_webhooks_types;
      } else {
        this.eventWebhooksTypes ??= null;
      }
      this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users._add(data.owner) : this.owner ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    get partial() {
      return !this.name;
    }
    async edit({
      customInstallURL,
      description,
      roleConnectionsVerificationURL,
      installParams,
      flags,
      icon,
      coverImage,
      interactionsEndpointURL,
      eventWebhooksURL,
      eventWebhooksStatus,
      eventWebhooksTypes,
      tags
    } = {}) {
      const data = await this.client.rest.patch(Routes.currentApplication(), {
        body: {
          custom_install_url: customInstallURL,
          description,
          role_connections_verification_url: roleConnectionsVerificationURL,
          install_params: installParams,
          flags: flags === undefined ? undefined : ApplicationFlagsBitField.resolve(flags),
          icon: icon && await resolveImage(icon),
          cover_image: coverImage && await resolveImage(coverImage),
          interactions_endpoint_url: interactionsEndpointURL,
          event_webhooks_url: eventWebhooksURL,
          event_webhooks_status: eventWebhooksStatus,
          event_webhooks_types: eventWebhooksTypes,
          tags
        }
      });
      this._patch(data);
      return this;
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.currentApplication());
      this._patch(data);
      return this;
    }
    async fetchRoleConnectionMetadataRecords() {
      const metadata = await this.client.rest.get(Routes.applicationRoleConnectionMetadata(this.client.user.id));
      return metadata.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
    async editRoleConnectionMetadataRecords(records) {
      const newRecords = await this.client.rest.put(Routes.applicationRoleConnectionMetadata(this.client.user.id), {
        body: records.map((record) => ({
          type: record.type,
          key: record.key,
          name: record.name,
          name_localizations: record.nameLocalizations,
          description: record.description,
          description_localizations: record.descriptionLocalizations
        }))
      });
      return newRecords.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
    async fetchSKUs() {
      const skus = await this.client.rest.get(Routes.skus(this.id));
      return skus.reduce((coll, sku) => coll.set(sku.id, new SKU(this.client, sku)), new Collection);
    }
  }
  module.exports = ClientApplication;
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// ../../node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// ../../node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// ../../node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// ../../node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  module.exports = getRawTag;
});

// ../../node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  module.exports = objectToString;
});

// ../../node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  module.exports = baseGetTag;
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  module.exports = isObjectLike;
});

// ../../node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  module.exports = isSymbol;
});

// ../../node_modules/lodash/_isKey.js
var require__isKey = __commonJS((exports, module) => {
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  module.exports = isKey;
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  module.exports = isObject;
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag();
  var isObject = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  module.exports = isFunction;
});

// ../../node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// ../../node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  module.exports = isMasked;
});

// ../../node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }
  module.exports = toSource;
});

// ../../node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  var isFunction = require_isFunction();
  var isMasked = require__isMasked();
  var isObject = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  module.exports = baseIsNative;
});

// ../../node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  module.exports = getValue;
});

// ../../node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  module.exports = getNative;
});

// ../../node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// ../../node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  module.exports = hashClear;
});

// ../../node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = hashDelete;
});

// ../../node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  module.exports = hashGet;
});

// ../../node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  module.exports = hashHas;
});

// ../../node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  module.exports = hashSet;
});

// ../../node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// ../../node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  module.exports = listCacheClear;
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  module.exports = eq;
});

// ../../node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  var eq = require_eq();
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  module.exports = assocIndexOf;
});

// ../../node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  module.exports = listCacheDelete;
});

// ../../node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  module.exports = listCacheGet;
});

// ../../node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  module.exports = listCacheHas;
});

// ../../node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  module.exports = listCacheSet;
});

// ../../node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// ../../node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// ../../node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  var Hash = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  module.exports = mapCacheClear;
});

// ../../node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  module.exports = isKeyable;
});

// ../../node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  var isKeyable = require__isKeyable();
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  module.exports = getMapData;
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = mapCacheDelete;
});

// ../../node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  module.exports = mapCacheGet;
});

// ../../node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  module.exports = mapCacheHas;
});

// ../../node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  module.exports = mapCacheSet;
});

// ../../node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// ../../node_modules/lodash/memoize.js
var require_memoize = __commonJS((exports, module) => {
  var MapCache = require__MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }
  memoize.Cache = MapCache;
  module.exports = memoize;
});

// ../../node_modules/lodash/_memoizeCapped.js
var require__memoizeCapped = __commonJS((exports, module) => {
  var memoize = require_memoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  module.exports = memoizeCapped;
});

// ../../node_modules/lodash/_stringToPath.js
var require__stringToPath = __commonJS((exports, module) => {
  var memoizeCapped = require__memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  module.exports = stringToPath;
});

// ../../node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  module.exports = arrayMap;
});

// ../../node_modules/lodash/_baseToString.js
var require__baseToString = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol();
  var arrayMap = require__arrayMap();
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  module.exports = baseToString;
});

// ../../node_modules/lodash/toString.js
var require_toString = __commonJS((exports, module) => {
  var baseToString = require__baseToString();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  module.exports = toString;
});

// ../../node_modules/lodash/_castPath.js
var require__castPath = __commonJS((exports, module) => {
  var isArray = require_isArray();
  var isKey = require__isKey();
  var stringToPath = require__stringToPath();
  var toString = require_toString();
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }
  module.exports = castPath;
});

// ../../node_modules/lodash/_toKey.js
var require__toKey = __commonJS((exports, module) => {
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  module.exports = toKey;
});

// ../../node_modules/lodash/_baseGet.js
var require__baseGet = __commonJS((exports, module) => {
  var castPath = require__castPath();
  var toKey = require__toKey();
  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
  }
  module.exports = baseGet;
});

// ../../node_modules/lodash/get.js
var require_get = __commonJS((exports, module) => {
  var baseGet = require__baseGet();
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }
  module.exports = get;
});

// ../../node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a instanceof Map && b instanceof Map) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        for (i of a.entries())
          if (!equal(i[1], b.get(i[0])))
            return false;
        return true;
      }
      if (a instanceof Set && b instanceof Set) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        return true;
      }
      if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (a[i] !== b[i])
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// ../../node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  module.exports = setCacheAdd;
});

// ../../node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  module.exports = setCacheHas;
});

// ../../node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  var MapCache = require__MapCache();
  var setCacheAdd = require__setCacheAdd();
  var setCacheHas = require__setCacheHas();
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// ../../node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  module.exports = baseFindIndex;
});

// ../../node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  function baseIsNaN(value) {
    return value !== value;
  }
  module.exports = baseIsNaN;
});

// ../../node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  module.exports = strictIndexOf;
});

// ../../node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  var baseFindIndex = require__baseFindIndex();
  var baseIsNaN = require__baseIsNaN();
  var strictIndexOf = require__strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  module.exports = baseIndexOf;
});

// ../../node_modules/lodash/_arrayIncludes.js
var require__arrayIncludes = __commonJS((exports, module) => {
  var baseIndexOf = require__baseIndexOf();
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  module.exports = arrayIncludes;
});

// ../../node_modules/lodash/_arrayIncludesWith.js
var require__arrayIncludesWith = __commonJS((exports, module) => {
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  module.exports = arrayIncludesWith;
});

// ../../node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  module.exports = cacheHas;
});

// ../../node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Set2 = getNative(root, "Set");
  module.exports = Set2;
});

// ../../node_modules/lodash/noop.js
var require_noop = __commonJS((exports, module) => {
  function noop() {}
  module.exports = noop;
});

// ../../node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  module.exports = setToArray;
});

// ../../node_modules/lodash/_createSet.js
var require__createSet = __commonJS((exports, module) => {
  var Set2 = require__Set();
  var noop = require_noop();
  var setToArray = require__setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  module.exports = createSet;
});

// ../../node_modules/lodash/_baseUniq.js
var require__baseUniq = __commonJS((exports, module) => {
  var SetCache = require__SetCache();
  var arrayIncludes = require__arrayIncludes();
  var arrayIncludesWith = require__arrayIncludesWith();
  var cacheHas = require__cacheHas();
  var createSet = require__createSet();
  var setToArray = require__setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  module.exports = baseUniq;
});

// ../../node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS((exports, module) => {
  var baseUniq = require__baseUniq();
  function uniqWith(array, comparator) {
    comparator = typeof comparator == "function" ? comparator : undefined;
    return array && array.length ? baseUniq(array, undefined, comparator) : [];
  }
  module.exports = uniqWith;
});

// ../../node_modules/@sapphire/shapeshift/dist/cjs/index.cjs
var require_cjs3 = __commonJS((exports) => {
  var get = require_get();
  var fastDeepEqual = require_es6();
  var uniqWith = require_uniqWith();
  function _interopDefault(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  }
  var get__default = /* @__PURE__ */ _interopDefault(get);
  var fastDeepEqual__default = /* @__PURE__ */ _interopDefault(fastDeepEqual);
  var uniqWith__default = /* @__PURE__ */ _interopDefault(uniqWith);
  var __defProp2 = Object.defineProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var e;
  var t;
  var n;
  var r = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : globalThis;
  var o = e = {};
  function i() {
    throw new Error("setTimeout has not been defined");
  }
  __name(i, "i");
  function u() {
    throw new Error("clearTimeout has not been defined");
  }
  __name(u, "u");
  function c(e3) {
    if (t === setTimeout)
      return setTimeout(e3, 0);
    if ((t === i || !t) && setTimeout)
      return t = setTimeout, setTimeout(e3, 0);
    try {
      return t(e3, 0);
    } catch (n3) {
      try {
        return t.call(null, e3, 0);
      } catch (n4) {
        return t.call(this || r, e3, 0);
      }
    }
  }
  __name(c, "c");
  (function() {
    try {
      t = typeof setTimeout == "function" ? setTimeout : i;
    } catch (e3) {
      t = i;
    }
    try {
      n = typeof clearTimeout == "function" ? clearTimeout : u;
    } catch (e3) {
      n = u;
    }
  })();
  var l;
  var s = [];
  var f = false;
  var a = -1;
  function h() {
    f && l && (f = false, l.length ? s = l.concat(s) : a = -1, s.length && d());
  }
  __name(h, "h");
  function d() {
    if (!f) {
      var e3 = c(h);
      f = true;
      for (var t3 = s.length;t3; ) {
        for (l = s, s = [];++a < t3; )
          l && l[a].run();
        a = -1, t3 = s.length;
      }
      l = null, f = false, function(e4) {
        if (n === clearTimeout)
          return clearTimeout(e4);
        if ((n === u || !n) && clearTimeout)
          return n = clearTimeout, clearTimeout(e4);
        try {
          n(e4);
        } catch (t4) {
          try {
            return n.call(null, e4);
          } catch (t5) {
            return n.call(this || r, e4);
          }
        }
      }(e3);
    }
  }
  __name(d, "d");
  function m(e3, t3) {
    (this || r).fun = e3, (this || r).array = t3;
  }
  __name(m, "m");
  function p() {}
  __name(p, "p");
  o.nextTick = function(e3) {
    var t3 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n3 = 1;n3 < arguments.length; n3++)
        t3[n3 - 1] = arguments[n3];
    s.push(new m(e3, t3)), s.length !== 1 || f || c(d);
  }, m.prototype.run = function() {
    (this || r).fun.apply(null, (this || r).array);
  }, o.title = "browser", o.browser = true, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = p, o.addListener = p, o.once = p, o.off = p, o.removeListener = p, o.removeAllListeners = p, o.emit = p, o.prependListener = p, o.prependOnceListener = p, o.listeners = function(e3) {
    return [];
  }, o.binding = function(e3) {
    throw new Error("process.binding is not supported");
  }, o.cwd = function() {
    return "/";
  }, o.chdir = function(e3) {
    throw new Error("process.chdir is not supported");
  }, o.umask = function() {
    return 0;
  };
  var T = e;
  T.addListener;
  T.argv;
  T.binding;
  T.browser;
  T.chdir;
  T.cwd;
  T.emit;
  T.env;
  T.listeners;
  T.nextTick;
  T.off;
  T.on;
  T.once;
  T.prependListener;
  T.prependOnceListener;
  T.removeAllListeners;
  T.removeListener;
  T.title;
  T.umask;
  T.version;
  T.versions;
  var t2 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
  var e2 = Object.prototype.toString;
  var o2 = /* @__PURE__ */ __name(function(o3) {
    return !(t2 && o3 && typeof o3 == "object" && (Symbol.toStringTag in o3)) && e2.call(o3) === "[object Arguments]";
  }, "o");
  var n2 = /* @__PURE__ */ __name(function(t3) {
    return !!o2(t3) || t3 !== null && typeof t3 == "object" && typeof t3.length == "number" && t3.length >= 0 && e2.call(t3) !== "[object Array]" && e2.call(t3.callee) === "[object Function]";
  }, "n");
  var r2 = function() {
    return o2(arguments);
  }();
  o2.isLegacyArguments = n2;
  var l2 = r2 ? o2 : n2;
  var t$1 = Object.prototype.toString;
  var o$1 = Function.prototype.toString;
  var n$1 = /^\s*(?:function)?\*/;
  var e$1 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
  var r$1 = Object.getPrototypeOf;
  var c2 = function() {
    if (!e$1)
      return false;
    try {
      return Function("return function*() {}")();
    } catch (t3) {}
  }();
  var u2 = c2 ? r$1(c2) : {};
  var i2 = /* @__PURE__ */ __name(function(c3) {
    return typeof c3 == "function" && (!!n$1.test(o$1.call(c3)) || (e$1 ? r$1(c3) === u2 : t$1.call(c3) === "[object GeneratorFunction]"));
  }, "i");
  var t$2 = typeof Object.create == "function" ? function(t3, e3) {
    e3 && (t3.super_ = e3, t3.prototype = Object.create(e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }));
  } : function(t3, e3) {
    if (e3) {
      t3.super_ = e3;
      var o3 = /* @__PURE__ */ __name(function() {}, "o");
      o3.prototype = e3.prototype, t3.prototype = new o3, t3.prototype.constructor = t3;
    }
  };
  var i$1 = /* @__PURE__ */ __name(function(e3) {
    return e3 && typeof e3 == "object" && typeof e3.copy == "function" && typeof e3.fill == "function" && typeof e3.readUInt8 == "function";
  }, "i$1");
  var o$2 = {};
  var u$1 = i$1;
  var f2 = l2;
  var a2 = i2;
  function c$1(e3) {
    return e3.call.bind(e3);
  }
  __name(c$1, "c$1");
  var s2 = typeof BigInt != "undefined";
  var p2 = typeof Symbol != "undefined";
  var y = p2 && Symbol.toStringTag !== undefined;
  var l$1 = typeof Uint8Array != "undefined";
  var d2 = typeof ArrayBuffer != "undefined";
  if (l$1 && y)
    var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
  var m2 = c$1(Object.prototype.toString);
  var h2 = c$1(Number.prototype.valueOf);
  var j = c$1(String.prototype.valueOf);
  var A = c$1(Boolean.prototype.valueOf);
  if (s2)
    var w = c$1(BigInt.prototype.valueOf);
  if (p2)
    var v = c$1(Symbol.prototype.valueOf);
  function O(e3, t3) {
    if (typeof e3 != "object")
      return false;
    try {
      return t3(e3), true;
    } catch (e4) {
      return false;
    }
  }
  __name(O, "O");
  function S(e3) {
    return l$1 && y ? b(e3) !== undefined : B(e3) || k(e3) || E(e3) || D(e3) || U(e3) || P(e3) || x(e3) || I(e3) || M(e3) || z(e3) || F(e3);
  }
  __name(S, "S");
  function B(e3) {
    return l$1 && y ? b(e3) === "Uint8Array" : m2(e3) === "[object Uint8Array]" || u$1(e3) && e3.buffer !== undefined;
  }
  __name(B, "B");
  function k(e3) {
    return l$1 && y ? b(e3) === "Uint8ClampedArray" : m2(e3) === "[object Uint8ClampedArray]";
  }
  __name(k, "k");
  function E(e3) {
    return l$1 && y ? b(e3) === "Uint16Array" : m2(e3) === "[object Uint16Array]";
  }
  __name(E, "E");
  function D(e3) {
    return l$1 && y ? b(e3) === "Uint32Array" : m2(e3) === "[object Uint32Array]";
  }
  __name(D, "D");
  function U(e3) {
    return l$1 && y ? b(e3) === "Int8Array" : m2(e3) === "[object Int8Array]";
  }
  __name(U, "U");
  function P(e3) {
    return l$1 && y ? b(e3) === "Int16Array" : m2(e3) === "[object Int16Array]";
  }
  __name(P, "P");
  function x(e3) {
    return l$1 && y ? b(e3) === "Int32Array" : m2(e3) === "[object Int32Array]";
  }
  __name(x, "x");
  function I(e3) {
    return l$1 && y ? b(e3) === "Float32Array" : m2(e3) === "[object Float32Array]";
  }
  __name(I, "I");
  function M(e3) {
    return l$1 && y ? b(e3) === "Float64Array" : m2(e3) === "[object Float64Array]";
  }
  __name(M, "M");
  function z(e3) {
    return l$1 && y ? b(e3) === "BigInt64Array" : m2(e3) === "[object BigInt64Array]";
  }
  __name(z, "z");
  function F(e3) {
    return l$1 && y ? b(e3) === "BigUint64Array" : m2(e3) === "[object BigUint64Array]";
  }
  __name(F, "F");
  function T2(e3) {
    return m2(e3) === "[object Map]";
  }
  __name(T2, "T");
  function N(e3) {
    return m2(e3) === "[object Set]";
  }
  __name(N, "N");
  function W(e3) {
    return m2(e3) === "[object WeakMap]";
  }
  __name(W, "W");
  function $(e3) {
    return m2(e3) === "[object WeakSet]";
  }
  __name($, "$");
  function C(e3) {
    return m2(e3) === "[object ArrayBuffer]";
  }
  __name(C, "C");
  function V(e3) {
    return typeof ArrayBuffer != "undefined" && (C.working ? C(e3) : e3 instanceof ArrayBuffer);
  }
  __name(V, "V");
  function G(e3) {
    return m2(e3) === "[object DataView]";
  }
  __name(G, "G");
  function R(e3) {
    return typeof DataView != "undefined" && (G.working ? G(e3) : e3 instanceof DataView);
  }
  __name(R, "R");
  function J(e3) {
    return m2(e3) === "[object SharedArrayBuffer]";
  }
  __name(J, "J");
  function _(e3) {
    return typeof SharedArrayBuffer != "undefined" && (J.working ? J(e3) : e3 instanceof SharedArrayBuffer);
  }
  __name(_, "_");
  function H(e3) {
    return O(e3, h2);
  }
  __name(H, "H");
  function Z(e3) {
    return O(e3, j);
  }
  __name(Z, "Z");
  function q(e3) {
    return O(e3, A);
  }
  __name(q, "q");
  function K(e3) {
    return s2 && O(e3, w);
  }
  __name(K, "K");
  function L(e3) {
    return p2 && O(e3, v);
  }
  __name(L, "L");
  o$2.isArgumentsObject = f2, o$2.isGeneratorFunction = a2, o$2.isPromise = function(e3) {
    return typeof Promise != "undefined" && e3 instanceof Promise || e3 !== null && typeof e3 == "object" && typeof e3.then == "function" && typeof e3.catch == "function";
  }, o$2.isArrayBufferView = function(e3) {
    return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : S(e3) || R(e3);
  }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = typeof Map != "undefined" && T2(/* @__PURE__ */ new Map), o$2.isMap = function(e3) {
    return typeof Map != "undefined" && (T2.working ? T2(e3) : e3 instanceof Map);
  }, N.working = typeof Set != "undefined" && N(/* @__PURE__ */ new Set), o$2.isSet = function(e3) {
    return typeof Set != "undefined" && (N.working ? N(e3) : e3 instanceof Set);
  }, W.working = typeof WeakMap != "undefined" && W(/* @__PURE__ */ new WeakMap), o$2.isWeakMap = function(e3) {
    return typeof WeakMap != "undefined" && (W.working ? W(e3) : e3 instanceof WeakMap);
  }, $.working = typeof WeakSet != "undefined" && $(/* @__PURE__ */ new WeakSet), o$2.isWeakSet = function(e3) {
    return $(e3);
  }, C.working = typeof ArrayBuffer != "undefined" && C(new ArrayBuffer), o$2.isArrayBuffer = V, G.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = typeof SharedArrayBuffer != "undefined" && J(new SharedArrayBuffer), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e3) {
    return m2(e3) === "[object AsyncFunction]";
  }, o$2.isMapIterator = function(e3) {
    return m2(e3) === "[object Map Iterator]";
  }, o$2.isSetIterator = function(e3) {
    return m2(e3) === "[object Set Iterator]";
  }, o$2.isGeneratorObject = function(e3) {
    return m2(e3) === "[object Generator]";
  }, o$2.isWebAssemblyCompiledModule = function(e3) {
    return m2(e3) === "[object WebAssembly.Module]";
  }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e3) {
    return H(e3) || Z(e3) || q(e3) || K(e3) || L(e3);
  }, o$2.isAnyArrayBuffer = function(e3) {
    return l$1 && (V(e3) || _(e3));
  }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e3) {
    Object.defineProperty(o$2, e3, { enumerable: false, value: function() {
      throw new Error(e3 + " is not supported in userland");
    } });
  });
  var Q = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : globalThis;
  var X = {};
  var Y = T;
  var ee = Object.getOwnPropertyDescriptors || function(e3) {
    for (var t3 = Object.keys(e3), r3 = {}, n3 = 0;n3 < t3.length; n3++)
      r3[t3[n3]] = Object.getOwnPropertyDescriptor(e3, t3[n3]);
    return r3;
  };
  var te = /%[sdj%]/g;
  X.format = function(e3) {
    if (!ge(e3)) {
      for (var t3 = [], r3 = 0;r3 < arguments.length; r3++)
        t3.push(oe(arguments[r3]));
      return t3.join(" ");
    }
    r3 = 1;
    for (var n3 = arguments, i3 = n3.length, o3 = String(e3).replace(te, function(e4) {
      if (e4 === "%%")
        return "%";
      if (r3 >= i3)
        return e4;
      switch (e4) {
        case "%s":
          return String(n3[r3++]);
        case "%d":
          return Number(n3[r3++]);
        case "%j":
          try {
            return JSON.stringify(n3[r3++]);
          } catch (e5) {
            return "[Circular]";
          }
        default:
          return e4;
      }
    }), u3 = n3[r3];r3 < i3; u3 = n3[++r3])
      le(u3) || !he(u3) ? o3 += " " + u3 : o3 += " " + oe(u3);
    return o3;
  }, X.deprecate = function(e3, t3) {
    if (Y !== undefined && Y.noDeprecation === true)
      return e3;
    if (Y === undefined)
      return function() {
        return X.deprecate(e3, t3).apply(this || Q, arguments);
      };
    var r3 = false;
    return function() {
      if (!r3) {
        if (Y.throwDeprecation)
          throw new Error(t3);
        Y.traceDeprecation ? console.trace(t3) : console.error(t3), r3 = true;
      }
      return e3.apply(this || Q, arguments);
    };
  };
  var re = {};
  var ne = /^$/;
  if (Y.env.NODE_DEBUG) {
    ie = Y.env.NODE_DEBUG;
    ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
  }
  var ie;
  function oe(e3, t3) {
    var r3 = { seen: [], stylize: fe };
    return arguments.length >= 3 && (r3.depth = arguments[2]), arguments.length >= 4 && (r3.colors = arguments[3]), ye(t3) ? r3.showHidden = t3 : t3 && X._extend(r3, t3), be(r3.showHidden) && (r3.showHidden = false), be(r3.depth) && (r3.depth = 2), be(r3.colors) && (r3.colors = false), be(r3.customInspect) && (r3.customInspect = true), r3.colors && (r3.stylize = ue), ae(r3, e3, r3.depth);
  }
  __name(oe, "oe");
  function ue(e3, t3) {
    var r3 = oe.styles[t3];
    return r3 ? "\x1B[" + oe.colors[r3][0] + "m" + e3 + "\x1B[" + oe.colors[r3][1] + "m" : e3;
  }
  __name(ue, "ue");
  function fe(e3, t3) {
    return e3;
  }
  __name(fe, "fe");
  function ae(e3, t3, r3) {
    if (e3.customInspect && t3 && we(t3.inspect) && t3.inspect !== X.inspect && (!t3.constructor || t3.constructor.prototype !== t3)) {
      var n3 = t3.inspect(r3, e3);
      return ge(n3) || (n3 = ae(e3, n3, r3)), n3;
    }
    var i3 = function(e4, t4) {
      if (be(t4))
        return e4.stylize("undefined", "undefined");
      if (ge(t4)) {
        var r4 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e4.stylize(r4, "string");
      }
      if (de(t4))
        return e4.stylize("" + t4, "number");
      if (ye(t4))
        return e4.stylize("" + t4, "boolean");
      if (le(t4))
        return e4.stylize("null", "null");
    }(e3, t3);
    if (i3)
      return i3;
    var o3 = Object.keys(t3), u3 = function(e4) {
      var t4 = {};
      return e4.forEach(function(e5, r4) {
        t4[e5] = true;
      }), t4;
    }(o3);
    if (e3.showHidden && (o3 = Object.getOwnPropertyNames(t3)), Ae(t3) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0))
      return ce(t3);
    if (o3.length === 0) {
      if (we(t3)) {
        var f3 = t3.name ? ": " + t3.name : "";
        return e3.stylize("[Function" + f3 + "]", "special");
      }
      if (me(t3))
        return e3.stylize(RegExp.prototype.toString.call(t3), "regexp");
      if (je(t3))
        return e3.stylize(Date.prototype.toString.call(t3), "date");
      if (Ae(t3))
        return ce(t3);
    }
    var a3, c3 = "", s4 = false, p3 = ["{", "}"];
    (pe(t3) && (s4 = true, p3 = ["[", "]"]), we(t3)) && (c3 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
    return me(t3) && (c3 = " " + RegExp.prototype.toString.call(t3)), je(t3) && (c3 = " " + Date.prototype.toUTCString.call(t3)), Ae(t3) && (c3 = " " + ce(t3)), o3.length !== 0 || s4 && t3.length != 0 ? r3 < 0 ? me(t3) ? e3.stylize(RegExp.prototype.toString.call(t3), "regexp") : e3.stylize("[Object]", "special") : (e3.seen.push(t3), a3 = s4 ? function(e4, t4, r4, n4, i4) {
      for (var o4 = [], u4 = 0, f4 = t4.length;u4 < f4; ++u4)
        ke(t4, String(u4)) ? o4.push(se(e4, t4, r4, n4, String(u4), true)) : o4.push("");
      return i4.forEach(function(i5) {
        i5.match(/^\d+$/) || o4.push(se(e4, t4, r4, n4, i5, true));
      }), o4;
    }(e3, t3, r3, u3, o3) : o3.map(function(n4) {
      return se(e3, t3, r3, u3, n4, s4);
    }), e3.seen.pop(), function(e4, t4, r4) {
      var n4 = 0;
      if (e4.reduce(function(e5, t5) {
        return n4++, t5.indexOf(`
`) >= 0 && n4++, e5 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60)
        return r4[0] + (t4 === "" ? "" : t4 + `
 `) + " " + e4.join(`,
  `) + " " + r4[1];
      return r4[0] + t4 + " " + e4.join(", ") + " " + r4[1];
    }(a3, c3, p3)) : p3[0] + c3 + p3[1];
  }
  __name(ae, "ae");
  function ce(e3) {
    return "[" + Error.prototype.toString.call(e3) + "]";
  }
  __name(ce, "ce");
  function se(e3, t3, r3, n3, i3, o3) {
    var u3, f3, a3;
    if ((a3 = Object.getOwnPropertyDescriptor(t3, i3) || { value: t3[i3] }).get ? f3 = a3.set ? e3.stylize("[Getter/Setter]", "special") : e3.stylize("[Getter]", "special") : a3.set && (f3 = e3.stylize("[Setter]", "special")), ke(n3, i3) || (u3 = "[" + i3 + "]"), f3 || (e3.seen.indexOf(a3.value) < 0 ? (f3 = le(r3) ? ae(e3, a3.value, null) : ae(e3, a3.value, r3 - 1)).indexOf(`
`) > -1 && (f3 = o3 ? f3.split(`
`).map(function(e4) {
      return "  " + e4;
    }).join(`
`).substr(2) : `
` + f3.split(`
`).map(function(e4) {
      return "   " + e4;
    }).join(`
`)) : f3 = e3.stylize("[Circular]", "special")), be(u3)) {
      if (o3 && i3.match(/^\d+$/))
        return f3;
      (u3 = JSON.stringify("" + i3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u3 = u3.substr(1, u3.length - 2), u3 = e3.stylize(u3, "name")) : (u3 = u3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u3 = e3.stylize(u3, "string"));
    }
    return u3 + ": " + f3;
  }
  __name(se, "se");
  function pe(e3) {
    return Array.isArray(e3);
  }
  __name(pe, "pe");
  function ye(e3) {
    return typeof e3 == "boolean";
  }
  __name(ye, "ye");
  function le(e3) {
    return e3 === null;
  }
  __name(le, "le");
  function de(e3) {
    return typeof e3 == "number";
  }
  __name(de, "de");
  function ge(e3) {
    return typeof e3 == "string";
  }
  __name(ge, "ge");
  function be(e3) {
    return e3 === undefined;
  }
  __name(be, "be");
  function me(e3) {
    return he(e3) && ve(e3) === "[object RegExp]";
  }
  __name(me, "me");
  function he(e3) {
    return typeof e3 == "object" && e3 !== null;
  }
  __name(he, "he");
  function je(e3) {
    return he(e3) && ve(e3) === "[object Date]";
  }
  __name(je, "je");
  function Ae(e3) {
    return he(e3) && (ve(e3) === "[object Error]" || e3 instanceof Error);
  }
  __name(Ae, "Ae");
  function we(e3) {
    return typeof e3 == "function";
  }
  __name(we, "we");
  function ve(e3) {
    return Object.prototype.toString.call(e3);
  }
  __name(ve, "ve");
  function Oe(e3) {
    return e3 < 10 ? "0" + e3.toString(10) : e3.toString(10);
  }
  __name(Oe, "Oe");
  X.debuglog = function(e3) {
    if (e3 = e3.toUpperCase(), !re[e3])
      if (ne.test(e3)) {
        var t3 = Y.pid;
        re[e3] = function() {
          var r3 = X.format.apply(X, arguments);
          console.error("%s %d: %s", e3, t3, r3);
        };
      } else
        re[e3] = function() {};
    return re[e3];
  }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e3) {
    return e3 == null;
  }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e3) {
    return typeof e3 == "symbol";
  }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e3) {
    return e3 === null || typeof e3 == "boolean" || typeof e3 == "number" || typeof e3 == "string" || typeof e3 == "symbol" || e3 === undefined;
  }, X.isBuffer = i$1;
  var Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function Be() {
    var e3 = /* @__PURE__ */ new Date, t3 = [Oe(e3.getHours()), Oe(e3.getMinutes()), Oe(e3.getSeconds())].join(":");
    return [e3.getDate(), Se[e3.getMonth()], t3].join(" ");
  }
  __name(Be, "Be");
  function ke(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  }
  __name(ke, "ke");
  X.log = function() {
    console.log("%s - %s", Be(), X.format.apply(X, arguments));
  }, X.inherits = t$2, X._extend = function(e3, t3) {
    if (!t3 || !he(t3))
      return e3;
    for (var r3 = Object.keys(t3), n3 = r3.length;n3--; )
      e3[r3[n3]] = t3[r3[n3]];
    return e3;
  };
  var Ee = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : undefined;
  function De(e3, t3) {
    if (!e3) {
      var r3 = new Error("Promise was rejected with a falsy value");
      r3.reason = e3, e3 = r3;
    }
    return t3(e3);
  }
  __name(De, "De");
  X.promisify = function(e3) {
    if (typeof e3 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (Ee && e3[Ee]) {
      var t3;
      if (typeof (t3 = e3[Ee]) != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
    }
    function t3() {
      for (var t4, r3, n3 = new Promise(function(e4, n4) {
        t4 = e4, r3 = n4;
      }), i3 = [], o3 = 0;o3 < arguments.length; o3++)
        i3.push(arguments[o3]);
      i3.push(function(e4, n4) {
        e4 ? r3(e4) : t4(n4);
      });
      try {
        e3.apply(this || Q, i3);
      } catch (e4) {
        r3(e4);
      }
      return n3;
    }
    __name(t3, "t");
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Ee && Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, ee(e3));
  }, X.promisify.custom = Ee, X.callbackify = function(e3) {
    if (typeof e3 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function t3() {
      for (var t4 = [], r3 = 0;r3 < arguments.length; r3++)
        t4.push(arguments[r3]);
      var n3 = t4.pop();
      if (typeof n3 != "function")
        throw new TypeError("The last argument must be of type Function");
      var i3 = this || Q, o3 = /* @__PURE__ */ __name(function() {
        return n3.apply(i3, arguments);
      }, "o");
      e3.apply(this || Q, t4).then(function(e4) {
        Y.nextTick(o3.bind(null, null, e4));
      }, function(e4) {
        Y.nextTick(De.bind(null, e4, o3));
      });
    }
    __name(t3, "t");
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Object.defineProperties(t3, ee(e3)), t3;
  };
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X.types;
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  var inspect2 = X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X.types;
  X.TextEncoder = globalThis.TextEncoder;
  X.TextDecoder = globalThis.TextDecoder;
  var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
  var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
  var _BaseError = class _BaseError2 extends Error {
    toJSON() {
      return {
        name: this.name,
        message: this.message
      };
    }
    [customInspectSymbol](depth, options) {
      return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf(`
`))}`;
    }
  };
  __name(_BaseError, "BaseError");
  var BaseError = _BaseError;
  var _BaseConstraintError = class _BaseConstraintError2 extends BaseError {
    constructor(constraint, message, given) {
      super(message);
      this.constraint = constraint;
      this.given = given;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        message: this.message
      };
    }
  };
  __name(_BaseConstraintError, "BaseConstraintError");
  var BaseConstraintError = _BaseConstraintError;
  var _ExpectedConstraintError = class _ExpectedConstraintError2 extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected,
        message: this.message
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_ExpectedConstraintError, "ExpectedConstraintError");
  var ExpectedConstraintError = _ExpectedConstraintError;
  var _Result = class _Result2 {
    constructor(success, value, error) {
      this.success = success;
      if (success) {
        this.value = value;
      } else {
        this.error = error;
      }
    }
    isOk() {
      return this.success;
    }
    isErr() {
      return !this.success;
    }
    unwrap() {
      if (this.isOk())
        return this.value;
      throw this.error;
    }
    static ok(value) {
      return new _Result2(true, value);
    }
    static err(error) {
      return new _Result2(false, undefined, error);
    }
  };
  __name(_Result, "Result");
  var Result = _Result;
  function whenConstraint(key, options, validator, validatorOptions) {
    return {
      run(input, parent) {
        if (!parent) {
          return Result.err(new ExpectedConstraintError("s.object(T.when)", validatorOptions?.message ?? "Validator has no parent", parent, "Validator to have a parent"));
        }
        const isKeyArray = Array.isArray(key);
        const value = isKeyArray ? key.map((k2) => get__default.default(parent, k2)) : get__default.default(parent, key);
        const predicate = resolveBooleanIs(options, value, isKeyArray) ? options.then : options.otherwise;
        if (predicate) {
          return predicate(validator).run(input);
        }
        return Result.ok(input);
      }
    };
  }
  __name(whenConstraint, "whenConstraint");
  function resolveBooleanIs(options, value, isKeyArray) {
    if (options.is === undefined) {
      return isKeyArray ? !value.some((val) => !val) : Boolean(value);
    }
    if (typeof options.is === "function") {
      return options.is(value);
    }
    return value === options.is;
  }
  __name(resolveBooleanIs, "resolveBooleanIs");
  var validationEnabled = true;
  function setGlobalValidationEnabled(enabled) {
    validationEnabled = enabled;
  }
  __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
  function getGlobalValidationEnabled() {
    return validationEnabled;
  }
  __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");
  function getValue(valueOrFn) {
    return typeof valueOrFn === "function" ? valueOrFn() : valueOrFn;
  }
  __name(getValue, "getValue");
  var _BaseValidator = class _BaseValidator2 {
    constructor(validatorOptions = {}, constraints = []) {
      this.constraints = [];
      this.isValidationEnabled = null;
      this.constraints = constraints;
      this.validatorOptions = validatorOptions;
    }
    setParent(parent) {
      this.parent = parent;
      return this;
    }
    optional(options = this.validatorOptions) {
      return new UnionValidator([new LiteralValidator(undefined, options), this.clone()], options);
    }
    nullable(options = this.validatorOptions) {
      return new UnionValidator([new LiteralValidator(null, options), this.clone()], options);
    }
    nullish(options = this.validatorOptions) {
      return new UnionValidator([new NullishValidator(options), this.clone()], options);
    }
    array(options = this.validatorOptions) {
      return new ArrayValidator(this.clone(), options);
    }
    set(options = this.validatorOptions) {
      return new SetValidator(this.clone(), options);
    }
    or(...predicates) {
      return new UnionValidator([this.clone(), ...predicates], this.validatorOptions);
    }
    transform(cb, options = this.validatorOptions) {
      return this.addConstraint({
        run: (input) => Result.ok(cb(input))
      }, options);
    }
    reshape(cb, options = this.validatorOptions) {
      return this.addConstraint({
        run: cb
      }, options);
    }
    default(value, options = this.validatorOptions) {
      return new DefaultValidator(this.clone(), value, options);
    }
    when(key, options, validatorOptions) {
      return this.addConstraint(whenConstraint(key, options, this, validatorOptions));
    }
    describe(description) {
      const clone = this.clone();
      clone.description = description;
      return clone;
    }
    run(value) {
      let result = this.handle(value);
      if (result.isErr())
        return result;
      for (const constraint of this.constraints) {
        result = constraint.run(result.value, this.parent);
        if (result.isErr())
          break;
      }
      return result;
    }
    parse(value) {
      if (!this.shouldRunConstraints) {
        return this.handle(value).unwrap();
      }
      return this.constraints.reduce((v2, constraint) => constraint.run(v2).unwrap(), this.handle(value).unwrap());
    }
    is(value) {
      return this.run(value).isOk();
    }
    setValidationEnabled(isValidationEnabled) {
      const clone = this.clone();
      clone.isValidationEnabled = isValidationEnabled;
      return clone;
    }
    getValidationEnabled() {
      return getValue(this.isValidationEnabled);
    }
    get shouldRunConstraints() {
      return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();
    }
    clone() {
      const clone = Reflect.construct(this.constructor, [this.validatorOptions, this.constraints]);
      clone.isValidationEnabled = this.isValidationEnabled;
      return clone;
    }
    addConstraint(constraint, validatorOptions = this.validatorOptions) {
      const clone = this.clone();
      clone.validatorOptions = validatorOptions;
      clone.constraints = clone.constraints.concat(constraint);
      return clone;
    }
  };
  __name(_BaseValidator, "BaseValidator");
  var BaseValidator = _BaseValidator;
  function isUnique(input) {
    if (input.length < 2)
      return true;
    const uniqueArray2 = uniqWith__default.default(input, fastDeepEqual__default.default);
    return uniqueArray2.length === input.length;
  }
  __name(isUnique, "isUnique");
  function lessThan(a3, b2) {
    return a3 < b2;
  }
  __name(lessThan, "lessThan");
  function lessThanOrEqual(a3, b2) {
    return a3 <= b2;
  }
  __name(lessThanOrEqual, "lessThanOrEqual");
  function greaterThan(a3, b2) {
    return a3 > b2;
  }
  __name(greaterThan, "greaterThan");
  function greaterThanOrEqual(a3, b2) {
    return a3 >= b2;
  }
  __name(greaterThanOrEqual, "greaterThanOrEqual");
  function equal(a3, b2) {
    return a3 === b2;
  }
  __name(equal, "equal");
  function notEqual(a3, b2) {
    return a3 !== b2;
  }
  __name(notEqual, "notEqual");
  function arrayLengthComparator(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthComparator, "arrayLengthComparator");
  function arrayLengthLessThan(value, options) {
    const expected = `expected.length < ${value}`;
    return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan()", expected, value, options);
  }
  __name(arrayLengthLessThan, "arrayLengthLessThan");
  function arrayLengthLessThanOrEqual(value, options) {
    const expected = `expected.length <= ${value}`;
    return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual()", expected, value, options);
  }
  __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
  function arrayLengthGreaterThan(value, options) {
    const expected = `expected.length > ${value}`;
    return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan()", expected, value, options);
  }
  __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
  function arrayLengthGreaterThanOrEqual(value, options) {
    const expected = `expected.length >= ${value}`;
    return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual()", expected, value, options);
  }
  __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
  function arrayLengthEqual(value, options) {
    const expected = `expected.length === ${value}`;
    return arrayLengthComparator(equal, "s.array(T).lengthEqual()", expected, value, options);
  }
  __name(arrayLengthEqual, "arrayLengthEqual");
  function arrayLengthNotEqual(value, options) {
    const expected = `expected.length !== ${value}`;
    return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual()", expected, value, options);
  }
  __name(arrayLengthNotEqual, "arrayLengthNotEqual");
  function arrayLengthRange(start, endBefore, options) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange()", options?.message ?? "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthRange, "arrayLengthRange");
  function arrayLengthRangeInclusive(start, end, options) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive()", options?.message ?? "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
  function arrayLengthRangeExclusive(startAfter, endBefore, options) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive()", options?.message ?? "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");
  function uniqueArray(options) {
    return {
      run(input) {
        return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).unique()", options?.message ?? "Array values are not unique", input, "Expected all values to be unique"));
      }
    };
  }
  __name(uniqueArray, "uniqueArray");
  var _CombinedPropertyError = class _CombinedPropertyError2 extends BaseError {
    constructor(errors, validatorOptions) {
      super(validatorOptions?.message ?? "Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedPropertyError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map(([key, error]) => {
        const property = _CombinedPropertyError2.formatProperty(key, options);
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  input${property}${padding}${body}`;
      }).join(`

`);
      return `${header}
  ${message}

${errors}`;
    }
    static formatProperty(key, options) {
      if (typeof key === "string")
        return options.stylize(`.${key}`, "symbol");
      if (typeof key === "number")
        return `[${options.stylize(key.toString(), "number")}]`;
      return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
    }
  };
  __name(_CombinedPropertyError, "CombinedPropertyError");
  var CombinedPropertyError = _CombinedPropertyError;
  var _ValidationError = class _ValidationError2 extends BaseError {
    constructor(validator, message, given) {
      super(message);
      this.validator = validator;
      this.given = given;
    }
    toJSON() {
      return {
        name: this.name,
        message: "Unknown validation error occurred.",
        validator: this.validator,
        given: this.given
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(_ValidationError, "ValidationError");
  var ValidationError = _ValidationError;
  var _ArrayValidator = class _ArrayValidator2 extends BaseValidator {
    constructor(validator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    lengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthLessThan(length, options));
    }
    lengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthLessThanOrEqual(length, options));
    }
    lengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthGreaterThan(length, options));
    }
    lengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthGreaterThanOrEqual(length, options));
    }
    lengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthEqual(length, options));
    }
    lengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthNotEqual(length, options));
    }
    lengthRange(start, endBefore, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthRange(start, endBefore, options));
    }
    lengthRangeInclusive(startAt, endAt, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt, options));
    }
    lengthRangeExclusive(startAfter, endBefore, options = this.validatorOptions) {
      return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore, options));
    }
    unique(options = this.validatorOptions) {
      return this.addConstraint(uniqueArray(options));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.array(T)", this.validatorOptions.message ?? "Expected an array", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i3 = 0;i3 < values.length; i3++) {
        const result = this.validator.run(values[i3]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i3, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_ArrayValidator, "ArrayValidator");
  var ArrayValidator = _ArrayValidator;
  function bigintComparator(comparator, name, expected, number, options) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid bigint value", input, expected));
      }
    };
  }
  __name(bigintComparator, "bigintComparator");
  function bigintLessThan(value, options) {
    const expected = `expected < ${value}n`;
    return bigintComparator(lessThan, "s.bigint().lessThan()", expected, value, options);
  }
  __name(bigintLessThan, "bigintLessThan");
  function bigintLessThanOrEqual(value, options) {
    const expected = `expected <= ${value}n`;
    return bigintComparator(lessThanOrEqual, "s.bigint().lessThanOrEqual()", expected, value, options);
  }
  __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
  function bigintGreaterThan(value, options) {
    const expected = `expected > ${value}n`;
    return bigintComparator(greaterThan, "s.bigint().greaterThan()", expected, value, options);
  }
  __name(bigintGreaterThan, "bigintGreaterThan");
  function bigintGreaterThanOrEqual(value, options) {
    const expected = `expected >= ${value}n`;
    return bigintComparator(greaterThanOrEqual, "s.bigint().greaterThanOrEqual()", expected, value, options);
  }
  __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
  function bigintEqual(value, options) {
    const expected = `expected === ${value}n`;
    return bigintComparator(equal, "s.bigint().equal()", expected, value, options);
  }
  __name(bigintEqual, "bigintEqual");
  function bigintNotEqual(value, options) {
    const expected = `expected !== ${value}n`;
    return bigintComparator(notEqual, "s.bigint().notEqual()", expected, value, options);
  }
  __name(bigintNotEqual, "bigintNotEqual");
  function bigintDivisibleBy(divider, options) {
    const expected = `expected % ${divider}n === 0n`;
    return {
      run(input) {
        return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint().divisibleBy()", options?.message ?? "BigInt is not divisible", input, expected));
      }
    };
  }
  __name(bigintDivisibleBy, "bigintDivisibleBy");
  var _BigIntValidator = class _BigIntValidator2 extends BaseValidator {
    lessThan(number, options = this.validatorOptions) {
      return this.addConstraint(bigintLessThan(number, options));
    }
    lessThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(bigintLessThanOrEqual(number, options));
    }
    greaterThan(number, options = this.validatorOptions) {
      return this.addConstraint(bigintGreaterThan(number, options));
    }
    greaterThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(bigintGreaterThanOrEqual(number, options));
    }
    equal(number, options = this.validatorOptions) {
      return this.addConstraint(bigintEqual(number, options));
    }
    notEqual(number, options = this.validatorOptions) {
      return this.addConstraint(bigintNotEqual(number, options));
    }
    positive(options = this.validatorOptions) {
      return this.greaterThanOrEqual(0n, options);
    }
    negative(options = this.validatorOptions) {
      return this.lessThan(0n, options);
    }
    divisibleBy(number, options = this.validatorOptions) {
      return this.addConstraint(bigintDivisibleBy(number, options));
    }
    abs(options = this.validatorOptions) {
      return this.transform((value) => value < 0 ? -value : value, options);
    }
    intN(bits, options = this.validatorOptions) {
      return this.transform((value) => BigInt.asIntN(bits, value), options);
    }
    uintN(bits, options = this.validatorOptions) {
      return this.transform((value) => BigInt.asUintN(bits, value), options);
    }
    handle(value) {
      return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint()", this.validatorOptions.message ?? "Expected a bigint primitive", value));
    }
  };
  __name(_BigIntValidator, "BigIntValidator");
  var BigIntValidator = _BigIntValidator;
  function booleanTrue(options) {
    return {
      run(input) {
        return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean().true()", options?.message ?? "Invalid boolean value", input, "true"));
      }
    };
  }
  __name(booleanTrue, "booleanTrue");
  function booleanFalse(options) {
    return {
      run(input) {
        return input ? Result.err(new ExpectedConstraintError("s.boolean().false()", options?.message ?? "Invalid boolean value", input, "false")) : Result.ok(input);
      }
    };
  }
  __name(booleanFalse, "booleanFalse");
  var _BooleanValidator = class _BooleanValidator2 extends BaseValidator {
    true(options = this.validatorOptions) {
      return this.addConstraint(booleanTrue(options));
    }
    false(options = this.validatorOptions) {
      return this.addConstraint(booleanFalse(options));
    }
    equal(value, options = this.validatorOptions) {
      return value ? this.true(options) : this.false(options);
    }
    notEqual(value, options = this.validatorOptions) {
      return value ? this.false(options) : this.true(options);
    }
    handle(value) {
      return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean()", this.validatorOptions.message ?? "Expected a boolean primitive", value));
    }
  };
  __name(_BooleanValidator, "BooleanValidator");
  var BooleanValidator = _BooleanValidator;
  function dateComparator(comparator, name, expected, number, options) {
    return {
      run(input) {
        return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Date value", input, expected));
      }
    };
  }
  __name(dateComparator, "dateComparator");
  function dateLessThan(value, options) {
    const expected = `expected < ${value.toISOString()}`;
    return dateComparator(lessThan, "s.date().lessThan()", expected, value.getTime(), options);
  }
  __name(dateLessThan, "dateLessThan");
  function dateLessThanOrEqual(value, options) {
    const expected = `expected <= ${value.toISOString()}`;
    return dateComparator(lessThanOrEqual, "s.date().lessThanOrEqual()", expected, value.getTime(), options);
  }
  __name(dateLessThanOrEqual, "dateLessThanOrEqual");
  function dateGreaterThan(value, options) {
    const expected = `expected > ${value.toISOString()}`;
    return dateComparator(greaterThan, "s.date().greaterThan()", expected, value.getTime(), options);
  }
  __name(dateGreaterThan, "dateGreaterThan");
  function dateGreaterThanOrEqual(value, options) {
    const expected = `expected >= ${value.toISOString()}`;
    return dateComparator(greaterThanOrEqual, "s.date().greaterThanOrEqual()", expected, value.getTime(), options);
  }
  __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
  function dateEqual(value, options) {
    const expected = `expected === ${value.toISOString()}`;
    return dateComparator(equal, "s.date().equal()", expected, value.getTime(), options);
  }
  __name(dateEqual, "dateEqual");
  function dateNotEqual(value, options) {
    const expected = `expected !== ${value.toISOString()}`;
    return dateComparator(notEqual, "s.date().notEqual()", expected, value.getTime(), options);
  }
  __name(dateNotEqual, "dateNotEqual");
  function dateInvalid(options) {
    return {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date().invalid()", options?.message ?? "Invalid Date value", input, "expected === NaN"));
      }
    };
  }
  __name(dateInvalid, "dateInvalid");
  function dateValid(options) {
    return {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date().valid()", options?.message ?? "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
  }
  __name(dateValid, "dateValid");
  var _DateValidator = class _DateValidator2 extends BaseValidator {
    lessThan(date, options = this.validatorOptions) {
      return this.addConstraint(dateLessThan(new Date(date), options));
    }
    lessThanOrEqual(date, options = this.validatorOptions) {
      return this.addConstraint(dateLessThanOrEqual(new Date(date), options));
    }
    greaterThan(date, options = this.validatorOptions) {
      return this.addConstraint(dateGreaterThan(new Date(date), options));
    }
    greaterThanOrEqual(date, options = this.validatorOptions) {
      return this.addConstraint(dateGreaterThanOrEqual(new Date(date), options));
    }
    equal(date, options = this.validatorOptions) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.invalid(options) : this.addConstraint(dateEqual(resolved, options));
    }
    notEqual(date, options = this.validatorOptions) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.valid(options) : this.addConstraint(dateNotEqual(resolved, options));
    }
    valid(options = this.validatorOptions) {
      return this.addConstraint(dateValid(options));
    }
    invalid(options = this.validatorOptions) {
      return this.addConstraint(dateInvalid(options));
    }
    handle(value) {
      return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date()", this.validatorOptions.message ?? "Expected a Date", value));
    }
  };
  __name(_DateValidator, "DateValidator");
  var DateValidator = _DateValidator;
  var _ExpectedValidationError = class _ExpectedValidationError2 extends ValidationError {
    constructor(validator, message, given, expected) {
      super(validator, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        validator: this.validator,
        given: this.given,
        expected: this.expected,
        message: this.message
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const expected = inspect2(this.expected, newOptions).replace(/\n/g, padding);
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_ExpectedValidationError, "ExpectedValidationError");
  var ExpectedValidationError = _ExpectedValidationError;
  var _InstanceValidator = class _InstanceValidator2 extends BaseValidator {
    constructor(expected, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.expected = expected;
    }
    handle(value) {
      return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", this.validatorOptions.message ?? "Expected", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.validatorOptions, this.constraints]);
    }
  };
  __name(_InstanceValidator, "InstanceValidator");
  var InstanceValidator = _InstanceValidator;
  var _LiteralValidator = class _LiteralValidator2 extends BaseValidator {
    constructor(literal, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.expected = literal;
    }
    handle(value) {
      return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", this.validatorOptions.message ?? "Expected values to be equals", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.validatorOptions, this.constraints]);
    }
  };
  __name(_LiteralValidator, "LiteralValidator");
  var LiteralValidator = _LiteralValidator;
  var _NeverValidator = class _NeverValidator2 extends BaseValidator {
    handle(value) {
      return Result.err(new ValidationError("s.never()", this.validatorOptions.message ?? "Expected a value to not be passed", value));
    }
  };
  __name(_NeverValidator, "NeverValidator");
  var NeverValidator = _NeverValidator;
  var _NullishValidator = class _NullishValidator2 extends BaseValidator {
    handle(value) {
      return value === undefined || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish()", this.validatorOptions.message ?? "Expected undefined or null", value));
    }
  };
  __name(_NullishValidator, "NullishValidator");
  var NullishValidator = _NullishValidator;
  function numberComparator(comparator, name, expected, number, options) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid number value", input, expected));
      }
    };
  }
  __name(numberComparator, "numberComparator");
  function numberLessThan(value, options) {
    const expected = `expected < ${value}`;
    return numberComparator(lessThan, "s.number().lessThan()", expected, value, options);
  }
  __name(numberLessThan, "numberLessThan");
  function numberLessThanOrEqual(value, options) {
    const expected = `expected <= ${value}`;
    return numberComparator(lessThanOrEqual, "s.number().lessThanOrEqual()", expected, value, options);
  }
  __name(numberLessThanOrEqual, "numberLessThanOrEqual");
  function numberGreaterThan(value, options) {
    const expected = `expected > ${value}`;
    return numberComparator(greaterThan, "s.number().greaterThan()", expected, value, options);
  }
  __name(numberGreaterThan, "numberGreaterThan");
  function numberGreaterThanOrEqual(value, options) {
    const expected = `expected >= ${value}`;
    return numberComparator(greaterThanOrEqual, "s.number().greaterThanOrEqual()", expected, value, options);
  }
  __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
  function numberEqual(value, options) {
    const expected = `expected === ${value}`;
    return numberComparator(equal, "s.number().equal()", expected, value, options);
  }
  __name(numberEqual, "numberEqual");
  function numberNotEqual(value, options) {
    const expected = `expected !== ${value}`;
    return numberComparator(notEqual, "s.number().notEqual()", expected, value, options);
  }
  __name(numberNotEqual, "numberNotEqual");
  function numberInt(options) {
    return {
      run(input) {
        return Number.isInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().int()", options?.message ?? "Given value is not an integer", input, "Number.isInteger(expected) to be true"));
      }
    };
  }
  __name(numberInt, "numberInt");
  function numberSafeInt(options) {
    return {
      run(input) {
        return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().safeInt()", options?.message ?? "Given value is not a safe integer", input, "Number.isSafeInteger(expected) to be true"));
      }
    };
  }
  __name(numberSafeInt, "numberSafeInt");
  function numberFinite(options) {
    return {
      run(input) {
        return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().finite()", options?.message ?? "Given value is not finite", input, "Number.isFinite(expected) to be true"));
      }
    };
  }
  __name(numberFinite, "numberFinite");
  function numberNaN(options) {
    return {
      run(input) {
        return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().equal(NaN)", options?.message ?? "Invalid number value", input, "expected === NaN"));
      }
    };
  }
  __name(numberNaN, "numberNaN");
  function numberNotNaN(options) {
    return {
      run(input) {
        return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number().notEqual(NaN)", options?.message ?? "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
  }
  __name(numberNotNaN, "numberNotNaN");
  function numberDivisibleBy(divider, options) {
    const expected = `expected % ${divider} === 0`;
    return {
      run(input) {
        return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number().divisibleBy()", options?.message ?? "Number is not divisible", input, expected));
      }
    };
  }
  __name(numberDivisibleBy, "numberDivisibleBy");
  var _NumberValidator = class _NumberValidator2 extends BaseValidator {
    lessThan(number, options = this.validatorOptions) {
      return this.addConstraint(numberLessThan(number, options));
    }
    lessThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(numberLessThanOrEqual(number, options));
    }
    greaterThan(number, options = this.validatorOptions) {
      return this.addConstraint(numberGreaterThan(number, options));
    }
    greaterThanOrEqual(number, options = this.validatorOptions) {
      return this.addConstraint(numberGreaterThanOrEqual(number, options));
    }
    equal(number, options = this.validatorOptions) {
      return Number.isNaN(number) ? this.addConstraint(numberNaN(options)) : this.addConstraint(numberEqual(number, options));
    }
    notEqual(number, options = this.validatorOptions) {
      return Number.isNaN(number) ? this.addConstraint(numberNotNaN(options)) : this.addConstraint(numberNotEqual(number, options));
    }
    int(options = this.validatorOptions) {
      return this.addConstraint(numberInt(options));
    }
    safeInt(options = this.validatorOptions) {
      return this.addConstraint(numberSafeInt(options));
    }
    finite(options = this.validatorOptions) {
      return this.addConstraint(numberFinite(options));
    }
    positive(options = this.validatorOptions) {
      return this.greaterThanOrEqual(0, options);
    }
    negative(options = this.validatorOptions) {
      return this.lessThan(0, options);
    }
    divisibleBy(divider, options = this.validatorOptions) {
      return this.addConstraint(numberDivisibleBy(divider, options));
    }
    abs(options = this.validatorOptions) {
      return this.transform(Math.abs, options);
    }
    sign(options = this.validatorOptions) {
      return this.transform(Math.sign, options);
    }
    trunc(options = this.validatorOptions) {
      return this.transform(Math.trunc, options);
    }
    floor(options = this.validatorOptions) {
      return this.transform(Math.floor, options);
    }
    fround(options = this.validatorOptions) {
      return this.transform(Math.fround, options);
    }
    round(options = this.validatorOptions) {
      return this.transform(Math.round, options);
    }
    ceil(options = this.validatorOptions) {
      return this.transform(Math.ceil, options);
    }
    handle(value) {
      return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number()", this.validatorOptions.message ?? "Expected a number primitive", value));
    }
  };
  __name(_NumberValidator, "NumberValidator");
  var NumberValidator = _NumberValidator;
  var _MissingPropertyError = class _MissingPropertyError2 extends BaseError {
    constructor(property, validatorOptions) {
      super(validatorOptions?.message ?? "A required property is missing");
      this.property = property;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        property: this.property
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[MissingPropertyError: ${property}]`, "special");
      }
      const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      return `${header}
  ${message}`;
    }
  };
  __name(_MissingPropertyError, "MissingPropertyError");
  var MissingPropertyError = _MissingPropertyError;
  var _UnknownPropertyError = class _UnknownPropertyError2 extends BaseError {
    constructor(property, value, options) {
      super(options?.message ?? "Received unexpected property");
      this.property = property;
      this.value = value;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        property: this.property,
        value: this.value
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.value, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(_UnknownPropertyError, "UnknownPropertyError");
  var UnknownPropertyError = _UnknownPropertyError;
  var _DefaultValidator = class _DefaultValidator2 extends BaseValidator {
    constructor(validator, value, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
      this.defaultValue = value;
    }
    default(value, options = this.validatorOptions) {
      const clone = this.clone();
      clone.validatorOptions = options;
      clone.defaultValue = value;
      return clone;
    }
    handle(value) {
      return typeof value === "undefined" ? Result.ok(getValue(this.defaultValue)) : this.validator["handle"](value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.validatorOptions, this.constraints]);
    }
  };
  __name(_DefaultValidator, "DefaultValidator");
  var DefaultValidator = _DefaultValidator;
  var _CombinedError = class _CombinedError2 extends BaseError {
    constructor(errors, validatorOptions) {
      super(validatorOptions?.message ?? "Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map((error, i3) => {
        const index = options.stylize((i3 + 1).toString(), "number");
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  ${index} ${body}`;
      }).join(`

`);
      return `${header}
  ${message}

${errors}`;
    }
  };
  __name(_CombinedError, "CombinedError");
  var CombinedError = _CombinedError;
  var _UnionValidator = class _UnionValidator2 extends BaseValidator {
    constructor(validators, validatorOptions, constraints = []) {
      super(validatorOptions, constraints);
      this.validators = validators;
    }
    optional(options = this.validatorOptions) {
      if (this.validators.length === 0)
        return new _UnionValidator2([new LiteralValidator(undefined, options)], this.validatorOptions, this.constraints);
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined)
          return this.clone();
        if (validator.expected === null) {
          return new _UnionValidator2([new NullishValidator(options), ...this.validators.slice(1)], this.validatorOptions, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new LiteralValidator(undefined, options), ...this.validators], this.validatorOptions);
    }
    required(options = this.validatorOptions) {
      if (this.validators.length === 0)
        return this.clone();
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined) {
          return new _UnionValidator2(this.validators.slice(1), this.validatorOptions, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return new _UnionValidator2([new LiteralValidator(null, options), ...this.validators.slice(1)], this.validatorOptions, this.constraints);
      }
      return this.clone();
    }
    nullable(options = this.validatorOptions) {
      if (this.validators.length === 0) {
        return new _UnionValidator2([new LiteralValidator(null, options)], this.validatorOptions, this.constraints);
      }
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null)
          return this.clone();
        if (validator.expected === undefined) {
          return new _UnionValidator2([new NullishValidator(options), ...this.validators.slice(1)], this.validatorOptions, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new LiteralValidator(null, options), ...this.validators], this.validatorOptions);
    }
    nullish(options = this.validatorOptions) {
      if (this.validators.length === 0) {
        return new _UnionValidator2([new NullishValidator(options)], options, this.constraints);
      }
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null || validator.expected === undefined) {
          return new _UnionValidator2([new NullishValidator(options), ...this.validators.slice(1)], options, this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new NullishValidator(options), ...this.validators], options);
    }
    or(...predicates) {
      return new _UnionValidator2([...this.validators, ...predicates], this.validatorOptions);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      const errors = [];
      for (const validator of this.validators) {
        const result = validator.run(value);
        if (result.isOk())
          return result;
        errors.push(result.error);
      }
      return Result.err(new CombinedError(errors, this.validatorOptions));
    }
  };
  __name(_UnionValidator, "UnionValidator");
  var UnionValidator = _UnionValidator;
  var _ObjectValidator = class _ObjectValidator2 extends BaseValidator {
    constructor(shape, strategy = 0, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.keys = [];
      this.requiredKeys = /* @__PURE__ */ new Map;
      this.possiblyUndefinedKeys = /* @__PURE__ */ new Map;
      this.possiblyUndefinedKeysWithDefaults = /* @__PURE__ */ new Map;
      this.shape = shape;
      this.strategy = strategy;
      switch (this.strategy) {
        case 0:
          this.handleStrategy = (value) => this.handleIgnoreStrategy(value);
          break;
        case 1: {
          this.handleStrategy = (value) => this.handleStrictStrategy(value);
          break;
        }
        case 2:
          this.handleStrategy = (value) => this.handlePassthroughStrategy(value);
          break;
      }
      const shapeEntries = Object.entries(shape);
      this.keys = shapeEntries.map(([key]) => key);
      for (const [key, validator] of shapeEntries) {
        if (validator instanceof UnionValidator) {
          const [possiblyLiteralOrNullishPredicate] = validator["validators"];
          if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {
            if (possiblyLiteralOrNullishPredicate.expected === undefined) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof DefaultValidator) {
            this.possiblyUndefinedKeysWithDefaults.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof NullishValidator) {
          this.possiblyUndefinedKeys.set(key, validator);
        } else if (validator instanceof LiteralValidator) {
          if (validator.expected === undefined) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof DefaultValidator) {
          this.possiblyUndefinedKeysWithDefaults.set(key, validator);
        } else {
          this.requiredKeys.set(key, validator);
        }
      }
    }
    strict(options = this.validatorOptions) {
      return Reflect.construct(this.constructor, [this.shape, 1, options, this.constraints]);
    }
    ignore(options = this.validatorOptions) {
      return Reflect.construct(this.constructor, [this.shape, 0, options, this.constraints]);
    }
    passthrough(options = this.validatorOptions) {
      return Reflect.construct(this.constructor, [this.shape, 2, options, this.constraints]);
    }
    partial(options = this.validatorOptions) {
      const shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional(options)]));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    required(options = this.validatorOptions) {
      const shape = Object.fromEntries(this.keys.map((key) => {
        let validator = this.shape[key];
        if (validator instanceof UnionValidator)
          validator = validator.required(options);
        return [key, validator];
      }));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    extend(schema, options = this.validatorOptions) {
      const shape = { ...this.shape, ...schema instanceof _ObjectValidator2 ? schema.shape : schema };
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    pick(keys, options = this.validatorOptions) {
      const shape = Object.fromEntries(keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    omit(keys, options = this.validatorOptions) {
      const shape = Object.fromEntries(this.keys.filter((key) => !keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, options, this.constraints]);
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue !== "object") {
        return Result.err(new ValidationError("s.object(T)", this.validatorOptions.message ?? `Expected the value to be an object, but received ${typeOfValue} instead`, value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.object(T)", this.validatorOptions.message ?? "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.object(T)", this.validatorOptions.message ?? "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      for (const predicate of Object.values(this.shape)) {
        predicate.setParent(this.parent ?? value);
      }
      return this.handleStrategy(value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.shape, this.strategy, this.validatorOptions, this.constraints]);
    }
    handleIgnoreStrategy(value) {
      const errors = [];
      const finalObject = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = /* @__PURE__ */ __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalObject[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key, this.validatorOptions)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      if (inputEntries.size === 0) {
        return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
      }
      const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;
      if (checkInputEntriesInsteadOfSchemaKeys) {
        for (const [key] of inputEntries) {
          const predicate = this.possiblyUndefinedKeys.get(key);
          if (predicate) {
            runPredicate(key, predicate);
          }
        }
      } else {
        for (const [key, predicate] of this.possiblyUndefinedKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          }
        }
      }
      return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
    handleStrictStrategy(value) {
      const errors = [];
      const finalResult = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = /* @__PURE__ */ __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalResult[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key, this.validatorOptions)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      for (const [key, predicate] of this.possiblyUndefinedKeys) {
        if (inputEntries.size === 0) {
          break;
        }
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        }
      }
      if (inputEntries.size !== 0) {
        for (const [key, value2] of inputEntries.entries()) {
          errors.push([key, new UnknownPropertyError(key, value2, this.validatorOptions)]);
        }
      }
      return errors.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
    handlePassthroughStrategy(value) {
      const result = this.handleIgnoreStrategy(value);
      return result.isErr() ? result : Result.ok({ ...value, ...result.value });
    }
  };
  __name(_ObjectValidator, "ObjectValidator");
  var ObjectValidator = _ObjectValidator;
  var _PassthroughValidator = class _PassthroughValidator2 extends BaseValidator {
    handle(value) {
      return Result.ok(value);
    }
  };
  __name(_PassthroughValidator, "PassthroughValidator");
  var PassthroughValidator = _PassthroughValidator;
  var _RecordValidator = class _RecordValidator2 extends BaseValidator {
    constructor(validator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      if (typeof value !== "object") {
        return Result.err(new ValidationError("s.record(T)", this.validatorOptions.message ?? "Expected an object", value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.record(T)", this.validatorOptions.message ?? "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.record(T)", this.validatorOptions.message ?? "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = {};
      for (const [key, val] of Object.entries(value)) {
        const result = this.validator.run(val);
        if (result.isOk())
          transformed[key] = result.value;
        else
          errors.push([key, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_RecordValidator, "RecordValidator");
  var RecordValidator = _RecordValidator;
  var _SetValidator = class _SetValidator2 extends BaseValidator {
    constructor(validator, validatorOptions, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      if (!(values instanceof Set)) {
        return Result.err(new ValidationError("s.set(T)", this.validatorOptions.message ?? "Expected a set", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = /* @__PURE__ */ new Set;
      for (const value of values) {
        const result = this.validator.run(value);
        if (result.isOk())
          transformed.add(result.value);
        else
          errors.push(result.error);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors, this.validatorOptions));
    }
  };
  __name(_SetValidator, "SetValidator");
  var SetValidator = _SetValidator;
  var accountRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]$/i;
  function validateEmail(email) {
    if (!email)
      return false;
    const atIndex = email.indexOf("@");
    if (atIndex === -1)
      return false;
    if (atIndex > 64)
      return false;
    const domainIndex = atIndex + 1;
    if (email.includes("@", domainIndex))
      return false;
    if (email.length - domainIndex > 255)
      return false;
    let dotIndex = email.indexOf(".", domainIndex);
    if (dotIndex === -1)
      return false;
    let lastDotIndex = domainIndex;
    do {
      if (dotIndex - lastDotIndex > 63)
        return false;
      lastDotIndex = dotIndex + 1;
    } while ((dotIndex = email.indexOf(".", lastDotIndex)) !== -1);
    if (email.length - lastDotIndex > 63)
      return false;
    return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));
  }
  __name(validateEmail, "validateEmail");
  function validateEmailDomain(domain) {
    try {
      return new URL(`http://${domain}`).hostname === domain;
    } catch {
      return false;
    }
  }
  __name(validateEmailDomain, "validateEmailDomain");
  var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
  var IPv4Reg = new RegExp(`^${v4Str}$`);
  var v6Seg = "(?:[0-9a-fA-F]{1,4})";
  var IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);
  function isIPv4(s4) {
    return IPv4Reg.test(s4);
  }
  __name(isIPv4, "isIPv4");
  function isIPv6(s4) {
    return IPv6Reg.test(s4);
  }
  __name(isIPv6, "isIPv6");
  function isIP(s4) {
    if (isIPv4(s4))
      return 4;
    if (isIPv6(s4))
      return 6;
    return 0;
  }
  __name(isIP, "isIP");
  var phoneNumberRegex = /^((?:\+|0{0,2})\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;
  function validatePhoneNumber(input) {
    return phoneNumberRegex.test(input);
  }
  __name(validatePhoneNumber, "validatePhoneNumber");
  var _MultiplePossibilitiesConstraintError = class _MultiplePossibilitiesConstraintError2 extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const verticalLine = options.stylize("|", "undefined");
      const padding = `
  ${verticalLine} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("MultiplePossibilitiesConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedPadding = `
  ${verticalLine} - `;
      const expectedBlock = `
  ${options.stylize("Expected any of the following:", "string")}${expectedPadding}${this.expected.map((possible) => options.stylize(possible, "boolean")).join(expectedPadding)}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_MultiplePossibilitiesConstraintError, "MultiplePossibilitiesConstraintError");
  var MultiplePossibilitiesConstraintError = _MultiplePossibilitiesConstraintError;
  function combinedErrorFn(...fns) {
    switch (fns.length) {
      case 0:
        return () => null;
      case 1:
        return fns[0];
      case 2: {
        const [fn0, fn1] = fns;
        return (...params) => fn0(...params) || fn1(...params);
      }
      default: {
        return (...params) => {
          for (const fn of fns) {
            const result = fn(...params);
            if (result)
              return result;
          }
          return null;
        };
      }
    }
  }
  __name(combinedErrorFn, "combinedErrorFn");
  function createUrlValidators(options, validatorOptions) {
    const fns = [];
    if (options?.allowedProtocols?.length)
      fns.push(allowedProtocolsFn(options.allowedProtocols, validatorOptions));
    if (options?.allowedDomains?.length)
      fns.push(allowedDomainsFn(options.allowedDomains, validatorOptions));
    return combinedErrorFn(...fns);
  }
  __name(createUrlValidators, "createUrlValidators");
  function allowedProtocolsFn(allowedProtocols, options) {
    return (input, url) => allowedProtocols.includes(url.protocol) ? null : new MultiplePossibilitiesConstraintError("s.string().url()", options?.message ?? "Invalid URL protocol", input, allowedProtocols);
  }
  __name(allowedProtocolsFn, "allowedProtocolsFn");
  function allowedDomainsFn(allowedDomains, options) {
    return (input, url) => allowedDomains.includes(url.hostname) ? null : new MultiplePossibilitiesConstraintError("s.string().url()", options?.message ?? "Invalid URL domain", input, allowedDomains);
  }
  __name(allowedDomainsFn, "allowedDomainsFn");
  function stringLengthComparator(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid string length", input, expected));
      }
    };
  }
  __name(stringLengthComparator, "stringLengthComparator");
  function stringLengthLessThan(length, options) {
    const expected = `expected.length < ${length}`;
    return stringLengthComparator(lessThan, "s.string().lengthLessThan()", expected, length, options);
  }
  __name(stringLengthLessThan, "stringLengthLessThan");
  function stringLengthLessThanOrEqual(length, options) {
    const expected = `expected.length <= ${length}`;
    return stringLengthComparator(lessThanOrEqual, "s.string().lengthLessThanOrEqual()", expected, length, options);
  }
  __name(stringLengthLessThanOrEqual, "stringLengthLessThanOrEqual");
  function stringLengthGreaterThan(length, options) {
    const expected = `expected.length > ${length}`;
    return stringLengthComparator(greaterThan, "s.string().lengthGreaterThan()", expected, length, options);
  }
  __name(stringLengthGreaterThan, "stringLengthGreaterThan");
  function stringLengthGreaterThanOrEqual(length, options) {
    const expected = `expected.length >= ${length}`;
    return stringLengthComparator(greaterThanOrEqual, "s.string().lengthGreaterThanOrEqual()", expected, length, options);
  }
  __name(stringLengthGreaterThanOrEqual, "stringLengthGreaterThanOrEqual");
  function stringLengthEqual(length, options) {
    const expected = `expected.length === ${length}`;
    return stringLengthComparator(equal, "s.string().lengthEqual()", expected, length, options);
  }
  __name(stringLengthEqual, "stringLengthEqual");
  function stringLengthNotEqual(length, options) {
    const expected = `expected.length !== ${length}`;
    return stringLengthComparator(notEqual, "s.string().lengthNotEqual()", expected, length, options);
  }
  __name(stringLengthNotEqual, "stringLengthNotEqual");
  function stringEmail(options) {
    return {
      run(input) {
        return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string().email()", options?.message ?? "Invalid email address", input, "expected to be an email address"));
      }
    };
  }
  __name(stringEmail, "stringEmail");
  function stringRegexValidator(type, expected, regex, options) {
    return {
      run(input) {
        return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, options?.message ?? "Invalid string format", input, expected));
      }
    };
  }
  __name(stringRegexValidator, "stringRegexValidator");
  function stringUrl(options, validatorOptions) {
    const validatorFn = createUrlValidators(options, validatorOptions);
    return {
      run(input) {
        let url;
        try {
          url = new URL(input);
        } catch {
          return Result.err(new ExpectedConstraintError("s.string().url()", validatorOptions?.message ?? "Invalid URL", input, "expected to match a URL"));
        }
        const validatorFnResult = validatorFn(input, url);
        if (validatorFnResult === null)
          return Result.ok(input);
        return Result.err(validatorFnResult);
      }
    };
  }
  __name(stringUrl, "stringUrl");
  function stringIp(version, options) {
    const ipVersion = version ? `v${version}` : "";
    const validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;
    const name = `s.string().ip${ipVersion}()`;
    const message = `Invalid IP${ipVersion} address`;
    const expected = `expected to be an IP${ipVersion} address`;
    return {
      run(input) {
        return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? message, input, expected));
      }
    };
  }
  __name(stringIp, "stringIp");
  function stringRegex(regex, options) {
    return stringRegexValidator("s.string().regex()", `expected ${regex}.test(expected) to be true`, regex, options);
  }
  __name(stringRegex, "stringRegex");
  function stringUuid({ version = 4, nullable = false } = {}, options) {
    version ?? (version = "1-5");
    const regex = new RegExp(`^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? "|00000000-0000-0000-0000-000000000000" : ""})$`, "i");
    const expected = `expected to match UUID${typeof version === "number" ? `v${version}` : ` in range of ${version}`}`;
    return stringRegexValidator("s.string().uuid()", expected, regex, options);
  }
  __name(stringUuid, "stringUuid");
  function stringDate(options) {
    return {
      run(input) {
        const time = Date.parse(input);
        return Number.isNaN(time) ? Result.err(new ExpectedConstraintError("s.string().date()", options?.message ?? "Invalid date string", input, "expected to be a valid date string (in the ISO 8601 or ECMA-262 format)")) : Result.ok(input);
      }
    };
  }
  __name(stringDate, "stringDate");
  function stringPhone(options) {
    return {
      run(input) {
        return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string().phone()", options?.message ?? "Invalid phone number", input, "expected to be a phone number"));
      }
    };
  }
  __name(stringPhone, "stringPhone");
  var _StringValidator = class _StringValidator2 extends BaseValidator {
    lengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthLessThan(length, options));
    }
    lengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthLessThanOrEqual(length, options));
    }
    lengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthGreaterThan(length, options));
    }
    lengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthGreaterThanOrEqual(length, options));
    }
    lengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthEqual(length, options));
    }
    lengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(stringLengthNotEqual(length, options));
    }
    email(options = this.validatorOptions) {
      return this.addConstraint(stringEmail(options));
    }
    url(options, validatorOptions = this.validatorOptions) {
      const urlOptions = this.isUrlOptions(options);
      if (urlOptions) {
        return this.addConstraint(stringUrl(options, validatorOptions));
      }
      return this.addConstraint(stringUrl(undefined, validatorOptions));
    }
    uuid(options, validatorOptions = this.validatorOptions) {
      const stringUuidOptions = this.isStringUuidOptions(options);
      if (stringUuidOptions) {
        return this.addConstraint(stringUuid(options, validatorOptions));
      }
      return this.addConstraint(stringUuid(undefined, validatorOptions));
    }
    regex(regex, options = this.validatorOptions) {
      return this.addConstraint(stringRegex(regex, options));
    }
    date(options = this.validatorOptions) {
      return this.addConstraint(stringDate(options));
    }
    ipv4(options = this.validatorOptions) {
      return this.ip(4, options);
    }
    ipv6(options = this.validatorOptions) {
      return this.ip(6, options);
    }
    ip(version, options = this.validatorOptions) {
      return this.addConstraint(stringIp(version, options));
    }
    phone(options = this.validatorOptions) {
      return this.addConstraint(stringPhone(options));
    }
    handle(value) {
      return typeof value === "string" ? Result.ok(value) : Result.err(new ValidationError("s.string()", this.validatorOptions.message ?? "Expected a string primitive", value));
    }
    isUrlOptions(options) {
      return options?.message === undefined;
    }
    isStringUuidOptions(options) {
      return options?.message === undefined;
    }
  };
  __name(_StringValidator, "StringValidator");
  var StringValidator = _StringValidator;
  var _TupleValidator = class _TupleValidator2 extends BaseValidator {
    constructor(validators, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validators = [];
      this.validators = validators;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.tuple(T)", this.validatorOptions.message ?? "Expected an array", values));
      }
      if (values.length !== this.validators.length) {
        return Result.err(new ValidationError("s.tuple(T)", this.validatorOptions.message ?? `Expected an array of length ${this.validators.length}`, values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i3 = 0;i3 < values.length; i3++) {
        const result = this.validators[i3].run(values[i3]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i3, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_TupleValidator, "TupleValidator");
  var TupleValidator = _TupleValidator;
  var _MapValidator = class _MapValidator2 extends BaseValidator {
    constructor(keyValidator, valueValidator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.keyValidator = keyValidator;
      this.valueValidator = valueValidator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      if (!(value instanceof Map)) {
        return Result.err(new ValidationError("s.map(K, V)", this.validatorOptions.message ?? "Expected a map", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = /* @__PURE__ */ new Map;
      for (const [key, val] of value.entries()) {
        const keyResult = this.keyValidator.run(key);
        const valueResult = this.valueValidator.run(val);
        const { length } = errors;
        if (keyResult.isErr())
          errors.push([key, keyResult.error]);
        if (valueResult.isErr())
          errors.push([key, valueResult.error]);
        if (errors.length === length)
          transformed.set(keyResult.value, valueResult.value);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors, this.validatorOptions));
    }
  };
  __name(_MapValidator, "MapValidator");
  var MapValidator = _MapValidator;
  var _LazyValidator = class _LazyValidator2 extends BaseValidator {
    constructor(validator, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.validatorOptions, this.constraints]);
    }
    handle(values) {
      return this.validator(values).run(values);
    }
  };
  __name(_LazyValidator, "LazyValidator");
  var LazyValidator = _LazyValidator;
  var _UnknownEnumValueError = class _UnknownEnumValueError2 extends BaseError {
    constructor(value, keys, enumMappings, validatorOptions) {
      super(validatorOptions?.message ?? "Expected the value to be one of the following enum values:");
      this.value = value;
      this.enumKeys = keys;
      this.enumMappings = enumMappings;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        value: this.value,
        enumKeys: this.enumKeys,
        enumMappings: [...this.enumMappings.entries()]
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const value = options.stylize(this.value.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownEnumValueError: ${value}]`, "special");
      }
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const pairs = this.enumKeys.map((key) => {
        const enumValue = this.enumMappings.get(key);
        return `${options.stylize(key, "string")} or ${options.stylize(enumValue.toString(), typeof enumValue === "number" ? "number" : "string")}`;
      }).join(padding);
      const header = `${options.stylize("UnknownEnumValueError", "special")} > ${value}`;
      const message = options.stylize(this.message, "regexp");
      const pairsBlock = `${padding}${pairs}`;
      return `${header}
  ${message}
${pairsBlock}`;
    }
  };
  __name(_UnknownEnumValueError, "UnknownEnumValueError");
  var UnknownEnumValueError = _UnknownEnumValueError;
  var _NativeEnumValidator = class _NativeEnumValidator2 extends BaseValidator {
    constructor(enumShape, validatorOptions = {}) {
      super(validatorOptions);
      this.hasNumericElements = false;
      this.enumMapping = /* @__PURE__ */ new Map;
      this.enumShape = enumShape;
      this.enumKeys = Object.keys(enumShape).filter((key) => {
        return typeof enumShape[enumShape[key]] !== "number";
      });
      for (const key of this.enumKeys) {
        const enumValue = enumShape[key];
        this.enumMapping.set(key, enumValue);
        this.enumMapping.set(enumValue, enumValue);
        if (typeof enumValue === "number") {
          this.hasNumericElements = true;
          this.enumMapping.set(`${enumValue}`, enumValue);
        }
      }
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue === "number") {
        if (!this.hasNumericElements) {
          return Result.err(new ValidationError("s.nativeEnum(T)", this.validatorOptions.message ?? "Expected the value to be a string", value));
        }
      } else if (typeOfValue !== "string") {
        return Result.err(new ValidationError("s.nativeEnum(T)", this.validatorOptions.message ?? "Expected the value to be a string or number", value));
      }
      const casted = value;
      const possibleEnumValue = this.enumMapping.get(casted);
      return typeof possibleEnumValue === "undefined" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping, this.validatorOptions)) : Result.ok(possibleEnumValue);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.enumShape, this.validatorOptions]);
    }
  };
  __name(_NativeEnumValidator, "NativeEnumValidator");
  var NativeEnumValidator = _NativeEnumValidator;
  function typedArrayByteLengthComparator(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  }
  __name(typedArrayByteLengthComparator, "typedArrayByteLengthComparator");
  function typedArrayByteLengthLessThan(value, options) {
    const expected = `expected.byteLength < ${value}`;
    return typedArrayByteLengthComparator(lessThan, "s.typedArray(T).byteLengthLessThan()", expected, value, options);
  }
  __name(typedArrayByteLengthLessThan, "typedArrayByteLengthLessThan");
  function typedArrayByteLengthLessThanOrEqual(value, options) {
    const expected = `expected.byteLength <= ${value}`;
    return typedArrayByteLengthComparator(lessThanOrEqual, "s.typedArray(T).byteLengthLessThanOrEqual()", expected, value, options);
  }
  __name(typedArrayByteLengthLessThanOrEqual, "typedArrayByteLengthLessThanOrEqual");
  function typedArrayByteLengthGreaterThan(value, options) {
    const expected = `expected.byteLength > ${value}`;
    return typedArrayByteLengthComparator(greaterThan, "s.typedArray(T).byteLengthGreaterThan()", expected, value, options);
  }
  __name(typedArrayByteLengthGreaterThan, "typedArrayByteLengthGreaterThan");
  function typedArrayByteLengthGreaterThanOrEqual(value, options) {
    const expected = `expected.byteLength >= ${value}`;
    return typedArrayByteLengthComparator(greaterThanOrEqual, "s.typedArray(T).byteLengthGreaterThanOrEqual()", expected, value, options);
  }
  __name(typedArrayByteLengthGreaterThanOrEqual, "typedArrayByteLengthGreaterThanOrEqual");
  function typedArrayByteLengthEqual(value, options) {
    const expected = `expected.byteLength === ${value}`;
    return typedArrayByteLengthComparator(equal, "s.typedArray(T).byteLengthEqual()", expected, value, options);
  }
  __name(typedArrayByteLengthEqual, "typedArrayByteLengthEqual");
  function typedArrayByteLengthNotEqual(value, options) {
    const expected = `expected.byteLength !== ${value}`;
    return typedArrayByteLengthComparator(notEqual, "s.typedArray(T).byteLengthNotEqual()", expected, value, options);
  }
  __name(typedArrayByteLengthNotEqual, "typedArrayByteLengthNotEqual");
  function typedArrayByteLengthRange(start, endBefore, options) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRange()", options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  }
  __name(typedArrayByteLengthRange, "typedArrayByteLengthRange");
  function typedArrayByteLengthRangeInclusive(start, end, options) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeInclusive()", options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  }
  __name(typedArrayByteLengthRangeInclusive, "typedArrayByteLengthRangeInclusive");
  function typedArrayByteLengthRangeExclusive(startAfter, endBefore, options) {
    const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeExclusive()", options?.message ?? "Invalid Typed Array byte length", input, expected));
      }
    };
  }
  __name(typedArrayByteLengthRangeExclusive, "typedArrayByteLengthRangeExclusive");
  function typedArrayLengthComparator(comparator, name, expected, length, options) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  }
  __name(typedArrayLengthComparator, "typedArrayLengthComparator");
  function typedArrayLengthLessThan(value, options) {
    const expected = `expected.length < ${value}`;
    return typedArrayLengthComparator(lessThan, "s.typedArray(T).lengthLessThan()", expected, value, options);
  }
  __name(typedArrayLengthLessThan, "typedArrayLengthLessThan");
  function typedArrayLengthLessThanOrEqual(value, options) {
    const expected = `expected.length <= ${value}`;
    return typedArrayLengthComparator(lessThanOrEqual, "s.typedArray(T).lengthLessThanOrEqual()", expected, value, options);
  }
  __name(typedArrayLengthLessThanOrEqual, "typedArrayLengthLessThanOrEqual");
  function typedArrayLengthGreaterThan(value, options) {
    const expected = `expected.length > ${value}`;
    return typedArrayLengthComparator(greaterThan, "s.typedArray(T).lengthGreaterThan()", expected, value, options);
  }
  __name(typedArrayLengthGreaterThan, "typedArrayLengthGreaterThan");
  function typedArrayLengthGreaterThanOrEqual(value, options) {
    const expected = `expected.length >= ${value}`;
    return typedArrayLengthComparator(greaterThanOrEqual, "s.typedArray(T).lengthGreaterThanOrEqual()", expected, value, options);
  }
  __name(typedArrayLengthGreaterThanOrEqual, "typedArrayLengthGreaterThanOrEqual");
  function typedArrayLengthEqual(value, options) {
    const expected = `expected.length === ${value}`;
    return typedArrayLengthComparator(equal, "s.typedArray(T).lengthEqual()", expected, value, options);
  }
  __name(typedArrayLengthEqual, "typedArrayLengthEqual");
  function typedArrayLengthNotEqual(value, options) {
    const expected = `expected.length !== ${value}`;
    return typedArrayLengthComparator(notEqual, "s.typedArray(T).lengthNotEqual()", expected, value, options);
  }
  __name(typedArrayLengthNotEqual, "typedArrayLengthNotEqual");
  function typedArrayLengthRange(start, endBefore, options) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRange()", options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  }
  __name(typedArrayLengthRange, "typedArrayLengthRange");
  function typedArrayLengthRangeInclusive(start, end, options) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeInclusive()", options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  }
  __name(typedArrayLengthRangeInclusive, "typedArrayLengthRangeInclusive");
  function typedArrayLengthRangeExclusive(startAfter, endBefore, options) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeExclusive()", options?.message ?? "Invalid Typed Array length", input, expected));
      }
    };
  }
  __name(typedArrayLengthRangeExclusive, "typedArrayLengthRangeExclusive");
  var vowels = ["a", "e", "i", "o", "u"];
  var aOrAn = /* @__PURE__ */ __name((word) => {
    return `${vowels.includes(word[0].toLowerCase()) ? "an" : "a"} ${word}`;
  }, "aOrAn");
  var TypedArrays = {
    Int8Array: (x2) => x2 instanceof Int8Array,
    Uint8Array: (x2) => x2 instanceof Uint8Array,
    Uint8ClampedArray: (x2) => x2 instanceof Uint8ClampedArray,
    Int16Array: (x2) => x2 instanceof Int16Array,
    Uint16Array: (x2) => x2 instanceof Uint16Array,
    Int32Array: (x2) => x2 instanceof Int32Array,
    Uint32Array: (x2) => x2 instanceof Uint32Array,
    Float32Array: (x2) => x2 instanceof Float32Array,
    Float64Array: (x2) => x2 instanceof Float64Array,
    BigInt64Array: (x2) => x2 instanceof BigInt64Array,
    BigUint64Array: (x2) => x2 instanceof BigUint64Array,
    TypedArray: (x2) => ArrayBuffer.isView(x2) && !(x2 instanceof DataView)
  };
  var _TypedArrayValidator = class _TypedArrayValidator2 extends BaseValidator {
    constructor(type, validatorOptions = {}, constraints = []) {
      super(validatorOptions, constraints);
      this.type = type;
    }
    byteLengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthLessThan(length, options));
    }
    byteLengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length, options));
    }
    byteLengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthGreaterThan(length, options));
    }
    byteLengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length, options));
    }
    byteLengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthEqual(length, options));
    }
    byteLengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthNotEqual(length, options));
    }
    byteLengthRange(start, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthRange(start, endBefore, options));
    }
    byteLengthRangeInclusive(startAt, endAt, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt, options));
    }
    byteLengthRangeExclusive(startAfter, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore, options));
    }
    lengthLessThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthLessThan(length, options));
    }
    lengthLessThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthLessThanOrEqual(length, options));
    }
    lengthGreaterThan(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthGreaterThan(length, options));
    }
    lengthGreaterThanOrEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length, options));
    }
    lengthEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthEqual(length, options));
    }
    lengthNotEqual(length, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthNotEqual(length, options));
    }
    lengthRange(start, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthRange(start, endBefore, options));
    }
    lengthRangeInclusive(startAt, endAt, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt, options));
    }
    lengthRangeExclusive(startAfter, endBefore, options = this.validatorOptions) {
      return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore, options));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.type, this.validatorOptions, this.constraints]);
    }
    handle(value) {
      return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError("s.typedArray()", this.validatorOptions.message ?? `Expected ${aOrAn(this.type)}`, value));
    }
  };
  __name(_TypedArrayValidator, "TypedArrayValidator");
  var TypedArrayValidator = _TypedArrayValidator;
  var _Shapes = class _Shapes2 {
    string(options) {
      return new StringValidator(options);
    }
    number(options) {
      return new NumberValidator(options);
    }
    bigint(options) {
      return new BigIntValidator(options);
    }
    boolean(options) {
      return new BooleanValidator(options);
    }
    date(options) {
      return new DateValidator(options);
    }
    object(shape, options) {
      return new ObjectValidator(shape, 0, options);
    }
    undefined(options) {
      return this.literal(undefined, { equalsOptions: options });
    }
    null(options) {
      return this.literal(null, { equalsOptions: options });
    }
    nullish(options) {
      return new NullishValidator(options);
    }
    any(options) {
      return new PassthroughValidator(options);
    }
    unknown(options) {
      return new PassthroughValidator(options);
    }
    never(options) {
      return new NeverValidator(options);
    }
    enum(values, options) {
      return this.union(values.map((value) => this.literal(value, { equalsOptions: options })), options);
    }
    nativeEnum(enumShape, options) {
      return new NativeEnumValidator(enumShape, options);
    }
    literal(value, options) {
      if (value instanceof Date) {
        return this.date(options?.dateOptions).equal(value, options?.equalsOptions);
      }
      return new LiteralValidator(value, options?.equalsOptions);
    }
    instance(expected, options) {
      return new InstanceValidator(expected, options);
    }
    union(validators, options) {
      return new UnionValidator(validators, options);
    }
    array(validator, options) {
      return new ArrayValidator(validator, options);
    }
    typedArray(type = "TypedArray", options) {
      return new TypedArrayValidator(type, options);
    }
    int8Array(options) {
      return this.typedArray("Int8Array", options);
    }
    uint8Array(options) {
      return this.typedArray("Uint8Array", options);
    }
    uint8ClampedArray(options) {
      return this.typedArray("Uint8ClampedArray", options);
    }
    int16Array(options) {
      return this.typedArray("Int16Array", options);
    }
    uint16Array(options) {
      return this.typedArray("Uint16Array", options);
    }
    int32Array(options) {
      return this.typedArray("Int32Array", options);
    }
    uint32Array(options) {
      return this.typedArray("Uint32Array", options);
    }
    float32Array(options) {
      return this.typedArray("Float32Array", options);
    }
    float64Array(options) {
      return this.typedArray("Float64Array", options);
    }
    bigInt64Array(options) {
      return this.typedArray("BigInt64Array", options);
    }
    bigUint64Array(options) {
      return this.typedArray("BigUint64Array", options);
    }
    tuple(validators, options) {
      return new TupleValidator(validators, options);
    }
    set(validator, options) {
      return new SetValidator(validator, options);
    }
    record(validator, options) {
      return new RecordValidator(validator, options);
    }
    map(keyValidator, valueValidator, options) {
      return new MapValidator(keyValidator, valueValidator, options);
    }
    lazy(validator, options) {
      return new LazyValidator(validator, options);
    }
  };
  __name(_Shapes, "Shapes");
  var Shapes = _Shapes;
  var s3 = new Shapes;
  exports.BaseError = BaseError;
  exports.CombinedError = CombinedError;
  exports.CombinedPropertyError = CombinedPropertyError;
  exports.ExpectedConstraintError = ExpectedConstraintError;
  exports.ExpectedValidationError = ExpectedValidationError;
  exports.MissingPropertyError = MissingPropertyError;
  exports.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;
  exports.Result = Result;
  exports.UnknownEnumValueError = UnknownEnumValueError;
  exports.UnknownPropertyError = UnknownPropertyError;
  exports.ValidationError = ValidationError;
  exports.customInspectSymbol = customInspectSymbol;
  exports.customInspectSymbolStackLess = customInspectSymbolStackLess;
  exports.getGlobalValidationEnabled = getGlobalValidationEnabled;
  exports.s = s3;
  exports.setGlobalValidationEnabled = setGlobalValidationEnabled;
});

// ../../node_modules/ts-mixer/dist/cjs/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatten = exports.unique = exports.hardMixProtos = exports.nearestCommonProto = exports.protoChain = exports.copyProps = undefined;
  var copyProps = (dest, src, exclude = []) => {
    const props = Object.getOwnPropertyDescriptors(src);
    for (let prop of exclude)
      delete props[prop];
    Object.defineProperties(dest, props);
  };
  exports.copyProps = copyProps;
  var protoChain = (obj, currentChain = [obj]) => {
    const proto = Object.getPrototypeOf(obj);
    if (proto === null)
      return currentChain;
    return (0, exports.protoChain)(proto, [...currentChain, proto]);
  };
  exports.protoChain = protoChain;
  var nearestCommonProto = (...objs) => {
    if (objs.length === 0)
      return;
    let commonProto = undefined;
    const protoChains = objs.map((obj) => (0, exports.protoChain)(obj));
    while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
      const protos = protoChains.map((protoChain2) => protoChain2.pop());
      const potentialCommonProto = protos[0];
      if (protos.every((proto) => proto === potentialCommonProto))
        commonProto = potentialCommonProto;
      else
        break;
    }
    return commonProto;
  };
  exports.nearestCommonProto = nearestCommonProto;
  var hardMixProtos = (ingredients, constructor, exclude = []) => {
    var _a;
    const base = (_a = (0, exports.nearestCommonProto)(...ingredients)) !== null && _a !== undefined ? _a : Object.prototype;
    const mixedProto = Object.create(base);
    const visitedProtos = (0, exports.protoChain)(base);
    for (let prototype of ingredients) {
      let protos = (0, exports.protoChain)(prototype);
      for (let i = protos.length - 1;i >= 0; i--) {
        let newProto = protos[i];
        if (visitedProtos.indexOf(newProto) === -1) {
          (0, exports.copyProps)(mixedProto, newProto, ["constructor", ...exclude]);
          visitedProtos.push(newProto);
        }
      }
    }
    mixedProto.constructor = constructor;
    return mixedProto;
  };
  exports.hardMixProtos = hardMixProtos;
  var unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
  exports.unique = unique;
  var flatten = (arr) => arr.length === 0 ? [] : arr.length === 1 ? arr[0] : arr.reduce((a1, a2) => [...a1, ...a2]);
  exports.flatten = flatten;
});

// ../../node_modules/ts-mixer/dist/cjs/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.softMixProtos = exports.proxyMix = exports.getIngredientWithProp = undefined;
  var util_1 = require_util();
  var getIngredientWithProp = (prop, ingredients) => {
    const protoChains = ingredients.map((ingredient) => (0, util_1.protoChain)(ingredient));
    let protoDepth = 0;
    let protosAreLeftToSearch = true;
    while (protosAreLeftToSearch) {
      protosAreLeftToSearch = false;
      for (let i = ingredients.length - 1;i >= 0; i--) {
        const searchTarget = protoChains[i][protoDepth];
        if (searchTarget !== undefined && searchTarget !== null) {
          protosAreLeftToSearch = true;
          if (Object.getOwnPropertyDescriptor(searchTarget, prop) != null) {
            return protoChains[i][0];
          }
        }
      }
      protoDepth++;
    }
    return;
  };
  exports.getIngredientWithProp = getIngredientWithProp;
  var proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
    getPrototypeOf() {
      return prototype;
    },
    setPrototypeOf() {
      throw Error("Cannot set prototype of Proxies created by ts-mixer");
    },
    getOwnPropertyDescriptor(_, prop) {
      return Object.getOwnPropertyDescriptor((0, exports.getIngredientWithProp)(prop, ingredients) || {}, prop);
    },
    defineProperty() {
      throw new Error("Cannot define new properties on Proxies created by ts-mixer");
    },
    has(_, prop) {
      return (0, exports.getIngredientWithProp)(prop, ingredients) !== undefined || prototype[prop] !== undefined;
    },
    get(_, prop) {
      return ((0, exports.getIngredientWithProp)(prop, ingredients) || prototype)[prop];
    },
    set(_, prop, val) {
      const ingredientWithProp = (0, exports.getIngredientWithProp)(prop, ingredients);
      if (ingredientWithProp === undefined)
        throw new Error("Cannot set new properties on Proxies created by ts-mixer");
      ingredientWithProp[prop] = val;
      return true;
    },
    deleteProperty() {
      throw new Error("Cannot delete properties on Proxies created by ts-mixer");
    },
    ownKeys() {
      return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
    }
  });
  exports.proxyMix = proxyMix;
  var softMixProtos = (ingredients, constructor) => (0, exports.proxyMix)([...ingredients, { constructor }]);
  exports.softMixProtos = softMixProtos;
});

// ../../node_modules/ts-mixer/dist/cjs/settings.js
var require_settings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.settings = undefined;
  exports.settings = {
    initFunction: null,
    staticsStrategy: "copy",
    prototypeStrategy: "copy",
    decoratorInheritance: "deep"
  };
});

// ../../node_modules/ts-mixer/dist/cjs/mixin-tracking.js
var require_mixin_tracking = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.registerMixins = exports.getMixinsForClass = undefined;
  var util_1 = require_util();
  var mixins = new WeakMap;
  var getMixinsForClass = (clazz) => mixins.get(clazz);
  exports.getMixinsForClass = getMixinsForClass;
  var registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
  exports.registerMixins = registerMixins;
  var hasMixin = (instance, mixin) => {
    if (instance instanceof mixin)
      return true;
    const constructor = instance.constructor;
    const visited = new Set;
    let frontier = new Set;
    frontier.add(constructor);
    while (frontier.size > 0) {
      if (frontier.has(mixin))
        return true;
      frontier.forEach((item) => visited.add(item));
      const newFrontier = new Set;
      frontier.forEach((item) => {
        var _a;
        const itemConstituents = (_a = mixins.get(item)) !== null && _a !== undefined ? _a : (0, util_1.protoChain)(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
        if (itemConstituents)
          itemConstituents.forEach((constituent) => {
            if (!visited.has(constituent) && !frontier.has(constituent))
              newFrontier.add(constituent);
          });
      });
      frontier = newFrontier;
    }
    return false;
  };
  exports.hasMixin = hasMixin;
});

// ../../node_modules/ts-mixer/dist/cjs/decorator.js
var require_decorator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decorate = exports.getDecoratorsForClass = exports.directDecoratorSearch = exports.deepDecoratorSearch = undefined;
  var util_1 = require_util();
  var mixin_tracking_1 = require_mixin_tracking();
  var mergeObjectsOfDecorators = (o1, o2) => {
    var _a, _b;
    const allKeys = (0, util_1.unique)([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
    const mergedObject = {};
    for (let key of allKeys)
      mergedObject[key] = (0, util_1.unique)([...(_a = o1 === null || o1 === undefined ? undefined : o1[key]) !== null && _a !== undefined ? _a : [], ...(_b = o2 === null || o2 === undefined ? undefined : o2[key]) !== null && _b !== undefined ? _b : []]);
    return mergedObject;
  };
  var mergePropertyAndMethodDecorators = (d1, d2) => {
    var _a, _b, _c, _d;
    return {
      property: mergeObjectsOfDecorators((_a = d1 === null || d1 === undefined ? undefined : d1.property) !== null && _a !== undefined ? _a : {}, (_b = d2 === null || d2 === undefined ? undefined : d2.property) !== null && _b !== undefined ? _b : {}),
      method: mergeObjectsOfDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.method) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.method) !== null && _d !== undefined ? _d : {})
    };
  };
  var mergeDecorators = (d1, d2) => {
    var _a, _b, _c, _d, _e, _f;
    return {
      class: (0, util_1.unique)([...(_a = d1 === null || d1 === undefined ? undefined : d1.class) !== null && _a !== undefined ? _a : [], ...(_b = d2 === null || d2 === undefined ? undefined : d2.class) !== null && _b !== undefined ? _b : []]),
      static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.static) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.static) !== null && _d !== undefined ? _d : {}),
      instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === undefined ? undefined : d1.instance) !== null && _e !== undefined ? _e : {}, (_f = d2 === null || d2 === undefined ? undefined : d2.instance) !== null && _f !== undefined ? _f : {})
    };
  };
  var decorators = new Map;
  var findAllConstituentClasses = (...classes) => {
    var _a;
    const allClasses = new Set;
    const frontier = new Set([...classes]);
    while (frontier.size > 0) {
      for (let clazz of frontier) {
        const protoChainClasses = (0, util_1.protoChain)(clazz.prototype).map((proto) => proto.constructor);
        const mixinClasses = (_a = (0, mixin_tracking_1.getMixinsForClass)(clazz)) !== null && _a !== undefined ? _a : [];
        const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
        const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
        for (let newClass of newClasses)
          frontier.add(newClass);
        allClasses.add(clazz);
        frontier.delete(clazz);
      }
    }
    return [...allClasses];
  };
  var deepDecoratorSearch = (...classes) => {
    const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
    if (decoratorsForClassChain.length == 0)
      return {};
    if (decoratorsForClassChain.length == 1)
      return decoratorsForClassChain[0];
    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.deepDecoratorSearch = deepDecoratorSearch;
  var directDecoratorSearch = (...classes) => {
    const classDecorators = classes.map((clazz) => (0, exports.getDecoratorsForClass)(clazz));
    if (classDecorators.length === 0)
      return {};
    if (classDecorators.length === 1)
      return classDecorators[0];
    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.directDecoratorSearch = directDecoratorSearch;
  var getDecoratorsForClass = (clazz) => {
    let decoratorsForClass = decorators.get(clazz);
    if (!decoratorsForClass) {
      decoratorsForClass = {};
      decorators.set(clazz, decoratorsForClass);
    }
    return decoratorsForClass;
  };
  exports.getDecoratorsForClass = getDecoratorsForClass;
  var decorateClass = (decorator) => (clazz) => {
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    let classDecorators = decoratorsForClass.class;
    if (!classDecorators) {
      classDecorators = [];
      decoratorsForClass.class = classDecorators;
    }
    classDecorators.push(decorator);
    return decorator(clazz);
  };
  var decorateMember = (decorator) => (object, key, ...otherArgs) => {
    var _a, _b, _c;
    const decoratorTargetType = typeof object === "function" ? "static" : "instance";
    const decoratorType = typeof object[key] === "function" ? "method" : "property";
    const clazz = decoratorTargetType === "static" ? object : object.constructor;
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === undefined ? undefined : decoratorsForClass[decoratorTargetType]) !== null && _a !== undefined ? _a : {};
    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === undefined ? undefined : decoratorsForTargetType[decoratorType]) !== null && _b !== undefined ? _b : {};
    decoratorsForTargetType[decoratorType] = decoratorsForType;
    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === undefined ? undefined : decoratorsForType[key]) !== null && _c !== undefined ? _c : [];
    decoratorsForType[key] = decoratorsForKey;
    decoratorsForKey.push(decorator);
    return decorator(object, key, ...otherArgs);
  };
  var decorate = (decorator) => (...args) => {
    if (args.length === 1)
      return decorateClass(decorator)(args[0]);
    return decorateMember(decorator)(...args);
  };
  exports.decorate = decorate;
});

// ../../node_modules/ts-mixer/dist/cjs/mixins.js
var require_mixins = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mix = exports.Mixin = undefined;
  var proxy_1 = require_proxy();
  var settings_1 = require_settings();
  var util_1 = require_util();
  var decorator_1 = require_decorator();
  var mixin_tracking_1 = require_mixin_tracking();
  function Mixin(...constructors) {
    var _a, _b, _c;
    const prototypes = constructors.map((constructor) => constructor.prototype);
    const initFunctionName = settings_1.settings.initFunction;
    if (initFunctionName !== null) {
      const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
      const combinedInitFunction = function(...args) {
        for (let initFunction of initFunctions)
          initFunction.apply(this, args);
      };
      const extraProto = { [initFunctionName]: combinedInitFunction };
      prototypes.push(extraProto);
    }
    function MixedClass(...args) {
      for (const constructor of constructors)
        (0, util_1.copyProps)(this, new constructor(...args));
      if (initFunctionName !== null && typeof this[initFunctionName] === "function")
        this[initFunctionName].apply(this, args);
    }
    MixedClass.prototype = settings_1.settings.prototypeStrategy === "copy" ? (0, util_1.hardMixProtos)(prototypes, MixedClass) : (0, proxy_1.softMixProtos)(prototypes, MixedClass);
    Object.setPrototypeOf(MixedClass, settings_1.settings.staticsStrategy === "copy" ? (0, util_1.hardMixProtos)(constructors, null, ["prototype"]) : (0, proxy_1.proxyMix)(constructors, Function.prototype));
    let DecoratedMixedClass = MixedClass;
    if (settings_1.settings.decoratorInheritance !== "none") {
      const classDecorators = settings_1.settings.decoratorInheritance === "deep" ? (0, decorator_1.deepDecoratorSearch)(...constructors) : (0, decorator_1.directDecoratorSearch)(...constructors);
      for (let decorator of (_a = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.class) !== null && _a !== undefined ? _a : []) {
        const result = decorator(DecoratedMixedClass);
        if (result) {
          DecoratedMixedClass = result;
        }
      }
      applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.static) !== null && _b !== undefined ? _b : {}, DecoratedMixedClass);
      applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.instance) !== null && _c !== undefined ? _c : {}, DecoratedMixedClass.prototype);
    }
    (0, mixin_tracking_1.registerMixins)(DecoratedMixedClass, constructors);
    return DecoratedMixedClass;
  }
  exports.Mixin = Mixin;
  var applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
    const propDecorators = propAndMethodDecorators.property;
    const methodDecorators = propAndMethodDecorators.method;
    if (propDecorators)
      for (let key in propDecorators)
        for (let decorator of propDecorators[key])
          decorator(target, key);
    if (methodDecorators)
      for (let key in methodDecorators)
        for (let decorator of methodDecorators[key])
          decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
  };
  var mix = (...ingredients) => (decoratedClass) => {
    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
    Object.defineProperty(mixedClass, "name", {
      value: decoratedClass.name,
      writable: false
    });
    return mixedClass;
  };
  exports.mix = mix;
});

// ../../node_modules/ts-mixer/dist/cjs/index.js
var require_cjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.decorate = exports.settings = exports.mix = exports.Mixin = undefined;
  var mixins_1 = require_mixins();
  Object.defineProperty(exports, "Mixin", { enumerable: true, get: function() {
    return mixins_1.Mixin;
  } });
  Object.defineProperty(exports, "mix", { enumerable: true, get: function() {
    return mixins_1.mix;
  } });
  var settings_1 = require_settings();
  Object.defineProperty(exports, "settings", { enumerable: true, get: function() {
    return settings_1.settings;
  } });
  var decorator_1 = require_decorator();
  Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
    return decorator_1.decorate;
  } });
  var mixin_tracking_1 = require_mixin_tracking();
  Object.defineProperty(exports, "hasMixin", { enumerable: true, get: function() {
    return mixin_tracking_1.hasMixin;
  } });
});

// ../../node_modules/@discordjs/builders/dist/index.js
var require_dist8 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? undefined : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator;i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp2(target, key, result);
    return result;
  };
  var src_exports = {};
  __export2(src_exports, {
    ActionRowBuilder: () => ActionRowBuilder,
    ApplicationCommandNumericOptionMinMaxValueMixin: () => ApplicationCommandNumericOptionMinMaxValueMixin,
    ApplicationCommandOptionBase: () => ApplicationCommandOptionBase,
    ApplicationCommandOptionChannelTypesMixin: () => ApplicationCommandOptionChannelTypesMixin,
    ApplicationCommandOptionWithAutocompleteMixin: () => ApplicationCommandOptionWithAutocompleteMixin,
    ApplicationCommandOptionWithChoicesMixin: () => ApplicationCommandOptionWithChoicesMixin,
    BaseSelectMenuBuilder: () => BaseSelectMenuBuilder,
    ButtonBuilder: () => ButtonBuilder,
    ChannelSelectMenuBuilder: () => ChannelSelectMenuBuilder,
    ComponentAssertions: () => Assertions_exports2,
    ComponentBuilder: () => ComponentBuilder,
    ComponentsV2Assertions: () => Assertions_exports4,
    ContainerBuilder: () => ContainerBuilder,
    ContextMenuCommandAssertions: () => Assertions_exports7,
    ContextMenuCommandBuilder: () => ContextMenuCommandBuilder,
    EmbedAssertions: () => Assertions_exports,
    EmbedBuilder: () => EmbedBuilder,
    FileBuilder: () => FileBuilder,
    MediaGalleryBuilder: () => MediaGalleryBuilder,
    MediaGalleryItemBuilder: () => MediaGalleryItemBuilder,
    MentionableSelectMenuBuilder: () => MentionableSelectMenuBuilder,
    ModalAssertions: () => Assertions_exports5,
    ModalBuilder: () => ModalBuilder,
    RoleSelectMenuBuilder: () => RoleSelectMenuBuilder,
    SectionBuilder: () => SectionBuilder,
    SelectMenuBuilder: () => StringSelectMenuBuilder,
    SelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    SeparatorBuilder: () => SeparatorBuilder,
    SharedNameAndDescription: () => SharedNameAndDescription,
    SharedSlashCommand: () => SharedSlashCommand,
    SharedSlashCommandOptions: () => SharedSlashCommandOptions,
    SharedSlashCommandSubcommands: () => SharedSlashCommandSubcommands,
    SlashCommandAssertions: () => Assertions_exports6,
    SlashCommandAttachmentOption: () => SlashCommandAttachmentOption,
    SlashCommandBooleanOption: () => SlashCommandBooleanOption,
    SlashCommandBuilder: () => SlashCommandBuilder,
    SlashCommandChannelOption: () => SlashCommandChannelOption,
    SlashCommandIntegerOption: () => SlashCommandIntegerOption,
    SlashCommandMentionableOption: () => SlashCommandMentionableOption,
    SlashCommandNumberOption: () => SlashCommandNumberOption,
    SlashCommandRoleOption: () => SlashCommandRoleOption,
    SlashCommandStringOption: () => SlashCommandStringOption,
    SlashCommandSubcommandBuilder: () => SlashCommandSubcommandBuilder,
    SlashCommandSubcommandGroupBuilder: () => SlashCommandSubcommandGroupBuilder,
    SlashCommandUserOption: () => SlashCommandUserOption,
    StringSelectMenuBuilder: () => StringSelectMenuBuilder,
    StringSelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    TextDisplayBuilder: () => TextDisplayBuilder,
    TextInputAssertions: () => Assertions_exports3,
    TextInputBuilder: () => TextInputBuilder,
    ThumbnailBuilder: () => ThumbnailBuilder,
    UserSelectMenuBuilder: () => UserSelectMenuBuilder,
    createComponentBuilder: () => createComponentBuilder,
    disableValidators: () => disableValidators,
    embedLength: () => embedLength,
    enableValidators: () => enableValidators,
    isValidationEnabled: () => isValidationEnabled,
    normalizeArray: () => normalizeArray,
    resolveBuilder: () => resolveBuilder,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Assertions_exports = {};
  __export2(Assertions_exports, {
    RGBPredicate: () => RGBPredicate,
    authorNamePredicate: () => authorNamePredicate,
    colorPredicate: () => colorPredicate,
    descriptionPredicate: () => descriptionPredicate,
    embedAuthorPredicate: () => embedAuthorPredicate,
    embedFieldPredicate: () => embedFieldPredicate,
    embedFieldsArrayPredicate: () => embedFieldsArrayPredicate,
    embedFooterPredicate: () => embedFooterPredicate,
    fieldInlinePredicate: () => fieldInlinePredicate,
    fieldLengthPredicate: () => fieldLengthPredicate,
    fieldNamePredicate: () => fieldNamePredicate,
    fieldValuePredicate: () => fieldValuePredicate,
    footerTextPredicate: () => footerTextPredicate,
    imageURLPredicate: () => imageURLPredicate,
    timestampPredicate: () => timestampPredicate,
    titlePredicate: () => titlePredicate,
    urlPredicate: () => urlPredicate,
    validateFieldLength: () => validateFieldLength
  });
  var import_shapeshift = require_cjs3();
  var validate = true;
  function enableValidators() {
    return validate = true;
  }
  __name(enableValidators, "enableValidators");
  function disableValidators() {
    return validate = false;
  }
  __name(disableValidators, "disableValidators");
  function isValidationEnabled() {
    return validate;
  }
  __name(isValidationEnabled, "isValidationEnabled");
  var fieldNamePredicate = import_shapeshift.s.string().lengthLessThanOrEqual(256).setValidationEnabled(isValidationEnabled);
  var fieldValuePredicate = import_shapeshift.s.string().lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
  var fieldInlinePredicate = import_shapeshift.s.boolean().optional();
  var embedFieldPredicate = import_shapeshift.s.object({
    name: fieldNamePredicate,
    value: fieldValuePredicate,
    inline: fieldInlinePredicate
  }).setValidationEnabled(isValidationEnabled);
  var embedFieldsArrayPredicate = embedFieldPredicate.array().setValidationEnabled(isValidationEnabled);
  var fieldLengthPredicate = import_shapeshift.s.number().lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  function validateFieldLength(amountAdding, fields) {
    fieldLengthPredicate.parse((fields?.length ?? 0) + amountAdding);
  }
  __name(validateFieldLength, "validateFieldLength");
  var authorNamePredicate = fieldNamePredicate.lengthGreaterThanOrEqual(1).nullable().setValidationEnabled(isValidationEnabled);
  var imageURLPredicate = import_shapeshift.s.string().url({
    allowedProtocols: ["http:", "https:", "attachment:"]
  }).nullish().setValidationEnabled(isValidationEnabled);
  var urlPredicate = import_shapeshift.s.string().url({
    allowedProtocols: ["http:", "https:"]
  }).nullish().setValidationEnabled(isValidationEnabled);
  var embedAuthorPredicate = import_shapeshift.s.object({
    name: authorNamePredicate,
    iconURL: imageURLPredicate,
    url: urlPredicate
  }).setValidationEnabled(isValidationEnabled);
  var RGBPredicate = import_shapeshift.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(255).setValidationEnabled(isValidationEnabled);
  var colorPredicate = import_shapeshift.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(16777215).or(import_shapeshift.s.tuple([RGBPredicate, RGBPredicate, RGBPredicate])).nullable().setValidationEnabled(isValidationEnabled);
  var descriptionPredicate = import_shapeshift.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4096).nullable().setValidationEnabled(isValidationEnabled);
  var footerTextPredicate = import_shapeshift.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(2048).nullable().setValidationEnabled(isValidationEnabled);
  var embedFooterPredicate = import_shapeshift.s.object({
    text: footerTextPredicate,
    iconURL: imageURLPredicate
  }).setValidationEnabled(isValidationEnabled);
  var timestampPredicate = import_shapeshift.s.union([import_shapeshift.s.number(), import_shapeshift.s.date()]).nullable().setValidationEnabled(isValidationEnabled);
  var titlePredicate = fieldNamePredicate.lengthGreaterThanOrEqual(1).nullable().setValidationEnabled(isValidationEnabled);
  function normalizeArray(arr) {
    if (Array.isArray(arr[0]))
      return [...arr[0]];
    return arr;
  }
  __name(normalizeArray, "normalizeArray");
  var EmbedBuilder = class {
    static {
      __name(this, "EmbedBuilder");
    }
    data;
    constructor(data = {}) {
      this.data = { ...data };
      if (data.timestamp)
        this.data.timestamp = new Date(data.timestamp).toISOString();
    }
    addFields(...fields) {
      const normalizedFields = normalizeArray(fields);
      validateFieldLength(normalizedFields.length, this.data.fields);
      embedFieldsArrayPredicate.parse(normalizedFields);
      if (this.data.fields)
        this.data.fields.push(...normalizedFields);
      else
        this.data.fields = normalizedFields;
      return this;
    }
    spliceFields(index, deleteCount, ...fields) {
      validateFieldLength(fields.length - deleteCount, this.data.fields);
      embedFieldsArrayPredicate.parse(fields);
      if (this.data.fields)
        this.data.fields.splice(index, deleteCount, ...fields);
      else
        this.data.fields = fields;
      return this;
    }
    setFields(...fields) {
      this.spliceFields(0, this.data.fields?.length ?? 0, ...normalizeArray(fields));
      return this;
    }
    setAuthor(options) {
      if (options === null) {
        this.data.author = undefined;
        return this;
      }
      embedAuthorPredicate.parse(options);
      this.data.author = { name: options.name, url: options.url, icon_url: options.iconURL };
      return this;
    }
    setColor(color) {
      colorPredicate.parse(color);
      if (Array.isArray(color)) {
        const [red, green, blue] = color;
        this.data.color = (red << 16) + (green << 8) + blue;
        return this;
      }
      this.data.color = color ?? undefined;
      return this;
    }
    setDescription(description) {
      descriptionPredicate.parse(description);
      this.data.description = description ?? undefined;
      return this;
    }
    setFooter(options) {
      if (options === null) {
        this.data.footer = undefined;
        return this;
      }
      embedFooterPredicate.parse(options);
      this.data.footer = { text: options.text, icon_url: options.iconURL };
      return this;
    }
    setImage(url) {
      imageURLPredicate.parse(url);
      this.data.image = url ? { url } : undefined;
      return this;
    }
    setThumbnail(url) {
      imageURLPredicate.parse(url);
      this.data.thumbnail = url ? { url } : undefined;
      return this;
    }
    setTimestamp(timestamp = Date.now()) {
      timestampPredicate.parse(timestamp);
      this.data.timestamp = timestamp ? new Date(timestamp).toISOString() : undefined;
      return this;
    }
    setTitle(title) {
      titlePredicate.parse(title);
      this.data.title = title ?? undefined;
      return this;
    }
    setURL(url) {
      urlPredicate.parse(url);
      this.data.url = url ?? undefined;
      return this;
    }
    toJSON() {
      return { ...this.data };
    }
  };
  __reExport(src_exports, require_dist7(), module.exports);
  var Assertions_exports2 = {};
  __export2(Assertions_exports2, {
    buttonLabelValidator: () => buttonLabelValidator,
    buttonStyleValidator: () => buttonStyleValidator,
    channelTypesValidator: () => channelTypesValidator,
    customIdValidator: () => customIdValidator,
    defaultValidator: () => defaultValidator,
    disabledValidator: () => disabledValidator,
    emojiValidator: () => emojiValidator,
    idValidator: () => idValidator,
    jsonOptionValidator: () => jsonOptionValidator,
    labelValueDescriptionValidator: () => labelValueDescriptionValidator,
    minMaxValidator: () => minMaxValidator,
    optionValidator: () => optionValidator,
    optionsLengthValidator: () => optionsLengthValidator,
    optionsValidator: () => optionsValidator,
    placeholderValidator: () => placeholderValidator,
    urlValidator: () => urlValidator,
    validateRequiredButtonParameters: () => validateRequiredButtonParameters,
    validateRequiredSelectMenuOptionParameters: () => validateRequiredSelectMenuOptionParameters,
    validateRequiredSelectMenuParameters: () => validateRequiredSelectMenuParameters
  });
  var import_shapeshift2 = require_cjs3();
  var import_v10 = require_v106();
  var StringSelectMenuOptionBuilder = class {
    constructor(data = {}) {
      this.data = data;
    }
    static {
      __name(this, "StringSelectMenuOptionBuilder");
    }
    setLabel(label) {
      this.data.label = labelValueDescriptionValidator.parse(label);
      return this;
    }
    setValue(value) {
      this.data.value = labelValueDescriptionValidator.parse(value);
      return this;
    }
    setDescription(description) {
      this.data.description = labelValueDescriptionValidator.parse(description);
      return this;
    }
    setDefault(isDefault = true) {
      this.data.default = defaultValidator.parse(isDefault);
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuOptionParameters(this.data.label, this.data.value);
      return {
        ...this.data
      };
    }
  };
  var idValidator = import_shapeshift2.s.number().safeInt().greaterThanOrEqual(1).lessThan(4294967296).setValidationEnabled(isValidationEnabled);
  var customIdValidator = import_shapeshift2.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var emojiValidator = import_shapeshift2.s.object({
    id: import_shapeshift2.s.string(),
    name: import_shapeshift2.s.string(),
    animated: import_shapeshift2.s.boolean()
  }).partial().strict().setValidationEnabled(isValidationEnabled);
  var disabledValidator = import_shapeshift2.s.boolean();
  var buttonLabelValidator = import_shapeshift2.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(80).setValidationEnabled(isValidationEnabled);
  var buttonStyleValidator = import_shapeshift2.s.nativeEnum(import_v10.ButtonStyle);
  var placeholderValidator = import_shapeshift2.s.string().lengthLessThanOrEqual(150).setValidationEnabled(isValidationEnabled);
  var minMaxValidator = import_shapeshift2.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  var labelValueDescriptionValidator = import_shapeshift2.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var jsonOptionValidator = import_shapeshift2.s.object({
    label: labelValueDescriptionValidator,
    value: labelValueDescriptionValidator,
    description: labelValueDescriptionValidator.optional(),
    emoji: emojiValidator.optional(),
    default: import_shapeshift2.s.boolean().optional()
  }).setValidationEnabled(isValidationEnabled);
  var optionValidator = import_shapeshift2.s.instance(StringSelectMenuOptionBuilder).setValidationEnabled(isValidationEnabled);
  var optionsValidator = optionValidator.array().lengthGreaterThanOrEqual(0).setValidationEnabled(isValidationEnabled);
  var optionsLengthValidator = import_shapeshift2.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  function validateRequiredSelectMenuParameters(options, customId) {
    customIdValidator.parse(customId);
    optionsValidator.parse(options);
  }
  __name(validateRequiredSelectMenuParameters, "validateRequiredSelectMenuParameters");
  var defaultValidator = import_shapeshift2.s.boolean();
  function validateRequiredSelectMenuOptionParameters(label, value) {
    labelValueDescriptionValidator.parse(label);
    labelValueDescriptionValidator.parse(value);
  }
  __name(validateRequiredSelectMenuOptionParameters, "validateRequiredSelectMenuOptionParameters");
  var channelTypesValidator = import_shapeshift2.s.nativeEnum(import_v10.ChannelType).array().setValidationEnabled(isValidationEnabled);
  var urlValidator = import_shapeshift2.s.string().url({
    allowedProtocols: ["http:", "https:", "discord:"]
  }).setValidationEnabled(isValidationEnabled);
  function validateRequiredButtonParameters(style, label, emoji, customId, skuId, url) {
    if (style === import_v10.ButtonStyle.Premium) {
      if (!skuId) {
        throw new RangeError("Premium buttons must have an SKU id.");
      }
      if (customId || label || url || emoji) {
        throw new RangeError("Premium buttons cannot have a custom id, label, URL, or emoji.");
      }
    } else {
      if (skuId) {
        throw new RangeError("Non-premium buttons must not have an SKU id.");
      }
      if (url && customId) {
        throw new RangeError("URL and custom id are mutually exclusive.");
      }
      if (!label && !emoji) {
        throw new RangeError("Non-premium buttons must have a label and/or an emoji.");
      }
      if (style === import_v10.ButtonStyle.Link) {
        if (!url) {
          throw new RangeError("Link buttons must have a URL.");
        }
      } else if (url) {
        throw new RangeError("Non-premium and non-link buttons cannot have a URL.");
      }
    }
  }
  __name(validateRequiredButtonParameters, "validateRequiredButtonParameters");
  var import_v1019 = require_v106();
  var ComponentBuilder = class {
    static {
      __name(this, "ComponentBuilder");
    }
    data;
    constructor(data) {
      this.data = data;
    }
    setId(id) {
      this.data.id = idValidator.parse(id);
      return this;
    }
    clearId() {
      this.data.id = undefined;
      return this;
    }
  };
  var import_v1018 = require_v106();
  var import_v102 = require_v106();
  var ButtonBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ButtonBuilder");
    }
    constructor(data) {
      super({ type: import_v102.ComponentType.Button, ...data });
    }
    setStyle(style) {
      this.data.style = buttonStyleValidator.parse(style);
      return this;
    }
    setURL(url) {
      this.data.url = urlValidator.parse(url);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setSKUId(skuId) {
      this.data.sku_id = skuId;
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    setLabel(label) {
      this.data.label = buttonLabelValidator.parse(label);
      return this;
    }
    toJSON() {
      validateRequiredButtonParameters(this.data.style, this.data.label, this.data.emoji, this.data.custom_id, this.data.sku_id, this.data.url);
      return {
        ...this.data
      };
    }
  };
  var import_v103 = require_v106();
  var BaseSelectMenuBuilder = class extends ComponentBuilder {
    static {
      __name(this, "BaseSelectMenuBuilder");
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator.parse(placeholder);
      return this;
    }
    setMinValues(minValues) {
      this.data.min_values = minMaxValidator.parse(minValues);
      return this;
    }
    setMaxValues(maxValues) {
      this.data.max_values = minMaxValidator.parse(maxValues);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var ChannelSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "ChannelSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v103.ComponentType.ChannelSelect });
    }
    addChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.push(...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    setChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.splice(0, this.data.channel_types.length, ...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    addDefaultChannels(...channels) {
      const normalizedValues = normalizeArray(channels);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v103.SelectMenuDefaultValueType.Channel
      })));
      return this;
    }
    setDefaultChannels(...channels) {
      const normalizedValues = normalizeArray(channels);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v103.SelectMenuDefaultValueType.Channel
      }));
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var import_v104 = require_v106();
  var MentionableSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "MentionableSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v104.ComponentType.MentionableSelect });
    }
    addDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v104.SelectMenuDefaultValueType.Role
      })));
      return this;
    }
    addDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v104.SelectMenuDefaultValueType.User
      })));
      return this;
    }
    addDefaultValues(...values) {
      const normalizedValues = normalizeArray(values);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues);
      return this;
    }
    setDefaultValues(...values) {
      const normalizedValues = normalizeArray(values);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues;
      return this;
    }
  };
  var import_v105 = require_v106();
  var RoleSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "RoleSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v105.ComponentType.RoleSelect });
    }
    addDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v105.SelectMenuDefaultValueType.Role
      })));
      return this;
    }
    setDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v105.SelectMenuDefaultValueType.Role
      }));
      return this;
    }
  };
  var import_v106 = require_v106();
  var StringSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "StringSelectMenuBuilder");
    }
    options;
    constructor(data) {
      const { options, ...initData } = data ?? {};
      super({ ...initData, type: import_v106.ComponentType.StringSelect });
      this.options = options?.map((option) => new StringSelectMenuOptionBuilder(option)) ?? [];
    }
    addOptions(...options) {
      const normalizedOptions = normalizeArray(options);
      optionsLengthValidator.parse(this.options.length + normalizedOptions.length);
      this.options.push(...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      return this;
    }
    setOptions(...options) {
      return this.spliceOptions(0, this.options.length, ...options);
    }
    spliceOptions(index, deleteCount, ...options) {
      const normalizedOptions = normalizeArray(options);
      const clone = [...this.options];
      clone.splice(index, deleteCount, ...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      optionsLengthValidator.parse(clone.length);
      this.options.splice(0, this.options.length, ...clone);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuParameters(this.options, this.data.custom_id);
      return {
        ...this.data,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  var import_v107 = require_v106();
  var UserSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "UserSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v107.ComponentType.UserSelect });
    }
    addDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v107.SelectMenuDefaultValueType.User
      })));
      return this;
    }
    setDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v107.SelectMenuDefaultValueType.User
      }));
      return this;
    }
  };
  var import_util = require_dist();
  var import_v109 = require_v106();
  var import_fast_deep_equal = __toESM2(require_fast_deep_equal());
  var Assertions_exports3 = {};
  __export2(Assertions_exports3, {
    labelValidator: () => labelValidator,
    maxLengthValidator: () => maxLengthValidator,
    minLengthValidator: () => minLengthValidator,
    placeholderValidator: () => placeholderValidator2,
    requiredValidator: () => requiredValidator,
    textInputStyleValidator: () => textInputStyleValidator,
    validateRequiredParameters: () => validateRequiredParameters,
    valueValidator: () => valueValidator
  });
  var import_shapeshift3 = require_cjs3();
  var import_v108 = require_v106();
  var textInputStyleValidator = import_shapeshift3.s.nativeEnum(import_v108.TextInputStyle);
  var minLengthValidator = import_shapeshift3.s.number().int().greaterThanOrEqual(0).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var maxLengthValidator = import_shapeshift3.s.number().int().greaterThanOrEqual(1).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var requiredValidator = import_shapeshift3.s.boolean();
  var valueValidator = import_shapeshift3.s.string().lengthLessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var placeholderValidator2 = import_shapeshift3.s.string().lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var labelValidator = import_shapeshift3.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  function validateRequiredParameters(customId, style, label) {
    customIdValidator.parse(customId);
    textInputStyleValidator.parse(style);
    labelValidator.parse(label);
  }
  __name(validateRequiredParameters, "validateRequiredParameters");
  var TextInputBuilder = class extends ComponentBuilder {
    static {
      __name(this, "TextInputBuilder");
    }
    constructor(data) {
      super({ type: import_v109.ComponentType.TextInput, ...data });
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setLabel(label) {
      this.data.label = labelValidator.parse(label);
      return this;
    }
    setStyle(style) {
      this.data.style = textInputStyleValidator.parse(style);
      return this;
    }
    setMinLength(minLength) {
      this.data.min_length = minLengthValidator.parse(minLength);
      return this;
    }
    setMaxLength(maxLength) {
      this.data.max_length = maxLengthValidator.parse(maxLength);
      return this;
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator2.parse(placeholder);
      return this;
    }
    setValue(value) {
      this.data.value = valueValidator.parse(value);
      return this;
    }
    setRequired(required = true) {
      this.data.required = requiredValidator.parse(required);
      return this;
    }
    toJSON() {
      validateRequiredParameters(this.data.custom_id, this.data.style, this.data.label);
      return {
        ...this.data
      };
    }
    equals(other) {
      if ((0, import_util.isJSONEncodable)(other)) {
        return (0, import_fast_deep_equal.default)(other.toJSON(), this.data);
      }
      return (0, import_fast_deep_equal.default)(other, this.data);
    }
  };
  var import_v1015 = require_v106();
  var Assertions_exports4 = {};
  __export2(Assertions_exports4, {
    accessoryPredicate: () => accessoryPredicate,
    assertReturnOfBuilder: () => assertReturnOfBuilder,
    containerColorPredicate: () => containerColorPredicate,
    descriptionPredicate: () => descriptionPredicate2,
    dividerPredicate: () => dividerPredicate,
    filePredicate: () => filePredicate,
    spacingPredicate: () => spacingPredicate,
    spoilerPredicate: () => spoilerPredicate,
    textDisplayContentPredicate: () => textDisplayContentPredicate,
    unfurledMediaItemPredicate: () => unfurledMediaItemPredicate,
    validateComponentArray: () => validateComponentArray
  });
  var import_shapeshift4 = require_cjs3();
  var import_v1011 = require_v106();
  var import_v1010 = require_v106();
  var ThumbnailBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ThumbnailBuilder");
    }
    constructor(data = {}) {
      super({
        type: import_v1010.ComponentType.Thumbnail,
        ...data,
        media: data.media ? { url: data.media.url } : undefined
      });
    }
    setDescription(description) {
      this.data.description = descriptionPredicate2.parse(description);
      return this;
    }
    clearDescription() {
      this.data.description = undefined;
      return this;
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    setURL(url) {
      this.data.media = unfurledMediaItemPredicate.parse({ url });
      return this;
    }
    toJSON() {
      unfurledMediaItemPredicate.parse(this.data.media);
      return { ...this.data };
    }
  };
  var unfurledMediaItemPredicate = import_shapeshift4.s.object({
    url: import_shapeshift4.s.string().url({ allowedProtocols: ["http:", "https:", "attachment:"] }, { message: "Invalid protocol for media URL. Must be http:, https:, or attachment:" })
  }).setValidationEnabled(isValidationEnabled);
  var descriptionPredicate2 = import_shapeshift4.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
  var filePredicate = import_shapeshift4.s.object({
    url: import_shapeshift4.s.string().url({ allowedProtocols: ["attachment:"] }, { message: "Invalid protocol for file URL. Must be attachment:" })
  }).setValidationEnabled(isValidationEnabled);
  var spoilerPredicate = import_shapeshift4.s.boolean();
  var dividerPredicate = import_shapeshift4.s.boolean();
  var spacingPredicate = import_shapeshift4.s.nativeEnum(import_v1011.SeparatorSpacingSize);
  var textDisplayContentPredicate = import_shapeshift4.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var accessoryPredicate = import_shapeshift4.s.instance(ButtonBuilder).or(import_shapeshift4.s.instance(ThumbnailBuilder)).setValidationEnabled(isValidationEnabled);
  var containerColorPredicate = colorPredicate.nullish();
  function assertReturnOfBuilder(input, ExpectedInstanceOf) {
    import_shapeshift4.s.instance(ExpectedInstanceOf).setValidationEnabled(isValidationEnabled).parse(input);
  }
  __name(assertReturnOfBuilder, "assertReturnOfBuilder");
  function validateComponentArray(input, min, max, ExpectedInstanceOf) {
    (ExpectedInstanceOf ? import_shapeshift4.s.instance(ExpectedInstanceOf) : import_shapeshift4.s.instance(ComponentBuilder)).array().lengthGreaterThanOrEqual(min).lengthLessThanOrEqual(max).setValidationEnabled(isValidationEnabled).parse(input);
  }
  __name(validateComponentArray, "validateComponentArray");
  var import_v1012 = require_v106();
  var FileBuilder = class extends ComponentBuilder {
    static {
      __name(this, "FileBuilder");
    }
    constructor(data = {}) {
      super({ type: import_v1012.ComponentType.File, ...data, file: data.file ? { url: data.file.url } : undefined });
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    setURL(url) {
      this.data.file = filePredicate.parse({ url });
      return this;
    }
    toJSON() {
      filePredicate.parse(this.data.file);
      return { ...this.data, file: { ...this.data.file } };
    }
  };
  var import_v1013 = require_v106();
  var SeparatorBuilder = class extends ComponentBuilder {
    static {
      __name(this, "SeparatorBuilder");
    }
    constructor(data = {}) {
      super({
        type: import_v1013.ComponentType.Separator,
        ...data
      });
    }
    setDivider(divider = true) {
      this.data.divider = dividerPredicate.parse(divider);
      return this;
    }
    setSpacing(spacing) {
      this.data.spacing = spacingPredicate.parse(spacing);
      return this;
    }
    clearSpacing() {
      this.data.spacing = undefined;
      return this;
    }
    toJSON() {
      return { ...this.data };
    }
  };
  var import_v1014 = require_v106();
  var TextDisplayBuilder = class extends ComponentBuilder {
    static {
      __name(this, "TextDisplayBuilder");
    }
    constructor(data = {}) {
      super({
        type: import_v1014.ComponentType.TextDisplay,
        ...data
      });
    }
    setContent(content) {
      this.data.content = textDisplayContentPredicate.parse(content);
      return this;
    }
    toJSON() {
      textDisplayContentPredicate.parse(this.data.content);
      return { ...this.data };
    }
  };
  var ContainerBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ContainerBuilder");
    }
    components;
    constructor({ components, ...data } = {}) {
      super({ type: import_v1015.ComponentType.Container, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    setAccentColor(color) {
      containerColorPredicate.parse(color);
      if (Array.isArray(color)) {
        const [red, green, blue] = color;
        this.data.accent_color = (red << 16) + (green << 8) + blue;
        return this;
      }
      this.data.accent_color = color;
      return this;
    }
    clearAccentColor() {
      this.data.accent_color = undefined;
      return this;
    }
    addActionRowComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, ActionRowBuilder)));
      return this;
    }
    addFileComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, FileBuilder)));
      return this;
    }
    addMediaGalleryComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, MediaGalleryBuilder)));
      return this;
    }
    addSectionComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, SectionBuilder)));
      return this;
    }
    addSeparatorComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, SeparatorBuilder)));
      return this;
    }
    addTextDisplayComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => resolveBuilder(component, TextDisplayBuilder)));
      return this;
    }
    spliceComponents(index, deleteCount, ...components) {
      this.components.splice(index, deleteCount, ...normalizeArray(components).map((component) => component instanceof ComponentBuilder ? component : createComponentBuilder(component)));
      return this;
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    toJSON() {
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var import_v1016 = require_v106();
  var MediaGalleryItemBuilder = class {
    static {
      __name(this, "MediaGalleryItemBuilder");
    }
    data;
    constructor(data = {}) {
      this.data = data;
    }
    setDescription(description) {
      this.data.description = descriptionPredicate2.parse(description);
      return this;
    }
    clearDescription() {
      this.data.description = undefined;
      return this;
    }
    setSpoiler(spoiler = true) {
      this.data.spoiler = spoilerPredicate.parse(spoiler);
      return this;
    }
    setURL(url) {
      this.data.media = unfurledMediaItemPredicate.parse({ url });
      return this;
    }
    toJSON() {
      unfurledMediaItemPredicate.parse(this.data.media);
      return { ...this.data };
    }
  };
  var MediaGalleryBuilder = class extends ComponentBuilder {
    static {
      __name(this, "MediaGalleryBuilder");
    }
    items;
    constructor({ items, ...data } = {}) {
      super({ type: import_v1016.ComponentType.MediaGallery, ...data });
      this.items = items?.map((item) => new MediaGalleryItemBuilder(item)) ?? [];
    }
    addItems(...items) {
      this.items.push(...normalizeArray(items).map((input) => {
        const result = resolveBuilder(input, MediaGalleryItemBuilder);
        assertReturnOfBuilder(result, MediaGalleryItemBuilder);
        return result;
      }));
      return this;
    }
    spliceItems(index, deleteCount, ...items) {
      this.items.splice(index, deleteCount, ...normalizeArray(items).map((input) => {
        const result = resolveBuilder(input, MediaGalleryItemBuilder);
        assertReturnOfBuilder(result, MediaGalleryItemBuilder);
        return result;
      }));
      return this;
    }
    toJSON() {
      validateComponentArray(this.items, 1, 10, MediaGalleryItemBuilder);
      return {
        ...this.data,
        items: this.items.map((item) => item.toJSON())
      };
    }
  };
  var import_v1017 = require_v106();
  var SectionBuilder = class extends ComponentBuilder {
    static {
      __name(this, "SectionBuilder");
    }
    components;
    accessory;
    constructor({ components, accessory, ...data } = {}) {
      super({ type: import_v1017.ComponentType.Section, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
      this.accessory = accessory ? createComponentBuilder(accessory) : undefined;
    }
    setButtonAccessory(accessory) {
      Reflect.set(this, "accessory", accessoryPredicate.parse(resolveBuilder(accessory, ButtonBuilder)));
      return this;
    }
    setThumbnailAccessory(accessory) {
      Reflect.set(this, "accessory", accessoryPredicate.parse(resolveBuilder(accessory, ThumbnailBuilder)));
      return this;
    }
    addTextDisplayComponents(...components) {
      this.components.push(...normalizeArray(components).map((input) => {
        const result = resolveBuilder(input, TextDisplayBuilder);
        assertReturnOfBuilder(result, TextDisplayBuilder);
        return result;
      }));
      return this;
    }
    spliceTextDisplayComponents(index, deleteCount, ...components) {
      this.components.splice(index, deleteCount, ...normalizeArray(components).map((input) => {
        const result = resolveBuilder(input, TextDisplayBuilder);
        assertReturnOfBuilder(result, TextDisplayBuilder);
        return result;
      }));
      return this;
    }
    toJSON() {
      validateComponentArray(this.components, 1, 3, TextDisplayBuilder);
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON()),
        accessory: accessoryPredicate.parse(this.accessory).toJSON()
      };
    }
  };
  function createComponentBuilder(data) {
    if (data instanceof ComponentBuilder) {
      return data;
    }
    switch (data.type) {
      case import_v1018.ComponentType.ActionRow:
        return new ActionRowBuilder(data);
      case import_v1018.ComponentType.Button:
        return new ButtonBuilder(data);
      case import_v1018.ComponentType.StringSelect:
        return new StringSelectMenuBuilder(data);
      case import_v1018.ComponentType.TextInput:
        return new TextInputBuilder(data);
      case import_v1018.ComponentType.UserSelect:
        return new UserSelectMenuBuilder(data);
      case import_v1018.ComponentType.RoleSelect:
        return new RoleSelectMenuBuilder(data);
      case import_v1018.ComponentType.MentionableSelect:
        return new MentionableSelectMenuBuilder(data);
      case import_v1018.ComponentType.ChannelSelect:
        return new ChannelSelectMenuBuilder(data);
      case import_v1018.ComponentType.File:
        return new FileBuilder(data);
      case import_v1018.ComponentType.Container:
        return new ContainerBuilder(data);
      case import_v1018.ComponentType.Section:
        return new SectionBuilder(data);
      case import_v1018.ComponentType.Separator:
        return new SeparatorBuilder(data);
      case import_v1018.ComponentType.TextDisplay:
        return new TextDisplayBuilder(data);
      case import_v1018.ComponentType.Thumbnail:
        return new ThumbnailBuilder(data);
      case import_v1018.ComponentType.MediaGallery:
        return new MediaGalleryBuilder(data);
      default:
        throw new Error(`Cannot properly serialize component type: ${data.type}`);
    }
  }
  __name(createComponentBuilder, "createComponentBuilder");
  function isBuilder(builder, Constructor) {
    return builder instanceof Constructor;
  }
  __name(isBuilder, "isBuilder");
  function resolveBuilder(builder, Constructor) {
    if (isBuilder(builder, Constructor)) {
      return builder;
    }
    if (typeof builder === "function") {
      return builder(new Constructor);
    }
    return new Constructor(builder);
  }
  __name(resolveBuilder, "resolveBuilder");
  var ActionRowBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ActionRowBuilder");
    }
    components;
    constructor({ components, ...data } = {}) {
      super({ type: import_v1019.ComponentType.ActionRow, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports5 = {};
  __export2(Assertions_exports5, {
    componentsValidator: () => componentsValidator,
    titleValidator: () => titleValidator,
    validateRequiredParameters: () => validateRequiredParameters2
  });
  var import_shapeshift5 = require_cjs3();
  var titleValidator = import_shapeshift5.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  var componentsValidator = import_shapeshift5.s.instance(ActionRowBuilder).array().lengthGreaterThanOrEqual(1).setValidationEnabled(isValidationEnabled);
  function validateRequiredParameters2(customId, title, components) {
    customIdValidator.parse(customId);
    titleValidator.parse(title);
    componentsValidator.parse(components);
  }
  __name(validateRequiredParameters2, "validateRequiredParameters");
  var ModalBuilder = class {
    static {
      __name(this, "ModalBuilder");
    }
    data;
    components = [];
    constructor({ components, ...data } = {}) {
      this.data = { ...data };
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    setTitle(title) {
      this.data.title = titleValidator.parse(title);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => component instanceof ActionRowBuilder ? component : new ActionRowBuilder(component)));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      validateRequiredParameters2(this.data.custom_id, this.data.title, this.components);
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports6 = {};
  __export2(Assertions_exports6, {
    assertReturnOfBuilder: () => assertReturnOfBuilder2,
    contextsPredicate: () => contextsPredicate,
    integrationTypesPredicate: () => integrationTypesPredicate,
    localizationMapPredicate: () => localizationMapPredicate,
    validateChoicesLength: () => validateChoicesLength,
    validateDMPermission: () => validateDMPermission,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions,
    validateDefaultPermission: () => validateDefaultPermission,
    validateDescription: () => validateDescription,
    validateLocale: () => validateLocale,
    validateLocalizationMap: () => validateLocalizationMap,
    validateMaxOptionsLength: () => validateMaxOptionsLength,
    validateNSFW: () => validateNSFW,
    validateName: () => validateName,
    validateRequired: () => validateRequired,
    validateRequiredParameters: () => validateRequiredParameters3
  });
  var import_shapeshift6 = require_cjs3();
  var import_v1020 = require_v106();
  var namePredicate = import_shapeshift6.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^[\p{Ll}\p{Lm}\p{Lo}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+$/u).setValidationEnabled(isValidationEnabled);
  function validateName(name) {
    namePredicate.parse(name);
  }
  __name(validateName, "validateName");
  var descriptionPredicate3 = import_shapeshift6.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var localePredicate = import_shapeshift6.s.nativeEnum(import_v1020.Locale);
  function validateDescription(description) {
    descriptionPredicate3.parse(description);
  }
  __name(validateDescription, "validateDescription");
  var maxArrayLengthPredicate = import_shapeshift6.s.unknown().array().lengthLessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  function validateLocale(locale) {
    return localePredicate.parse(locale);
  }
  __name(validateLocale, "validateLocale");
  function validateMaxOptionsLength(options) {
    maxArrayLengthPredicate.parse(options);
  }
  __name(validateMaxOptionsLength, "validateMaxOptionsLength");
  function validateRequiredParameters3(name, description, options) {
    validateName(name);
    validateDescription(description);
    validateMaxOptionsLength(options);
  }
  __name(validateRequiredParameters3, "validateRequiredParameters");
  var booleanPredicate = import_shapeshift6.s.boolean();
  function validateDefaultPermission(value) {
    booleanPredicate.parse(value);
  }
  __name(validateDefaultPermission, "validateDefaultPermission");
  function validateRequired(required) {
    booleanPredicate.parse(required);
  }
  __name(validateRequired, "validateRequired");
  var choicesLengthPredicate = import_shapeshift6.s.number().lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  function validateChoicesLength(amountAdding, choices) {
    choicesLengthPredicate.parse((choices?.length ?? 0) + amountAdding);
  }
  __name(validateChoicesLength, "validateChoicesLength");
  function assertReturnOfBuilder2(input, ExpectedInstanceOf) {
    import_shapeshift6.s.instance(ExpectedInstanceOf).parse(input);
  }
  __name(assertReturnOfBuilder2, "assertReturnOfBuilder");
  var localizationMapPredicate = import_shapeshift6.s.object(Object.fromEntries(Object.values(import_v1020.Locale).map((locale) => [locale, import_shapeshift6.s.string().nullish()]))).strict().nullish().setValidationEnabled(isValidationEnabled);
  function validateLocalizationMap(value) {
    localizationMapPredicate.parse(value);
  }
  __name(validateLocalizationMap, "validateLocalizationMap");
  var dmPermissionPredicate = import_shapeshift6.s.boolean().nullish();
  function validateDMPermission(value) {
    dmPermissionPredicate.parse(value);
  }
  __name(validateDMPermission, "validateDMPermission");
  var memberPermissionPredicate = import_shapeshift6.s.union([
    import_shapeshift6.s.bigint().transform((value) => value.toString()),
    import_shapeshift6.s.number().safeInt().transform((value) => value.toString()),
    import_shapeshift6.s.string().regex(/^\d+$/)
  ]).nullish();
  function validateDefaultMemberPermissions(permissions) {
    return memberPermissionPredicate.parse(permissions);
  }
  __name(validateDefaultMemberPermissions, "validateDefaultMemberPermissions");
  function validateNSFW(value) {
    booleanPredicate.parse(value);
  }
  __name(validateNSFW, "validateNSFW");
  var contextsPredicate = import_shapeshift6.s.array(import_shapeshift6.s.nativeEnum(import_v1020.InteractionContextType).setValidationEnabled(isValidationEnabled));
  var integrationTypesPredicate = import_shapeshift6.s.array(import_shapeshift6.s.nativeEnum(import_v1020.ApplicationIntegrationType).setValidationEnabled(isValidationEnabled));
  var import_ts_mixer6 = require_cjs4();
  var SharedNameAndDescription = class {
    static {
      __name(this, "SharedNameAndDescription");
    }
    name;
    name_localizations;
    description;
    description_localizations;
    setName(name) {
      validateName(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setDescription(description) {
      validateDescription(description);
      Reflect.set(this, "description", description);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames)) {
        this.setNameLocalization(...args);
      }
      return this;
    }
    setDescriptionLocalization(locale, localizedDescription) {
      if (!this.description_localizations) {
        Reflect.set(this, "description_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedDescription === null) {
        this.description_localizations[parsedLocale] = null;
        return this;
      }
      validateDescription(localizedDescription);
      this.description_localizations[parsedLocale] = localizedDescription;
      return this;
    }
    setDescriptionLocalizations(localizedDescriptions) {
      if (localizedDescriptions === null) {
        Reflect.set(this, "description_localizations", null);
        return this;
      }
      Reflect.set(this, "description_localizations", {});
      for (const args of Object.entries(localizedDescriptions)) {
        this.setDescriptionLocalization(...args);
      }
      return this;
    }
  };
  var import_v1021 = require_v106();
  var SharedSlashCommand = class {
    static {
      __name(this, "SharedSlashCommand");
    }
    name = undefined;
    name_localizations;
    description = undefined;
    description_localizations;
    options = [];
    contexts;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    integration_types;
    nsfw = undefined;
    setContexts(...contexts) {
      Reflect.set(this, "contexts", contextsPredicate.parse(normalizeArray(contexts)));
      return this;
    }
    setIntegrationTypes(...integrationTypes) {
      Reflect.set(this, "integration_types", integrationTypesPredicate.parse(normalizeArray(integrationTypes)));
      return this;
    }
    setDefaultPermission(value) {
      validateDefaultPermission(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNSFW(nsfw = true) {
      validateNSFW(nsfw);
      Reflect.set(this, "nsfw", nsfw);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      return {
        ...this,
        type: import_v1021.ApplicationCommandType.ChatInput,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  var import_v1022 = require_v106();
  var ApplicationCommandOptionBase = class extends SharedNameAndDescription {
    static {
      __name(this, "ApplicationCommandOptionBase");
    }
    required = false;
    setRequired(required) {
      validateRequired(required);
      Reflect.set(this, "required", required);
      return this;
    }
    runRequiredValidations() {
      validateRequiredParameters3(this.name, this.description, []);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      validateRequired(this.required);
    }
  };
  var SlashCommandAttachmentOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandAttachmentOption");
    }
    type = import_v1022.ApplicationCommandOptionType.Attachment;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1023 = require_v106();
  var SlashCommandBooleanOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandBooleanOption");
    }
    type = import_v1023.ApplicationCommandOptionType.Boolean;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1025 = require_v106();
  var import_ts_mixer = require_cjs4();
  var import_shapeshift7 = require_cjs3();
  var import_v1024 = require_v106();
  var allowedChannelTypes = [
    import_v1024.ChannelType.GuildText,
    import_v1024.ChannelType.GuildVoice,
    import_v1024.ChannelType.GuildCategory,
    import_v1024.ChannelType.GuildAnnouncement,
    import_v1024.ChannelType.AnnouncementThread,
    import_v1024.ChannelType.PublicThread,
    import_v1024.ChannelType.PrivateThread,
    import_v1024.ChannelType.GuildStageVoice,
    import_v1024.ChannelType.GuildForum,
    import_v1024.ChannelType.GuildMedia
  ];
  var channelTypesPredicate = import_shapeshift7.s.array(import_shapeshift7.s.union(allowedChannelTypes.map((type) => import_shapeshift7.s.literal(type))));
  var ApplicationCommandOptionChannelTypesMixin = class {
    static {
      __name(this, "ApplicationCommandOptionChannelTypesMixin");
    }
    channel_types;
    addChannelTypes(...channelTypes) {
      if (this.channel_types === undefined) {
        Reflect.set(this, "channel_types", []);
      }
      this.channel_types.push(...channelTypesPredicate.parse(normalizeArray(channelTypes)));
      return this;
    }
  };
  var SlashCommandChannelOption = class extends ApplicationCommandOptionBase {
    type = import_v1025.ApplicationCommandOptionType.Channel;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  __name(SlashCommandChannelOption, "SlashCommandChannelOption");
  SlashCommandChannelOption = __decorateClass([
    (0, import_ts_mixer.mix)(ApplicationCommandOptionChannelTypesMixin)
  ], SlashCommandChannelOption);
  var import_shapeshift10 = require_cjs3();
  var import_v1027 = require_v106();
  var import_ts_mixer2 = require_cjs4();
  var ApplicationCommandNumericOptionMinMaxValueMixin = class {
    static {
      __name(this, "ApplicationCommandNumericOptionMinMaxValueMixin");
    }
    max_value;
    min_value;
  };
  var import_shapeshift8 = require_cjs3();
  var booleanPredicate2 = import_shapeshift8.s.boolean();
  var ApplicationCommandOptionWithAutocompleteMixin = class {
    static {
      __name(this, "ApplicationCommandOptionWithAutocompleteMixin");
    }
    autocomplete;
    type;
    setAutocomplete(autocomplete) {
      booleanPredicate2.parse(autocomplete);
      if (autocomplete && "choices" in this && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      Reflect.set(this, "autocomplete", autocomplete);
      return this;
    }
  };
  var import_shapeshift9 = require_cjs3();
  var import_v1026 = require_v106();
  var stringPredicate = import_shapeshift9.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100);
  var numberPredicate = import_shapeshift9.s.number().greaterThan(Number.NEGATIVE_INFINITY).lessThan(Number.POSITIVE_INFINITY);
  var choicesPredicate = import_shapeshift9.s.object({
    name: stringPredicate,
    name_localizations: localizationMapPredicate,
    value: import_shapeshift9.s.union([stringPredicate, numberPredicate])
  }).array();
  var ApplicationCommandOptionWithChoicesMixin = class {
    static {
      __name(this, "ApplicationCommandOptionWithChoicesMixin");
    }
    choices;
    type;
    addChoices(...choices) {
      const normalizedChoices = normalizeArray(choices);
      if (normalizedChoices.length > 0 && "autocomplete" in this && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(normalizedChoices);
      if (this.choices === undefined) {
        Reflect.set(this, "choices", []);
      }
      validateChoicesLength(normalizedChoices.length, this.choices);
      for (const { name, name_localizations, value } of normalizedChoices) {
        if (this.type === import_v1026.ApplicationCommandOptionType.String) {
          stringPredicate.parse(value);
        } else {
          numberPredicate.parse(value);
        }
        this.choices.push({ name, name_localizations, value });
      }
      return this;
    }
    setChoices(...choices) {
      const normalizedChoices = normalizeArray(choices);
      if (normalizedChoices.length > 0 && "autocomplete" in this && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(normalizedChoices);
      Reflect.set(this, "choices", []);
      this.addChoices(normalizedChoices);
      return this;
    }
  };
  var numberValidator = import_shapeshift10.s.number().int();
  var SlashCommandIntegerOption = class extends ApplicationCommandOptionBase {
    type = import_v1027.ApplicationCommandOptionType.Integer;
    setMaxValue(max) {
      numberValidator.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandIntegerOption, "SlashCommandIntegerOption");
  SlashCommandIntegerOption = __decorateClass([
    (0, import_ts_mixer2.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithAutocompleteMixin, ApplicationCommandOptionWithChoicesMixin)
  ], SlashCommandIntegerOption);
  var import_v1028 = require_v106();
  var SlashCommandMentionableOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandMentionableOption");
    }
    type = import_v1028.ApplicationCommandOptionType.Mentionable;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift11 = require_cjs3();
  var import_v1029 = require_v106();
  var import_ts_mixer3 = require_cjs4();
  var numberValidator2 = import_shapeshift11.s.number();
  var SlashCommandNumberOption = class extends ApplicationCommandOptionBase {
    type = import_v1029.ApplicationCommandOptionType.Number;
    setMaxValue(max) {
      numberValidator2.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator2.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandNumberOption, "SlashCommandNumberOption");
  SlashCommandNumberOption = __decorateClass([
    (0, import_ts_mixer3.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithAutocompleteMixin, ApplicationCommandOptionWithChoicesMixin)
  ], SlashCommandNumberOption);
  var import_v1030 = require_v106();
  var SlashCommandRoleOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandRoleOption");
    }
    type = import_v1030.ApplicationCommandOptionType.Role;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift12 = require_cjs3();
  var import_v1031 = require_v106();
  var import_ts_mixer4 = require_cjs4();
  var minLengthValidator2 = import_shapeshift12.s.number().greaterThanOrEqual(0).lessThanOrEqual(6000);
  var maxLengthValidator2 = import_shapeshift12.s.number().greaterThanOrEqual(1).lessThanOrEqual(6000);
  var SlashCommandStringOption = class extends ApplicationCommandOptionBase {
    type = import_v1031.ApplicationCommandOptionType.String;
    max_length;
    min_length;
    setMaxLength(max) {
      maxLengthValidator2.parse(max);
      Reflect.set(this, "max_length", max);
      return this;
    }
    setMinLength(min) {
      minLengthValidator2.parse(min);
      Reflect.set(this, "min_length", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandStringOption, "SlashCommandStringOption");
  SlashCommandStringOption = __decorateClass([
    (0, import_ts_mixer4.mix)(ApplicationCommandOptionWithAutocompleteMixin, ApplicationCommandOptionWithChoicesMixin)
  ], SlashCommandStringOption);
  var import_v1032 = require_v106();
  var SlashCommandUserOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandUserOption");
    }
    type = import_v1032.ApplicationCommandOptionType.User;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var SharedSlashCommandOptions = class {
    static {
      __name(this, "SharedSlashCommandOptions");
    }
    options;
    addBooleanOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandBooleanOption);
    }
    addUserOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandUserOption);
    }
    addChannelOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandChannelOption);
    }
    addRoleOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandRoleOption);
    }
    addAttachmentOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandAttachmentOption);
    }
    addMentionableOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandMentionableOption);
    }
    addStringOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandStringOption);
    }
    addIntegerOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandIntegerOption);
    }
    addNumberOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandNumberOption);
    }
    _sharedAddOptionMethod(input, Instance) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new Instance) : input;
      assertReturnOfBuilder2(result, Instance);
      options.push(result);
      return this;
    }
  };
  var import_v1033 = require_v106();
  var import_ts_mixer5 = require_cjs4();
  var SlashCommandSubcommandGroupBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder2(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1033.ApplicationCommandOptionType.SubcommandGroup,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandGroupBuilder, "SlashCommandSubcommandGroupBuilder");
  SlashCommandSubcommandGroupBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription)
  ], SlashCommandSubcommandGroupBuilder);
  var SlashCommandSubcommandBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1033.ApplicationCommandOptionType.Subcommand,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandBuilder, "SlashCommandSubcommandBuilder");
  SlashCommandSubcommandBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription, SharedSlashCommandOptions)
  ], SlashCommandSubcommandBuilder);
  var SharedSlashCommandSubcommands = class {
    static {
      __name(this, "SharedSlashCommandSubcommands");
    }
    options = [];
    addSubcommandGroup(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandGroupBuilder) : input;
      assertReturnOfBuilder2(result, SlashCommandSubcommandGroupBuilder);
      options.push(result);
      return this;
    }
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder2(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
  };
  var SlashCommandBuilder = class {
    name = undefined;
    name_localizations;
    description = undefined;
    description_localizations;
    options = [];
    contexts;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    integration_types;
    nsfw = undefined;
  };
  __name(SlashCommandBuilder, "SlashCommandBuilder");
  SlashCommandBuilder = __decorateClass([
    (0, import_ts_mixer6.mix)(SharedSlashCommandOptions, SharedNameAndDescription, SharedSlashCommandSubcommands, SharedSlashCommand)
  ], SlashCommandBuilder);
  var Assertions_exports7 = {};
  __export2(Assertions_exports7, {
    contextsPredicate: () => contextsPredicate2,
    integrationTypesPredicate: () => integrationTypesPredicate2,
    validateDMPermission: () => validateDMPermission2,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions2,
    validateDefaultPermission: () => validateDefaultPermission2,
    validateName: () => validateName2,
    validateRequiredParameters: () => validateRequiredParameters4,
    validateType: () => validateType
  });
  var import_shapeshift13 = require_cjs3();
  var import_v1034 = require_v106();
  var namePredicate2 = import_shapeshift13.s.string().lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/\S/).setValidationEnabled(isValidationEnabled);
  var typePredicate = import_shapeshift13.s.union([import_shapeshift13.s.literal(import_v1034.ApplicationCommandType.User), import_shapeshift13.s.literal(import_v1034.ApplicationCommandType.Message)]).setValidationEnabled(isValidationEnabled);
  var booleanPredicate3 = import_shapeshift13.s.boolean();
  function validateDefaultPermission2(value) {
    booleanPredicate3.parse(value);
  }
  __name(validateDefaultPermission2, "validateDefaultPermission");
  function validateName2(name) {
    namePredicate2.parse(name);
  }
  __name(validateName2, "validateName");
  function validateType(type) {
    typePredicate.parse(type);
  }
  __name(validateType, "validateType");
  function validateRequiredParameters4(name, type) {
    validateName2(name);
    validateType(type);
  }
  __name(validateRequiredParameters4, "validateRequiredParameters");
  var dmPermissionPredicate2 = import_shapeshift13.s.boolean().nullish();
  function validateDMPermission2(value) {
    dmPermissionPredicate2.parse(value);
  }
  __name(validateDMPermission2, "validateDMPermission");
  var memberPermissionPredicate2 = import_shapeshift13.s.union([
    import_shapeshift13.s.bigint().transform((value) => value.toString()),
    import_shapeshift13.s.number().safeInt().transform((value) => value.toString()),
    import_shapeshift13.s.string().regex(/^\d+$/)
  ]).nullish();
  function validateDefaultMemberPermissions2(permissions) {
    return memberPermissionPredicate2.parse(permissions);
  }
  __name(validateDefaultMemberPermissions2, "validateDefaultMemberPermissions");
  var contextsPredicate2 = import_shapeshift13.s.array(import_shapeshift13.s.nativeEnum(import_v1034.InteractionContextType).setValidationEnabled(isValidationEnabled));
  var integrationTypesPredicate2 = import_shapeshift13.s.array(import_shapeshift13.s.nativeEnum(import_v1034.ApplicationIntegrationType).setValidationEnabled(isValidationEnabled));
  var ContextMenuCommandBuilder = class {
    static {
      __name(this, "ContextMenuCommandBuilder");
    }
    name = undefined;
    name_localizations;
    type = undefined;
    contexts;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    integration_types;
    setContexts(...contexts) {
      Reflect.set(this, "contexts", contextsPredicate2.parse(normalizeArray(contexts)));
      return this;
    }
    setIntegrationTypes(...integrationTypes) {
      Reflect.set(this, "integration_types", integrationTypesPredicate2.parse(normalizeArray(integrationTypes)));
      return this;
    }
    setName(name) {
      validateName2(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setType(type) {
      validateType(type);
      Reflect.set(this, "type", type);
      return this;
    }
    setDefaultPermission(value) {
      validateDefaultPermission2(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions2(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission2(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName2(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames))
        this.setNameLocalization(...args);
      return this;
    }
    toJSON() {
      validateRequiredParameters4(this.name, this.type);
      validateLocalizationMap(this.name_localizations);
      return { ...this };
    }
  };
  function embedLength(data) {
    return (data.title?.length ?? 0) + (data.description?.length ?? 0) + (data.fields?.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) ?? 0) + (data.footer?.text.length ?? 0) + (data.author?.name.length ?? 0);
  }
  __name(embedLength, "embedLength");
  var version = "1.11.3";
});

// ../../node_modules/discord.js/src/structures/Embed.js
var require_Embed = __commonJS((exports, module) => {
  var { embedLength } = require_dist8();
  var isEqual = require_fast_deep_equal();

  class Embed {
    constructor(data) {
      this.data = { ...data };
    }
    get fields() {
      return this.data.fields ?? [];
    }
    get title() {
      return this.data.title ?? null;
    }
    get description() {
      return this.data.description ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
    get color() {
      return this.data.color ?? null;
    }
    get timestamp() {
      return this.data.timestamp ?? null;
    }
    get thumbnail() {
      if (!this.data.thumbnail)
        return null;
      return {
        url: this.data.thumbnail.url,
        proxyURL: this.data.thumbnail.proxy_url,
        height: this.data.thumbnail.height,
        width: this.data.thumbnail.width
      };
    }
    get image() {
      if (!this.data.image)
        return null;
      return {
        url: this.data.image.url,
        proxyURL: this.data.image.proxy_url,
        height: this.data.image.height,
        width: this.data.image.width
      };
    }
    get video() {
      if (!this.data.video)
        return null;
      return {
        url: this.data.video.url,
        proxyURL: this.data.video.proxy_url,
        height: this.data.video.height,
        width: this.data.video.width
      };
    }
    get author() {
      if (!this.data.author)
        return null;
      return {
        name: this.data.author.name,
        url: this.data.author.url,
        iconURL: this.data.author.icon_url,
        proxyIconURL: this.data.author.proxy_icon_url
      };
    }
    get provider() {
      return this.data.provider ?? null;
    }
    get footer() {
      if (!this.data.footer)
        return null;
      return {
        text: this.data.footer.text,
        iconURL: this.data.footer.icon_url,
        proxyIconURL: this.data.footer.proxy_icon_url
      };
    }
    get length() {
      return embedLength(this.data);
    }
    get hexColor() {
      return typeof this.data.color === "number" ? `#${this.data.color.toString(16).padStart(6, "0")}` : this.data.color ?? null;
    }
    toJSON() {
      return { ...this.data };
    }
    equals(other) {
      if (other instanceof Embed) {
        return isEqual(this.data, other.data);
      }
      return this.author?.iconURL === other.author?.icon_url && this.author?.name === other.author?.name && this.author?.url === other.author?.url && this.color === (other.color ?? null) && this.description === (other.description ?? null) && this.footer?.iconURL === other.footer?.icon_url && this.footer?.text === other.footer?.text && this.image?.url === other.image?.url && this.thumbnail?.url === other.thumbnail?.url && (this.timestamp && Date.parse(this.timestamp)) === (other.timestamp ? Date.parse(other.timestamp) : null) && this.title === (other.title ?? null) && this.url === (other.url ?? null) && this.video?.url === other.video?.url && isEqual(this.fields, other.fields?.map((field) => ({ ...field, inline: field.inline ?? false })) ?? []) && isEqual(this.provider, other.provider ?? null);
    }
  }
  module.exports = Embed;
});

// ../../node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { FormattingPatterns } = require_v106();
  var { flatten } = require_Util();

  class MessageMentions {
    static EveryonePattern = /@(?<mention>everyone|here)/;
    static UsersPattern = FormattingPatterns.UserWithOptionalNickname;
    static RolesPattern = FormattingPatterns.Role;
    static ChannelsPattern = FormattingPatterns.Channel;
    static GlobalChannelsPattern = new RegExp(this.ChannelsPattern.source, "g");
    static GlobalUsersPattern = new RegExp(this.UsersPattern.source, "g");
    constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {
      Object.defineProperty(this, "client", { value: message.client });
      Object.defineProperty(this, "guild", { value: message.guild });
      Object.defineProperty(this, "_content", { value: message.content });
      this.everyone = Boolean(everyone);
      if (users) {
        if (users instanceof Collection) {
          this.users = new Collection(users);
        } else {
          this.users = new Collection;
          for (const mention of users) {
            if (mention.member && message.guild) {
              message.guild.members._add(Object.assign(mention.member, { user: mention }));
            }
            const user = message.client.users._add(mention);
            this.users.set(user.id, user);
          }
        }
      } else {
        this.users = new Collection;
      }
      if (roles instanceof Collection) {
        this.roles = new Collection(roles);
      } else if (roles) {
        this.roles = new Collection;
        const guild = message.guild;
        if (guild) {
          for (const mention of roles) {
            const role = guild.roles.cache.get(mention);
            if (role)
              this.roles.set(role.id, role);
          }
        }
      } else {
        this.roles = new Collection;
      }
      this._members = null;
      this._channels = null;
      this._parsedUsers = null;
      if (crosspostedChannels) {
        if (crosspostedChannels instanceof Collection) {
          this.crosspostedChannels = new Collection(crosspostedChannels);
        } else {
          this.crosspostedChannels = new Collection;
          for (const crosspostedChannel of crosspostedChannels) {
            this.crosspostedChannels.set(crosspostedChannel.id, {
              channelId: crosspostedChannel.id,
              guildId: crosspostedChannel.guild_id,
              type: crosspostedChannel.type,
              name: crosspostedChannel.name
            });
          }
        }
      } else {
        this.crosspostedChannels = new Collection;
      }
      this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;
    }
    get members() {
      if (this._members)
        return this._members;
      if (!this.guild)
        return null;
      this._members = new Collection;
      this.users.forEach((user) => {
        const member = this.guild.members.resolve(user);
        if (member)
          this._members.set(member.user.id, member);
      });
      return this._members;
    }
    get channels() {
      if (this._channels)
        return this._channels;
      this._channels = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {
        const channel = this.client.channels.cache.get(matches.groups.id);
        if (channel)
          this._channels.set(channel.id, channel);
      }
      return this._channels;
    }
    get parsedUsers() {
      if (this._parsedUsers)
        return this._parsedUsers;
      this._parsedUsers = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {
        const user = this.client.users.cache.get(matches[1]);
        if (user)
          this._parsedUsers.set(user.id, user);
      }
      return this._parsedUsers;
    }
    has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {
      const user = this.client.users.resolve(data);
      if (!ignoreEveryone && user && this.everyone)
        return true;
      const userWasRepliedTo = user && this.repliedUser?.id === user.id;
      if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id))
        return true;
      if (!ignoreDirect) {
        if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id))
          return true;
        const role = this.guild?.roles.resolve(data);
        if (role && this.roles.has(role.id))
          return true;
        const channel = this.client.channels.resolve(data);
        if (channel && this.channels.has(channel.id))
          return true;
      }
      if (!ignoreRoles) {
        const member = this.guild?.members.resolve(data);
        if (member) {
          for (const mentionedRole of this.roles.values())
            if (member.roles.cache.has(mentionedRole.id))
              return true;
        }
      }
      return false;
    }
    toJSON() {
      return flatten(this, {
        members: true,
        channels: true
      });
    }
  }
  module.exports = MessageMentions;
});

// ../../node_modules/discord.js/src/structures/PollAnswer.js
var require_PollAnswer = __commonJS((exports) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class PollAnswer extends Base {
    constructor(client, data, poll) {
      super(client);
      Object.defineProperty(this, "poll", { value: poll });
      this.id = data.answer_id;
      this.text = data.poll_media.text ?? null;
      Object.defineProperty(this, "_emoji", { value: data.poll_media.emoji ?? null });
      this._patch(data);
    }
    _patch(data) {
      if ("count" in data) {
        this.voteCount = data.count;
      } else {
        this.voteCount ??= 0;
      }
    }
    get emoji() {
      if (!this._emoji || !this._emoji.id && !this._emoji.name)
        return null;
      return this.client.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
    fetchVoters({ after, limit } = {}) {
      return this.poll.message.channel.messages.fetchPollAnswerVoters({
        messageId: this.poll.message.id,
        answerId: this.id,
        after,
        limit
      });
    }
  }
  exports.PollAnswer = PollAnswer;
});

// ../../node_modules/discord.js/src/structures/Poll.js
var require_Poll = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { PollAnswer } = require_PollAnswer();
  var { DiscordjsError } = require_DJSError();
  var { ErrorCodes } = require_errors();

  class Poll extends Base {
    constructor(client, data, message) {
      super(client);
      Object.defineProperty(this, "message", { value: message });
      this.question = {
        text: data.question.text
      };
      this.answers = data.answers.reduce((acc, answer) => acc.set(answer.answer_id, new PollAnswer(this.client, answer, this)), new Collection);
      this.expiresTimestamp = Date.parse(data.expiry);
      this.allowMultiselect = data.allow_multiselect;
      this.layoutType = data.layout_type;
      this._patch(data);
    }
    _patch(data) {
      if (data.results) {
        this.resultsFinalized = data.results.is_finalized;
        for (const answerResult of data.results.answer_counts) {
          const answer = this.answers.get(answerResult.id);
          answer?._patch(answerResult);
        }
      } else {
        this.resultsFinalized ??= false;
      }
    }
    get expiresAt() {
      return new Date(this.expiresTimestamp);
    }
    async end() {
      if (Date.now() > this.expiresTimestamp) {
        throw new DiscordjsError(ErrorCodes.PollAlreadyExpired);
      }
      return this.message.channel.messages.endPoll(this.message.id);
    }
  }
  exports.Poll = Poll;
});

// ../../node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Collector = require_Collector();
  var Events = require_Events();

  class ReactionCollector extends Collector {
    constructor(message, options = {}) {
      super(message.client, options);
      this.message = message;
      this.users = new Collection;
      this.total = 0;
      this.empty = this.empty.bind(this);
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.message.id))
          this.stop("messageDelete");
      };
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageReactionAdd, this.handleCollect);
      this.client.on(Events.MessageReactionRemove, this.handleDispose);
      this.client.on(Events.MessageReactionRemoveAll, this.empty);
      this.client.on(Events.MessageDelete, this._handleMessageDeletion);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageReactionAdd, this.handleCollect);
        this.client.removeListener(Events.MessageReactionRemove, this.handleDispose);
        this.client.removeListener(Events.MessageReactionRemoveAll, this.empty);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (reaction, user) => {
        if (reaction.count === 1) {
          this.emit("create", reaction, user);
        }
        this.total++;
        this.users.set(user.id, user);
      });
      this.on("remove", (_reaction, user) => {
        this.total--;
        if (!this.collected.some((reaction) => reaction.users.cache.has(user.id)))
          this.users.delete(user.id);
      });
    }
    collect(reaction) {
      if (reaction.message.id !== this.message.id)
        return null;
      return ReactionCollector.key(reaction);
    }
    dispose(reaction, user) {
      if (reaction.message.id !== this.message.id)
        return null;
      if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {
        this.emit("remove", reaction, user);
      }
      return reaction.count ? null : ReactionCollector.key(reaction);
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
        return "emojiLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.message.id) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.message.channelId || channel.threads?.cache.has(this.message.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.message.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.message.guild?.id) {
        this.stop("guildDelete");
      }
    }
    static key(reaction) {
      return reaction.emoji.id ?? reaction.emoji.name;
    }
  }
  module.exports = ReactionCollector;
});

// ../../node_modules/discord.js/src/structures/Sticker.js
var require_Sticker = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var { Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var { StickerFormatExtensionMap } = require_Constants();

  class Sticker extends Base {
    constructor(client, sticker) {
      super(client);
      this._patch(sticker);
    }
    _patch(sticker) {
      this.id = sticker.id;
      if ("description" in sticker) {
        this.description = sticker.description;
      } else {
        this.description ??= null;
      }
      if ("type" in sticker) {
        this.type = sticker.type;
      } else {
        this.type ??= null;
      }
      if ("format_type" in sticker) {
        this.format = sticker.format_type;
      }
      if ("name" in sticker) {
        this.name = sticker.name;
      }
      if ("pack_id" in sticker) {
        this.packId = sticker.pack_id;
      } else {
        this.packId ??= null;
      }
      if ("tags" in sticker) {
        this.tags = sticker.tags;
      } else {
        this.tags ??= null;
      }
      if ("available" in sticker) {
        this.available = sticker.available;
      } else {
        this.available ??= null;
      }
      if ("guild_id" in sticker) {
        this.guildId = sticker.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("user" in sticker) {
        this.user = this.client.users._add(sticker.user);
      } else {
        this.user ??= null;
      }
      if ("sort_value" in sticker) {
        this.sortValue = sticker.sort_value;
      } else {
        this.sortValue ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get partial() {
      return !this.type;
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return this.client.rest.cdn.sticker(this.id, StickerFormatExtensionMap[this.format]);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.sticker(this.id));
      this._patch(data);
      return this;
    }
    async fetchPack() {
      if (!this.packId)
        return null;
      return this.client.fetchStickerPacks({ packId: this.packId });
    }
    async fetchUser() {
      if (this.partial)
        await this.fetch();
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSticker);
      return this.guild.stickers.fetchUser(this);
    }
    edit(options) {
      return this.guild.stickers.edit(this, options);
    }
    async delete(reason) {
      await this.guild.stickers.delete(this, reason);
      return this;
    }
    equals(other) {
      if (other instanceof Sticker) {
        return other.id === this.id && other.description === this.description && other.type === this.type && other.format === this.format && other.name === this.name && other.packId === this.packId && other.tags === this.tags && other.available === this.available && other.guildId === this.guildId && other.sortValue === this.sortValue;
      } else {
        return other.id === this.id && other.description === this.description && other.name === this.name && other.tags === this.tags;
      }
    }
  }
  exports.Sticker = Sticker;
});

// ../../node_modules/discord.js/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class BaseGuildEmoji extends Emoji {
    constructor(client, data, guild) {
      super(client, data);
      this.guild = guild;
      this.requiresColons = null;
      this.managed = null;
      this.available = null;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data)
        this.name = data.name;
      if ("require_colons" in data) {
        this.requiresColons = data.require_colons;
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("available" in data) {
        this.available = data.available;
      }
    }
  }
  module.exports = BaseGuildEmoji;
});

// ../../node_modules/discord.js/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Role } = require_Role();

  class GuildEmojiRoleManager extends DataManager {
    constructor(emoji) {
      super(emoji.client, Role);
      this.emoji = emoji;
      this.guild = emoji.guild;
    }
    get cache() {
      return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
    }
    async add(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoles = [];
      for (const role of roleOrRoles.values()) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
        }
        resolvedRoles.push(resolvedRole);
      }
      const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
      return this.set(newRoles);
    }
    async remove(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoleIds = [];
      for (const role of roleOrRoles.values()) {
        const roleId = this.guild.roles.resolveId(role);
        if (!roleId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
        }
        resolvedRoleIds.push(roleId);
      }
      const newRoles = [...this.cache.keys()].filter((id) => !resolvedRoleIds.includes(id));
      return this.set(newRoles);
    }
    set(roles) {
      return this.emoji.edit({ roles });
    }
    clone() {
      const clone = new this.constructor(this.emoji);
      clone._patch([...this.cache.keys()]);
      return clone;
    }
    _patch(roles) {
      this.emoji._roles = roles;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = GuildEmojiRoleManager;
});

// ../../node_modules/discord.js/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BaseGuildEmoji = require_BaseGuildEmoji();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var GuildEmojiRoleManager = require_GuildEmojiRoleManager();

  class GuildEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.author = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      this._patch(data);
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    _patch(data) {
      super._patch(data);
      if (data.user)
        this.author = this.client.users._add(data.user);
      if (data.roles)
        this._roles = data.roles;
    }
    get deletable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return !this.managed && this.guild.members.me.permissions.has(PermissionFlagsBits.ManageGuildExpressions);
    }
    get roles() {
      return new GuildEmojiRoleManager(this);
    }
    fetchAuthor() {
      return this.guild.emojis.fetchAuthor(this);
    }
    edit(options) {
      return this.guild.emojis.edit(this.id, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    async delete(reason) {
      await this.guild.emojis.delete(this.id, reason);
      return this;
    }
    equals(other) {
      if (other instanceof GuildEmoji) {
        return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
      } else {
        return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
      }
    }
  }
  module.exports = GuildEmoji;
});

// ../../node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();
  var { flatten } = require_Util();

  class ReactionEmoji extends Emoji {
    constructor(reaction, emoji) {
      super(reaction.message.client, emoji);
      this.reaction = reaction;
    }
    toJSON() {
      return flatten(this, { identifier: true });
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = ReactionEmoji;
});

// ../../node_modules/discord.js/src/util/UserFlagsBitField.js
var require_UserFlagsBitField = __commonJS((exports, module) => {
  var { UserFlags } = require_v106();
  var BitField = require_BitField();

  class UserFlagsBitField extends BitField {
    static Flags = UserFlags;
  }
  module.exports = UserFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/User.js
var require_User = __commonJS((exports, module) => {
  var { userMention } = require_dist7();
  var { calculateUserDefaultAvatarIndex } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var TextBasedChannel = require_TextBasedChannel();
  var { _transformCollectibles } = require_Transformers();
  var UserFlagsBitField = require_UserFlagsBitField();
  var { emitDeprecationWarningForUserFetchFlags } = require_Util();

  class User extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.bot = null;
      this.system = null;
      this.flags = null;
      this._patch(data);
    }
    _patch(data) {
      if ("username" in data) {
        this.username = data.username;
      } else {
        this.username ??= null;
      }
      if ("global_name" in data) {
        this.globalName = data.global_name;
      } else {
        this.globalName ??= null;
      }
      if ("bot" in data) {
        this.bot = Boolean(data.bot);
      } else if (!this.partial && typeof this.bot !== "boolean") {
        this.bot = false;
      }
      if ("discriminator" in data) {
        this.discriminator = data.discriminator;
      } else {
        this.discriminator ??= null;
      }
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else {
        this.avatar ??= null;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      } else if (this.banner !== null) {
        this.banner ??= undefined;
      }
      if ("accent_color" in data) {
        this.accentColor = data.accent_color;
      } else if (this.accentColor !== null) {
        this.accentColor ??= undefined;
      }
      if ("system" in data) {
        this.system = Boolean(data.system);
      } else if (!this.partial && typeof this.system !== "boolean") {
        this.system = false;
      }
      if ("public_flags" in data) {
        this.flags = new UserFlagsBitField(data.public_flags);
      }
      if ("avatar_decoration" in data) {
        this.avatarDecoration = data.avatar_decoration;
      } else {
        this.avatarDecoration ??= null;
      }
      if ("avatar_decoration_data" in data) {
        if (data.avatar_decoration_data) {
          this.avatarDecorationData = {
            asset: data.avatar_decoration_data.asset,
            skuId: data.avatar_decoration_data.sku_id
          };
        } else {
          this.avatarDecorationData = null;
        }
      } else {
        this.avatarDecorationData ??= null;
      }
      if (data.collectibles) {
        this.collectibles = _transformCollectibles(data.collectibles);
      } else {
        this.collectibles = null;
      }
      if ("primary_guild" in data) {
        if (data.primary_guild) {
          this.primaryGuild = {
            identityGuildId: data.primary_guild.identity_guild_id,
            identityEnabled: data.primary_guild.identity_enabled,
            tag: data.primary_guild.tag,
            badge: data.primary_guild.badge
          };
        } else {
          this.primaryGuild = null;
        }
      } else {
        this.primaryGuild ??= null;
      }
    }
    get partial() {
      return typeof this.username !== "string";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    avatarDecorationURL(options = {}) {
      if (this.avatarDecorationData) {
        return this.client.rest.cdn.avatarDecoration(this.avatarDecorationData.asset);
      }
      return this.avatarDecoration && this.client.rest.cdn.avatarDecoration(this.id, this.avatarDecoration, options);
    }
    get defaultAvatarURL() {
      const index = this.discriminator === "0" ? calculateUserDefaultAvatarIndex(this.id) : this.discriminator % 5;
      return this.client.rest.cdn.defaultAvatar(index);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.defaultAvatarURL;
    }
    get hexAccentColor() {
      if (typeof this.accentColor !== "number")
        return this.accentColor;
      return `#${this.accentColor.toString(16).padStart(6, "0")}`;
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    guildTagBadgeURL(options = {}) {
      return this.primaryGuild?.badge ? this.client.rest.cdn.guildTagBadge(this.primaryGuild.identityGuildId, this.primaryGuild.badge, options) : null;
    }
    get tag() {
      return typeof this.username === "string" ? this.discriminator === "0" ? this.username : `${this.username}#${this.discriminator}` : null;
    }
    get displayName() {
      return this.globalName ?? this.username;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    createDM(force = false) {
      return this.client.users.createDM(this.id, { force });
    }
    deleteDM() {
      return this.client.users.deleteDM(this.id);
    }
    equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.globalName && this.avatar === user.avatar && this.flags?.bitfield === user.flags?.bitfield && this.banner === user.banner && this.accentColor === user.accentColor && this.avatarDecoration === user.avatarDecoration && this.avatarDecorationData?.asset === user.avatarDecorationData?.asset && this.avatarDecorationData?.skuId === user.avatarDecorationData?.skuId && this.collectibles?.nameplate?.skuId === user.collectibles?.nameplate?.skuId && this.collectibles?.nameplate?.asset === user.collectibles?.nameplate?.asset && this.collectibles?.nameplate?.label === user.collectibles?.nameplate?.label && this.collectibles?.nameplate?.palette === user.collectibles?.nameplate?.palette && this.primaryGuild?.identityGuildId === user.primaryGuild?.identityGuildId && this.primaryGuild?.identityEnabled === user.primaryGuild?.identityEnabled && this.primaryGuild?.tag === user.primaryGuild?.tag && this.primaryGuild?.badge === user.primaryGuild?.badge;
    }
    _equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.global_name && this.avatar === user.avatar && this.flags?.bitfield === user.public_flags && ("banner" in user ? this.banner === user.banner : true) && ("accent_color" in user ? this.accentColor === user.accent_color : true) && ("avatar_decoration" in user ? this.avatarDecoration === user.avatar_decoration : true) && ("avatar_decoration_data" in user ? this.avatarDecorationData?.asset === user.avatar_decoration_data?.asset && this.avatarDecorationData?.skuId === user.avatar_decoration_data?.sku_id : true) && ("collectibles" in user ? this.collectibles?.nameplate?.skuId === user.collectibles?.nameplate?.sku_id && this.collectibles?.nameplate?.asset === user.collectibles?.nameplate?.asset && this.collectibles?.nameplate?.label === user.collectibles?.nameplate?.label && this.collectibles?.nameplate?.palette === user.collectibles?.nameplate?.palette : true) && ("primary_guild" in user ? this.primaryGuild?.identityGuildId === user.primary_guild?.identity_guild_id && this.primaryGuild?.identityEnabled === user.primary_guild?.identity_enabled && this.primaryGuild?.tag === user.primary_guild?.tag && this.primaryGuild?.badge === user.primary_guild?.badge : true);
    }
    fetchFlags(force = false) {
      emitDeprecationWarningForUserFetchFlags(this.constructor.name);
      return this.client.users.fetchFlags(this.id, { force });
    }
    fetch(force = true) {
      return this.client.users.fetch(this.id, { force });
    }
    toString() {
      return userMention(this.id);
    }
    toJSON(...props) {
      const json = super.toJSON({
        createdTimestamp: true,
        defaultAvatarURL: true,
        hexAccentColor: true,
        tag: true
      }, ...props);
      json.avatarURL = this.avatarURL();
      json.displayAvatarURL = this.displayAvatarURL();
      json.bannerURL = this.banner ? this.bannerURL() : this.banner;
      json.guildTagBadgeURL = this.guildTagBadgeURL();
      return json;
    }
  }
  TextBasedChannel.applyToClass(User);
  module.exports = User;
});

// ../../node_modules/discord.js/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { ReactionType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var User = require_User();

  class ReactionUserManager extends CachedManager {
    constructor(reaction, iterable) {
      super(reaction.client, User, iterable);
      this.reaction = reaction;
    }
    async fetch({ type = ReactionType.Normal, limit = 100, after } = {}) {
      const message = this.reaction.message;
      const query = makeURLSearchParams({ limit, after, type });
      const data = await this.client.rest.get(Routes.channelMessageReaction(message.channelId, message.id, this.reaction.emoji.identifier), { query });
      const users = new Collection;
      for (const rawUser of data) {
        const user = this.client.users._add(rawUser);
        this.cache.set(user.id, user);
        users.set(user.id, user);
      }
      return users;
    }
    async remove(user = this.client.user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsError(ErrorCodes.ReactionResolveUser);
      const message = this.reaction.message;
      const route = userId === this.client.user.id ? Routes.channelMessageOwnReaction(message.channelId, message.id, this.reaction.emoji.identifier) : Routes.channelMessageUserReaction(message.channelId, message.id, this.reaction.emoji.identifier, userId);
      await this.client.rest.delete(route);
      return this.reaction;
    }
  }
  module.exports = ReactionUserManager;
});

// ../../node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var ApplicationEmoji = require_ApplicationEmoji();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var ReactionUserManager = require_ReactionUserManager();
  var { flatten } = require_Util();

  class MessageReaction {
    constructor(client, data, message) {
      Object.defineProperty(this, "client", { value: client });
      this.message = message;
      this.me = data.me;
      this.meBurst = Boolean(data.me_burst);
      this.users = new ReactionUserManager(this, this.me ? [client.user] : []);
      this._emoji = new ReactionEmoji(this, data.emoji);
      this.burstColors = null;
      this._patch(data);
    }
    _patch(data) {
      if (data.burst_colors) {
        this.burstColors = data.burst_colors;
      }
      if ("count" in data) {
        this.count ??= data.count;
      }
      if ("count_details" in data) {
        this.countDetails = {
          burst: data.count_details.burst,
          normal: data.count_details.normal
        };
      } else {
        this.countDetails ??= { burst: 0, normal: 0 };
      }
    }
    react() {
      return this.message.react(this.emoji);
    }
    async remove() {
      await this.client.rest.delete(Routes.channelMessageReaction(this.message.channelId, this.message.id, this._emoji.identifier));
      return this;
    }
    get emoji() {
      if (this._emoji instanceof GuildEmoji)
        return this._emoji;
      if (this._emoji instanceof ApplicationEmoji)
        return this._emoji;
      if (this._emoji.id) {
        const applicationEmojis = this.message.client.application.emojis.cache;
        if (applicationEmojis.has(this._emoji.id)) {
          const emoji = applicationEmojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
        const emojis = this.message.client.emojis.cache;
        if (emojis.has(this._emoji.id)) {
          const emoji = emojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
      }
      return this._emoji;
    }
    get partial() {
      return this.count === null;
    }
    async fetch() {
      const message = await this.message.fetch();
      const existing = message.reactions.cache.get(this.emoji.id ?? this.emoji.name);
      this._patch(existing ?? { count: 0 });
      return this;
    }
    toJSON() {
      return flatten(this, { emoji: "emojiId", message: "messageId" });
    }
    valueOf() {
      return this._emoji.id ?? this._emoji.name;
    }
    _add(user, burst) {
      if (this.partial)
        return;
      this.users.cache.set(user.id, user);
      if (!this.me || user.id !== this.message.client.user.id || this.count === 0) {
        this.count++;
        if (burst)
          this.countDetails.burst++;
        else
          this.countDetails.normal++;
      }
      if (user.id === this.message.client.user.id) {
        if (burst)
          this.meBurst = true;
        else
          this.me = true;
      }
    }
    _remove(user, burst) {
      if (this.partial)
        return;
      this.users.cache.delete(user.id);
      if (!this.me || user.id !== this.message.client.user.id) {
        this.count--;
        if (burst)
          this.countDetails.burst--;
        else
          this.countDetails.normal--;
      }
      if (user.id === this.message.client.user.id) {
        if (burst)
          this.meBurst = false;
        else
          this.me = false;
      }
      if (this.count <= 0 && this.users.cache.size === 0) {
        this.message.reactions.cache.delete(this.emoji.id ?? this.emoji.name);
      }
    }
  }
  module.exports = MessageReaction;
});

// ../../node_modules/discord.js/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var MessageReaction = require_MessageReaction();

  class ReactionManager extends CachedManager {
    constructor(message, iterable) {
      super(message.client, MessageReaction, iterable);
      this.message = message;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.emoji.id ?? data.emoji.name, extras: [this.message] });
    }
    async removeAll() {
      await this.client.rest.delete(Routes.channelMessageAllReactions(this.message.channelId, this.message.id));
      return this.message;
    }
  }
  module.exports = ReactionManager;
});

// ../../node_modules/discord.js/src/structures/Component.js
var require_Component = __commonJS((exports, module) => {
  var isEqual = require_fast_deep_equal();

  class Component {
    constructor(data) {
      this.data = data;
    }
    get id() {
      return this.data.id;
    }
    get type() {
      return this.data.type;
    }
    equals(other) {
      if (other instanceof Component) {
        return isEqual(other.data, this.data);
      }
      return isEqual(other, this.data);
    }
    toJSON() {
      return { ...this.data };
    }
  }
  module.exports = Component;
});

// ../../node_modules/discord.js/src/structures/ActionRow.js
var require_ActionRow = __commonJS((exports, module) => {
  var { deprecate } = __require("util");
  var { isJSONEncodable } = require_dist();
  var Component = require_Component();
  var { createComponent } = require_Components();

  class ActionRow extends Component {
    constructor({ components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
    }
    static from = deprecate((other) => new this(isJSONEncodable(other) ? other.toJSON() : other), "ActionRow.from() is deprecated. Use ActionRowBuilder.from() instead.");
    toJSON() {
      return { ...this.data, components: this.components.map((component) => component.toJSON()) };
    }
  }
  module.exports = ActionRow;
});

// ../../node_modules/discord.js/src/structures/ActionRowBuilder.js
var require_ActionRowBuilder = __commonJS((exports, module) => {
  var { ActionRowBuilder: BuildersActionRow } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { createComponentBuilder } = require_Components();
  var { toSnakeCase } = require_Transformers();

  class ActionRowBuilder extends BuildersActionRow {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((component) => createComponentBuilder(component))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ActionRowBuilder;
});

// ../../node_modules/discord.js/src/structures/ButtonBuilder.js
var require_ButtonBuilder = __commonJS((exports, module) => {
  var { ButtonBuilder: BuildersButton } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class ButtonBuilder extends BuildersButton {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({ ...data, emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ButtonBuilder;
});

// ../../node_modules/discord.js/src/structures/ButtonComponent.js
var require_ButtonComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class ButtonComponent extends Component {
    get style() {
      return this.data.style;
    }
    get label() {
      return this.data.label ?? null;
    }
    get emoji() {
      return this.data.emoji ?? null;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
    get customId() {
      return this.data.custom_id ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
  }
  module.exports = ButtonComponent;
});

// ../../node_modules/discord.js/src/structures/ChannelSelectMenuBuilder.js
var require_ChannelSelectMenuBuilder = __commonJS((exports, module) => {
  var { ChannelSelectMenuBuilder: BuildersChannelSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ChannelSelectMenuBuilder extends BuildersChannelSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ChannelSelectMenuBuilder;
});

// ../../node_modules/discord.js/src/structures/BaseSelectMenuComponent.js
var require_BaseSelectMenuComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class BaseSelectMenuComponent extends Component {
    get placeholder() {
      return this.data.placeholder ?? null;
    }
    get maxValues() {
      return this.data.max_values ?? null;
    }
    get minValues() {
      return this.data.min_values ?? null;
    }
    get customId() {
      return this.data.custom_id;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
  }
  module.exports = BaseSelectMenuComponent;
});

// ../../node_modules/discord.js/src/structures/ChannelSelectMenuComponent.js
var require_ChannelSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class ChannelSelectMenuComponent extends BaseSelectMenuComponent {
    get channelTypes() {
      return this.data.channel_types ?? null;
    }
  }
  module.exports = ChannelSelectMenuComponent;
});

// ../../node_modules/discord.js/src/structures/ContainerComponent.js
var require_ContainerComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var { createComponent } = require_Components();

  class ContainerComponent extends Component {
    constructor({ components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
    }
    get accentColor() {
      return this.data.accent_color ?? null;
    }
    get hexAccentColor() {
      return typeof this.data.accent_color === "number" ? `#${this.data.accent_color.toString(16).padStart(6, "0")}` : this.data.accent_color ?? null;
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, components: this.components.map((component) => component.toJSON()) };
    }
  }
  module.exports = ContainerComponent;
});

// ../../node_modules/discord.js/src/structures/UnfurledMediaItem.js
var require_UnfurledMediaItem = __commonJS((exports, module) => {
  class UnfurledMediaItem {
    constructor(data) {
      this.data = data;
    }
    get url() {
      return this.data.url;
    }
    toJSON() {
      return { ...this.data };
    }
  }
  module.exports = UnfurledMediaItem;
});

// ../../node_modules/discord.js/src/structures/FileComponent.js
var require_FileComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var UnfurledMediaItem = require_UnfurledMediaItem();

  class FileComponent extends Component {
    constructor({ file, ...data }) {
      super(data);
      this.file = new UnfurledMediaItem(file);
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, file: this.file.toJSON() };
    }
  }
  module.exports = FileComponent;
});

// ../../node_modules/discord.js/src/structures/MediaGalleryItem.js
var require_MediaGalleryItem = __commonJS((exports, module) => {
  var UnfurledMediaItem = require_UnfurledMediaItem();

  class MediaGalleryItem {
    constructor({ media, ...data }) {
      this.data = data;
      this.media = new UnfurledMediaItem(media);
    }
    get description() {
      return this.data.description ?? null;
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, media: this.media.toJSON() };
    }
  }
  module.exports = MediaGalleryItem;
});

// ../../node_modules/discord.js/src/structures/MediaGalleryComponent.js
var require_MediaGalleryComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var MediaGalleryItem = require_MediaGalleryItem();

  class MediaGalleryComponent extends Component {
    constructor({ items, ...data }) {
      super(data);
      this.items = items.map((item) => new MediaGalleryItem(item));
    }
    toJSON() {
      return { ...this.data, items: this.items.map((item) => item.toJSON()) };
    }
  }
  module.exports = MediaGalleryComponent;
});

// ../../node_modules/discord.js/src/structures/MentionableSelectMenuBuilder.js
var require_MentionableSelectMenuBuilder = __commonJS((exports, module) => {
  var { MentionableSelectMenuBuilder: BuildersMentionableSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class MentionableSelectMenuBuilder extends BuildersMentionableSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = MentionableSelectMenuBuilder;
});

// ../../node_modules/discord.js/src/structures/MentionableSelectMenuComponent.js
var require_MentionableSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class MentionableSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = MentionableSelectMenuComponent;
});

// ../../node_modules/discord.js/src/structures/RoleSelectMenuBuilder.js
var require_RoleSelectMenuBuilder = __commonJS((exports, module) => {
  var { RoleSelectMenuBuilder: BuildersRoleSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class RoleSelectMenuBuilder extends BuildersRoleSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = RoleSelectMenuBuilder;
});

// ../../node_modules/discord.js/src/structures/RoleSelectMenuComponent.js
var require_RoleSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class RoleSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = RoleSelectMenuComponent;
});

// ../../node_modules/discord.js/src/structures/SectionComponent.js
var require_SectionComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var { createComponent } = require_Components();

  class SectionComponent extends Component {
    constructor({ accessory, components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
      this.accessory = createComponent(accessory);
    }
    toJSON() {
      return {
        ...this.data,
        accessory: this.accessory.toJSON(),
        components: this.components.map((component) => component.toJSON())
      };
    }
  }
  module.exports = SectionComponent;
});

// ../../node_modules/discord.js/src/structures/SeparatorComponent.js
var require_SeparatorComponent = __commonJS((exports, module) => {
  var { SeparatorSpacingSize } = require_v106();
  var Component = require_Component();

  class SeparatorComponent extends Component {
    get spacing() {
      return this.data.spacing ?? SeparatorSpacingSize.Small;
    }
    get divider() {
      return this.data.divider ?? true;
    }
  }
  module.exports = SeparatorComponent;
});

// ../../node_modules/discord.js/src/structures/StringSelectMenuBuilder.js
var require_StringSelectMenuBuilder = __commonJS((exports, module) => {
  var { SelectMenuBuilder: BuildersSelectMenu, normalizeArray } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuBuilder extends BuildersSelectMenu {
    constructor({ options, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        options: options?.map(({ emoji, ...option }) => ({
          ...option,
          emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
        }))
      }));
    }
    static normalizeEmoji(selectMenuOption) {
      if (isJSONEncodable(selectMenuOption)) {
        return selectMenuOption;
      }
      const { emoji, ...option } = selectMenuOption;
      return {
        ...option,
        emoji: typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      };
    }
    addOptions(...options) {
      return super.addOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    setOptions(...options) {
      return super.setOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    static from(other) {
      if (isJSONEncodable(other)) {
        return new this(other.toJSON());
      }
      return new this(other);
    }
  }
  module.exports = StringSelectMenuBuilder;
});

// ../../node_modules/discord.js/src/structures/StringSelectMenuComponent.js
var require_StringSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class StringSelectMenuComponent extends BaseSelectMenuComponent {
    get options() {
      return this.data.options;
    }
  }
  module.exports = StringSelectMenuComponent;
});

// ../../node_modules/discord.js/src/structures/TextDisplayComponent.js
var require_TextDisplayComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class TextDisplayComponent extends Component {
    get content() {
      return this.data.content;
    }
  }
  module.exports = TextDisplayComponent;
});

// ../../node_modules/discord.js/src/structures/TextInputBuilder.js
var require_TextInputBuilder = __commonJS((exports, module) => {
  var { TextInputBuilder: BuildersTextInput } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class TextInputBuilder extends BuildersTextInput {
    constructor(data) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = TextInputBuilder;
});

// ../../node_modules/discord.js/src/structures/TextInputComponent.js
var require_TextInputComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class TextInputComponent extends Component {
    get customId() {
      return this.data.custom_id;
    }
    get value() {
      return this.data.value;
    }
  }
  module.exports = TextInputComponent;
});

// ../../node_modules/discord.js/src/structures/ThumbnailComponent.js
var require_ThumbnailComponent = __commonJS((exports, module) => {
  var Component = require_Component();
  var UnfurledMediaItem = require_UnfurledMediaItem();

  class ThumbnailComponent extends Component {
    constructor({ media, ...data }) {
      super(data);
      this.media = new UnfurledMediaItem(media);
    }
    get description() {
      return this.data.description ?? null;
    }
    get spoiler() {
      return this.data.spoiler ?? false;
    }
    toJSON() {
      return { ...this.data, media: this.media.toJSON() };
    }
  }
  module.exports = ThumbnailComponent;
});

// ../../node_modules/discord.js/src/structures/UserSelectMenuBuilder.js
var require_UserSelectMenuBuilder = __commonJS((exports, module) => {
  var { UserSelectMenuBuilder: BuildersUserSelectMenu } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class UserSelectMenuBuilder extends BuildersUserSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = UserSelectMenuBuilder;
});

// ../../node_modules/discord.js/src/structures/UserSelectMenuComponent.js
var require_UserSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class UserSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = UserSelectMenuComponent;
});

// ../../node_modules/discord.js/src/util/Components.js
var require_Components = __commonJS((exports, module) => {
  var { ComponentBuilder } = require_dist8();
  var { ComponentType } = require_v106();
  function createComponent(data) {
    return data instanceof Component ? data : new (ComponentTypeToComponent[data.type] ?? Component)(data);
  }
  function createComponentBuilder(data) {
    return data instanceof ComponentBuilder ? data : new (ComponentTypeToBuilder[data.type] ?? ComponentBuilder)(data);
  }
  function extractInteractiveComponents(component) {
    switch (component.type) {
      case ComponentType.ActionRow:
        return component.components;
      case ComponentType.Section:
        return [...component.components, component.accessory];
      case ComponentType.Container:
        return component.components.flatMap(extractInteractiveComponents);
      default:
        return [component];
    }
  }
  function findComponentByCustomId(components, customId) {
    return components.flatMap(extractInteractiveComponents).find((component) => (component.customId ?? component.custom_id) === customId) ?? null;
  }
  module.exports = { createComponent, createComponentBuilder, findComponentByCustomId };
  var ActionRow = require_ActionRow();
  var ActionRowBuilder = require_ActionRowBuilder();
  var ButtonBuilder = require_ButtonBuilder();
  var ButtonComponent = require_ButtonComponent();
  var ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  var ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  var Component = require_Component();
  var ContainerComponent = require_ContainerComponent();
  var FileComponent = require_FileComponent();
  var MediaGalleryComponent = require_MediaGalleryComponent();
  var MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  var MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  var RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  var RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  var SectionComponent = require_SectionComponent();
  var SeparatorComponent = require_SeparatorComponent();
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var TextDisplayComponent = require_TextDisplayComponent();
  var TextInputBuilder = require_TextInputBuilder();
  var TextInputComponent = require_TextInputComponent();
  var ThumbnailComponent = require_ThumbnailComponent();
  var UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  var UserSelectMenuComponent = require_UserSelectMenuComponent();
  var ComponentTypeToComponent = {
    [ComponentType.ActionRow]: ActionRow,
    [ComponentType.Button]: ButtonComponent,
    [ComponentType.StringSelect]: StringSelectMenuComponent,
    [ComponentType.TextInput]: TextInputComponent,
    [ComponentType.UserSelect]: UserSelectMenuComponent,
    [ComponentType.RoleSelect]: RoleSelectMenuComponent,
    [ComponentType.MentionableSelect]: MentionableSelectMenuComponent,
    [ComponentType.ChannelSelect]: ChannelSelectMenuComponent,
    [ComponentType.Container]: ContainerComponent,
    [ComponentType.TextDisplay]: TextDisplayComponent,
    [ComponentType.File]: FileComponent,
    [ComponentType.MediaGallery]: MediaGalleryComponent,
    [ComponentType.Section]: SectionComponent,
    [ComponentType.Separator]: SeparatorComponent,
    [ComponentType.Thumbnail]: ThumbnailComponent
  };
  var ComponentTypeToBuilder = {
    [ComponentType.ActionRow]: ActionRowBuilder,
    [ComponentType.Button]: ButtonBuilder,
    [ComponentType.StringSelect]: StringSelectMenuBuilder,
    [ComponentType.TextInput]: TextInputBuilder,
    [ComponentType.UserSelect]: UserSelectMenuBuilder,
    [ComponentType.RoleSelect]: RoleSelectMenuBuilder,
    [ComponentType.MentionableSelect]: MentionableSelectMenuBuilder,
    [ComponentType.ChannelSelect]: ChannelSelectMenuBuilder
  };
});

// ../../node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { messageLink } = require_dist7();
  var { DiscordSnowflake } = require_cjs();
  var {
    InteractionType,
    ChannelType,
    MessageType,
    MessageFlags,
    PermissionFlagsBits,
    MessageReferenceType
  } = require_v106();
  var Attachment = require_Attachment();
  var Base = require_Base();
  var ClientApplication = require_ClientApplication();
  var Embed = require_Embed();
  var InteractionCollector = require_InteractionCollector();
  var Mentions = require_MessageMentions();
  var MessagePayload = require_MessagePayload();
  var { Poll } = require_Poll();
  var ReactionCollector = require_ReactionCollector();
  var { Sticker } = require_Sticker();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var ReactionManager = require_ReactionManager();
  var { createComponent, findComponentByCustomId } = require_Components();
  var { NonSystemMessageTypes, MaxBulkDeletableMessageAge, UndeletableMessageTypes } = require_Constants();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();
  var { _transformAPIMessageInteractionMetadata } = require_Transformers();
  var { cleanContent, resolvePartialEmoji, transformResolved } = require_Util();

  class Message extends Base {
    constructor(client, data) {
      super(client);
      this.channelId = data.channel_id;
      this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);
      if ("type" in data) {
        this.type = data.type;
        this.system = !NonSystemMessageTypes.includes(this.type);
      } else {
        this.system ??= null;
        this.type ??= null;
      }
      if ("content" in data) {
        this.content = data.content;
      } else {
        this.content ??= null;
      }
      if ("author" in data) {
        this.author = this.client.users._add(data.author, !data.webhook_id);
      } else {
        this.author ??= null;
      }
      if ("pinned" in data) {
        this.pinned = Boolean(data.pinned);
      } else {
        this.pinned ??= null;
      }
      if ("tts" in data) {
        this.tts = data.tts;
      } else {
        this.tts ??= null;
      }
      if ("nonce" in data) {
        this.nonce = data.nonce;
      } else {
        this.nonce ??= null;
      }
      if ("embeds" in data) {
        this.embeds = data.embeds.map((embed) => new Embed(embed));
      } else {
        this.embeds = this.embeds?.slice() ?? [];
      }
      if ("components" in data) {
        this.components = data.components.map((component) => createComponent(component));
      } else {
        this.components = this.components?.slice() ?? [];
      }
      if ("attachments" in data) {
        this.attachments = new Collection;
        if (data.attachments) {
          for (const attachment of data.attachments) {
            this.attachments.set(attachment.id, new Attachment(attachment));
          }
        }
      } else {
        this.attachments = new Collection(this.attachments);
      }
      if ("sticker_items" in data || "stickers" in data) {
        this.stickers = new Collection((data.sticker_items ?? data.stickers)?.map((sticker) => [sticker.id, new Sticker(this.client, sticker)]));
      } else {
        this.stickers = new Collection(this.stickers);
      }
      if ("position" in data) {
        this.position = data.position;
      } else {
        this.position ??= null;
      }
      if ("role_subscription_data" in data) {
        this.roleSubscriptionData = {
          roleSubscriptionListingId: data.role_subscription_data.role_subscription_listing_id,
          tierName: data.role_subscription_data.tier_name,
          totalMonthsSubscribed: data.role_subscription_data.total_months_subscribed,
          isRenewal: data.role_subscription_data.is_renewal
        };
      } else {
        this.roleSubscriptionData ??= null;
      }
      if ("resolved" in data) {
        this.resolved = transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.resolved);
      } else {
        this.resolved ??= null;
      }
      if (data.edited_timestamp) {
        this.editedTimestamp = Date.parse(data.edited_timestamp);
      } else {
        this.editedTimestamp ??= null;
      }
      if ("reactions" in data) {
        this.reactions = new ReactionManager(this);
        if (data.reactions?.length > 0) {
          for (const reaction of data.reactions) {
            this.reactions._add(reaction);
          }
        }
      } else {
        this.reactions ??= new ReactionManager(this);
      }
      if (!this.mentions) {
        this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels, data.referenced_message?.author);
      } else {
        this.mentions = new Mentions(this, data.mentions ?? this.mentions.users, data.mention_roles ?? this.mentions.roles, data.mention_everyone ?? this.mentions.everyone, data.mention_channels ?? this.mentions.crosspostedChannels, data.referenced_message?.author ?? this.mentions.repliedUser);
      }
      if ("webhook_id" in data) {
        this.webhookId = data.webhook_id;
      } else {
        this.webhookId ??= null;
      }
      if ("application" in data) {
        this.groupActivityApplication = new ClientApplication(this.client, data.application);
      } else {
        this.groupActivityApplication ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("activity" in data) {
        this.activity = {
          partyId: data.activity.party_id,
          type: data.activity.type
        };
      } else {
        this.activity ??= null;
      }
      if ("thread" in data) {
        this.client.channels._add(data.thread, this.guild);
      }
      if (this.member && data.member) {
        this.member._patch(data.member);
      } else if (data.member && this.guild && this.author) {
        this.guild.members._add(Object.assign(data.member, { user: this.author }));
      }
      if ("flags" in data) {
        this.flags = new MessageFlagsBitField(data.flags).freeze();
      } else {
        this.flags = new MessageFlagsBitField(this.flags).freeze();
      }
      if ("message_reference" in data) {
        this.reference = {
          channelId: data.message_reference.channel_id,
          guildId: data.message_reference.guild_id,
          messageId: data.message_reference.message_id,
          type: data.message_reference.type
        };
      } else {
        this.reference ??= null;
      }
      if (data.referenced_message) {
        this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });
      }
      if (data.interaction_metadata) {
        this.interactionMetadata = _transformAPIMessageInteractionMetadata(this.client, data.interaction_metadata);
      } else {
        this.interactionMetadata ??= null;
      }
      if (data.interaction) {
        this.interaction = {
          id: data.interaction.id,
          type: data.interaction.type,
          commandName: data.interaction.name,
          user: this.client.users._add(data.interaction.user)
        };
      } else {
        this.interaction ??= null;
      }
      if (data.poll) {
        this.poll = new Poll(this.client, data.poll, this);
      } else {
        this.poll ??= null;
      }
      if (data.message_snapshots) {
        this.messageSnapshots = data.message_snapshots.reduce((coll, snapshot) => {
          const channel = this.client.channels.resolve(this.reference.channelId);
          const snapshotData = {
            ...snapshot.message,
            id: this.reference.messageId,
            channel_id: this.reference.channelId,
            guild_id: this.reference.guildId
          };
          return coll.set(this.reference.messageId, channel ? channel.messages._add(snapshotData) : new this.constructor(this.client, snapshotData));
        }, new Collection);
      } else {
        this.messageSnapshots ??= new Collection;
      }
      if (data.call) {
        this.call = {
          endedTimestamp: data.call.ended_timestamp ? Date.parse(data.call.ended_timestamp) : null,
          participants: data.call.participants,
          get endedAt() {
            return this.endedTimestamp && new Date(this.endedTimestamp);
          }
        };
      } else {
        this.call ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get partial() {
      return typeof this.content !== "string" || !this.author;
    }
    get member() {
      return this.guild?.members.resolve(this.author) ?? null;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get editedAt() {
      return this.editedTimestamp && new Date(this.editedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;
    }
    get hasThread() {
      return this.flags.has(MessageFlags.HasThread);
    }
    get thread() {
      return this.channel?.threads?.cache.get(this.id) ?? null;
    }
    get url() {
      return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);
    }
    get cleanContent() {
      return this.content != null && this.channel ? cleanContent(this.content, this.channel) : null;
    }
    createReactionCollector(options = {}) {
      return new ReactionCollector(this, options);
    }
    awaitReactions(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createReactionCollector(options);
        collector.once("end", (reactions, reason) => {
          if (options.errors?.includes(reason))
            reject(reactions);
          else
            resolve(reactions);
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        message: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    get editable() {
      const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable) && this.reference?.type !== MessageReferenceType.Forward);
      if (this.channel?.isThread()) {
        if (this.channel.archived)
          return false;
        if (this.channel.locked) {
          const permissions = this.channel.permissionsFor(this.client.user);
          if (!permissions?.has(PermissionFlagsBits.ManageThreads, true))
            return false;
        }
      }
      return precheck;
    }
    get deletable() {
      if (UndeletableMessageTypes.includes(this.type))
        return false;
      if (!this.guild) {
        return this.author.id === this.client.user.id;
      }
      if (!this.channel?.viewable) {
        return false;
      }
      const permissions = this.channel?.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.type !== MessageType.AutoModerationAction && this.author.id === this.client.user.id || permissions.has(PermissionFlagsBits.ManageMessages, false) && !this.guild.members.me.isCommunicationDisabled();
    }
    get bulkDeletable() {
      return (this.inGuild() && Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge && this.deletable && this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageMessages, false)) ?? false;
    }
    get pinnable() {
      const { channel } = this;
      return Boolean(!this.system && (!this.guild || channel?.viewable && channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false)));
    }
    async fetchReference() {
      if (!this.reference)
        throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);
      const { channelId, messageId } = this.reference;
      if (!messageId)
        throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);
      const channel = this.client.channels.resolve(channelId);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const message = await channel.messages.fetch(messageId);
      return message;
    }
    get crosspostable() {
      const bitfield = PermissionFlagsBits.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField.DefaultBit : PermissionFlagsBits.ManageMessages);
      const { channel } = this;
      return Boolean(channel?.type === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.reference?.type !== MessageReferenceType.Forward && this.type === MessageType.Default && !this.poll && channel.viewable && channel.permissionsFor(this.client.user)?.has(bitfield, false));
    }
    async edit(options) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      return this.channel.messages.edit(this, options);
    }
    async crosspost() {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      return this.channel.messages.crosspost(this.id);
    }
    async pin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.pin(this.id, reason);
      return this;
    }
    async unpin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.unpin(this.id, reason);
      return this;
    }
    async react(emoji) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.react(this.id, emoji);
      return this.client.actions.MessageReactionAdd.handle({
        [this.client.actions.injectedUser]: this.client.user,
        [this.client.actions.injectedChannel]: this.channel,
        [this.client.actions.injectedMessage]: this,
        emoji: resolvePartialEmoji(emoji)
      }, true).reaction;
    }
    async delete() {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.delete(this.id);
      return this;
    }
    async reply(options) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      let data;
      if (options instanceof MessagePayload) {
        data = options;
      } else {
        data = MessagePayload.create(this, options, {
          reply: {
            messageReference: this,
            failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists
          }
        });
      }
      return this.channel.send(data);
    }
    forward(channel) {
      const resolvedChannel = this.client.channels.resolve(channel);
      if (!resolvedChannel)
        throw new DiscordjsError(ErrorCodes.InvalidType, "channel", "TextBasedChannelResolvable");
      return resolvedChannel.send({
        forward: {
          message: this.id,
          channel: this.channelId,
          guild: this.guildId
        }
      });
    }
    async startThread(options = {}) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {
        throw new DiscordjsError(ErrorCodes.MessageThreadParent);
      }
      if (this.hasThread)
        throw new DiscordjsError(ErrorCodes.MessageExistingThread);
      return this.channel.threads.create({ ...options, startMessage: this });
    }
    async fetch(force = true) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      return this.channel.messages.fetch({ message: this.id, force });
    }
    async fetchWebhook() {
      if (!this.webhookId)
        throw new DiscordjsError(ErrorCodes.WebhookMessage);
      if (this.webhookId === this.applicationId)
        throw new DiscordjsError(ErrorCodes.WebhookApplication);
      return this.client.fetchWebhook(this.webhookId);
    }
    suppressEmbeds(suppress = true) {
      const flags = new MessageFlagsBitField(this.flags.bitfield);
      if (suppress) {
        flags.add(MessageFlags.SuppressEmbeds);
      } else {
        flags.remove(MessageFlags.SuppressEmbeds);
      }
      return this.edit({ flags });
    }
    removeAttachments() {
      return this.edit({ attachments: [] });
    }
    resolveComponent(customId) {
      return findComponentByCustomId(this.components, customId);
    }
    equals(message, rawData) {
      if (!message)
        return false;
      const embedUpdate = !message.author && !message.attachments;
      if (embedUpdate)
        return this.id === message.id && this.embeds.length === message.embeds.length;
      let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.nonce === message.nonce && this.tts === message.tts && this.attachments.size === message.attachments.size && this.embeds.length === message.embeds.length && this.attachments.every((attachment) => message.attachments.has(attachment.id)) && this.embeds.every((embed, index) => embed.equals(message.embeds[index]));
      if (equal && rawData) {
        equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);
      }
      return equal;
    }
    inGuild() {
      return Boolean(this.guildId);
    }
    toString() {
      return this.content;
    }
    toJSON() {
      return super.toJSON({
        channel: "channelId",
        author: "authorId",
        groupActivityApplication: "groupActivityApplicationId",
        guild: "guildId",
        cleanContent: true,
        member: false,
        reactions: false
      });
    }
  }
  exports.Message = Message;
});

// ../../node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist5();
  var { lazy } = require_dist();
  var { DiscordSnowflake } = require_cjs();
  var { Routes, WebhookType } = require_v106();
  var MessagePayload = require_MessagePayload();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var { resolveImage } = require_DataResolver();
  var getMessage = lazy(() => require_Message().Message);

  class Webhook {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      Object.defineProperty(this, "token", {
        value: data.token ?? null,
        writable: true,
        configurable: true
      });
      if ("avatar" in data) {
        this.avatar = data.avatar;
      }
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("user" in data) {
        this.owner = this.client.users?._add(data.user) ?? data.user;
      } else {
        this.owner ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("source_guild" in data) {
        this.sourceGuild = this.client.guilds?.cache.get(data.source_guild.id) ?? data.source_guild;
      } else {
        this.sourceGuild ??= null;
      }
      if ("source_channel" in data) {
        this.sourceChannel = this.client.channels?.cache.get(data.source_channel?.id) ?? data.source_channel;
      } else {
        this.sourceChannel ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    async send(options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const { body, files } = await messagePayload.resolveFiles();
      const query = makeURLSearchParams({
        wait: true,
        thread_id: messagePayload.options.threadId,
        with_components: messagePayload.options.withComponents
      });
      const d = await this.client.rest.post(Routes.webhook(this.id, this.token), {
        body,
        files,
        query,
        auth: false
      });
      if (!this.client.channels)
        return d;
      return this.client.channels.cache.get(d.channel_id)?.messages._add(d, false) ?? new (getMessage())(this.client, d);
    }
    async sendSlackMessage(body) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.post(Routes.webhookPlatform(this.id, this.token, "slack"), {
        query: makeURLSearchParams({ wait: true }),
        auth: false,
        body
      });
      return data.toString() === "ok";
    }
    async edit({ name = this.name, avatar, channel, reason }) {
      if (avatar && !(typeof avatar === "string" && avatar.startsWith("data:"))) {
        avatar = await resolveImage(avatar);
      }
      channel &&= channel.id ?? channel;
      const data = await this.client.rest.patch(Routes.webhook(this.id, channel ? undefined : this.token), {
        body: { name, avatar, channel_id: channel },
        reason,
        auth: !this.token || Boolean(channel)
      });
      this.name = data.name;
      this.avatar = data.avatar;
      this.channelId = data.channel_id;
      return this;
    }
    async fetchMessage(message, { threadId } = {}) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.get(Routes.webhookMessage(this.id, this.token, message), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
      if (!this.client.channels)
        return data;
      return this.client.channels.cache.get(data.channel_id)?.messages._add(data, false) ?? new (getMessage())(this.client, data);
    }
    async editMessage(message, options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body, files } = await messagePayload.resolveBody().resolveFiles();
      const query = makeURLSearchParams({
        thread_id: messagePayload.options.threadId,
        with_components: messagePayload.options.withComponents
      });
      const d = await this.client.rest.patch(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        body,
        files,
        query,
        auth: false
      });
      const channelManager = this.client.channels;
      if (!channelManager)
        return d;
      const messageManager = channelManager.cache.get(d.channel_id)?.messages;
      if (!messageManager)
        return new (getMessage())(this.client, d);
      const existing = messageManager.cache.get(d.id);
      if (!existing)
        return messageManager._add(d);
      const clone = existing._clone();
      clone._patch(d);
      return clone;
    }
    delete(reason) {
      return this.client.deleteWebhook(this.id, { token: this.token, reason });
    }
    async deleteMessage(message, threadId) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      await this.client.rest.delete(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.client.options.rest.api + Routes.webhook(this.id, this.token);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    isUserCreated() {
      return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);
    }
    isApplicationCreated() {
      return this.type === WebhookType.Application;
    }
    isChannelFollower() {
      return this.type === WebhookType.ChannelFollower;
    }
    isIncoming() {
      return this.type === WebhookType.Incoming;
    }
    static applyToClass(structure, ignore = []) {
      for (const prop of [
        "send",
        "sendSlackMessage",
        "fetchMessage",
        "edit",
        "editMessage",
        "delete",
        "deleteMessage",
        "createdTimestamp",
        "createdAt",
        "url"
      ]) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));
      }
    }
  }
  module.exports = Webhook;
});

// ../../node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS((exports, module) => {
  var BaseClient = require_BaseClient();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var Webhook = require_Webhook();
  var { parseWebhookURL } = require_Util();

  class WebhookClient extends BaseClient {
    constructor(data, options) {
      super(options);
      Object.defineProperty(this, "client", { value: this });
      let { id, token } = data;
      if ("url" in data) {
        const parsed = parseWebhookURL(data.url);
        if (!parsed) {
          throw new DiscordjsError(ErrorCodes.WebhookURLInvalid);
        }
        ({ id, token } = parsed);
      }
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {}
    fetchMessage() {}
    editMessage() {}
    sendSlackMessage() {}
    edit() {}
    delete() {}
    deleteMessage() {}
    get createdTimestamp() {}
    get createdAt() {}
    get url() {}
  }
  Webhook.applyToClass(WebhookClient);
  module.exports = WebhookClient;
});

// ../../node_modules/discord.js/src/structures/VoiceState.js
var require_VoiceState = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();

  class VoiceState extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.id = data.user_id;
      this._patch(data);
    }
    _patch(data) {
      if ("deaf" in data) {
        this.serverDeaf = data.deaf;
      } else {
        this.serverDeaf ??= null;
      }
      if ("mute" in data) {
        this.serverMute = data.mute;
      } else {
        this.serverMute ??= null;
      }
      if ("self_deaf" in data) {
        this.selfDeaf = data.self_deaf;
      } else {
        this.selfDeaf ??= null;
      }
      if ("self_mute" in data) {
        this.selfMute = data.self_mute;
      } else {
        this.selfMute ??= null;
      }
      if ("self_video" in data) {
        this.selfVideo = data.self_video;
      } else {
        this.selfVideo ??= null;
      }
      if ("session_id" in data) {
        this.sessionId = data.session_id;
      } else {
        this.sessionId ??= null;
      }
      if ("self_video" in data) {
        this.streaming = data.self_stream ?? false;
      } else {
        this.streaming ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("suppress" in data) {
        this.suppress = data.suppress;
      } else {
        this.suppress ??= null;
      }
      if ("request_to_speak_timestamp" in data) {
        this.requestToSpeakTimestamp = data.request_to_speak_timestamp && Date.parse(data.request_to_speak_timestamp);
      } else {
        this.requestToSpeakTimestamp ??= null;
      }
      return this;
    }
    get member() {
      return this.guild.members.cache.get(this.id) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get deaf() {
      return this.serverDeaf || this.selfDeaf;
    }
    get mute() {
      return this.serverMute || this.selfMute;
    }
    setMute(mute = true, reason) {
      return this.guild.members.edit(this.id, { mute, reason });
    }
    setDeaf(deaf = true, reason) {
      return this.guild.members.edit(this.id, { deaf, reason });
    }
    disconnect(reason) {
      return this.setChannel(null, reason);
    }
    setChannel(channel, reason) {
      return this.guild.members.edit(this.id, { channel, reason });
    }
    async edit(options) {
      if (this.channel?.type !== ChannelType.GuildStageVoice)
        throw new DiscordjsError(ErrorCodes.VoiceNotStageChannel);
      const target = this.client.user.id === this.id ? "@me" : this.id;
      if (target !== "@me" && options.requestToSpeak !== undefined) {
        throw new DiscordjsError(ErrorCodes.VoiceStateNotOwn);
      }
      if (!["boolean", "undefined"].includes(typeof options.requestToSpeak)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "requestToSpeak");
      }
      if (!["boolean", "undefined"].includes(typeof options.suppressed)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "suppressed");
      }
      await this.client.rest.patch(Routes.guildVoiceState(this.guild.id, target), {
        body: {
          channel_id: this.channelId,
          request_to_speak_timestamp: options.requestToSpeak ? new Date().toISOString() : options.requestToSpeak === false ? null : undefined,
          suppress: options.suppressed
        }
      });
      return this;
    }
    fetch(force = true) {
      return this.guild.voiceStates.fetch(this.id, { force });
    }
    setRequestToSpeak(requestToSpeak = true) {
      return this.edit({ requestToSpeak });
    }
    setSuppressed(suppressed = true) {
      return this.edit({ suppressed });
    }
    toJSON() {
      return super.toJSON({
        id: true,
        serverDeaf: true,
        serverMute: true,
        selfDeaf: true,
        selfMute: true,
        sessionId: true,
        channelId: "channel"
      });
    }
  }
  module.exports = VoiceState;
});

// ../../node_modules/discord.js/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Role } = require_Role();

  class GuildMemberRoleManager extends DataManager {
    constructor(member) {
      super(member.client, Role);
      this.member = member;
      this.guild = member.guild;
    }
    get cache() {
      const everyone = this.guild.roles.everyone;
      return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
    }
    get hoist() {
      const hoistedRoles = this.cache.filter((role) => role.hoist);
      if (!hoistedRoles.size)
        return null;
      return hoistedRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get icon() {
      const iconRoles = this.cache.filter((role) => role.icon || role.unicodeEmoji);
      if (!iconRoles.size)
        return null;
      return iconRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get color() {
      const coloredRoles = this.cache.filter((role) => role.colors.primaryColor);
      if (!coloredRoles.size)
        return null;
      return coloredRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get botRole() {
      if (!this.member.user.bot)
        return null;
      return this.cache.find((role) => role.tags?.botId === this.member.user.id) ?? null;
    }
    async add(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.put(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        clone._roles = [...this.cache.keys(), roleOrRoles];
        return clone;
      }
    }
    async remove(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = this.cache.filter((role) => !resolvedRoles.includes(role.id));
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        const newRoles = this.cache.filter((role) => role.id !== roleOrRoles);
        clone._roles = [...newRoles.keys()];
        return clone;
      }
    }
    set(roles, reason) {
      return this.member.edit({ roles, reason });
    }
    clone() {
      const clone = new this.constructor(this.member);
      clone.member._roles = [...this.cache.keys()];
      return clone;
    }
  }
  module.exports = GuildMemberRoleManager;
});

// ../../node_modules/discord.js/src/util/GuildMemberFlagsBitField.js
var require_GuildMemberFlagsBitField = __commonJS((exports) => {
  var { GuildMemberFlags } = require_v106();
  var BitField = require_BitField();

  class GuildMemberFlagsBitField extends BitField {
    static Flags = GuildMemberFlags;
  }
  exports.GuildMemberFlagsBitField = GuildMemberFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS((exports) => {
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var VoiceState = require_VoiceState();
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var GuildMemberRoleManager = require_GuildMemberRoleManager();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();

  class GuildMember extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.joinedTimestamp = null;
      this.premiumSinceTimestamp = null;
      this.nickname = null;
      this.pending = null;
      this.communicationDisabledUntilTimestamp = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("nick" in data)
        this.nickname = data.nick;
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else if (typeof this.avatar !== "string") {
        this.avatar = null;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      } else {
        this.banner ??= null;
      }
      if ("joined_at" in data)
        this.joinedTimestamp = Date.parse(data.joined_at);
      if ("premium_since" in data) {
        this.premiumSinceTimestamp = data.premium_since ? Date.parse(data.premium_since) : null;
      }
      if ("roles" in data)
        this._roles = data.roles;
      if ("pending" in data) {
        this.pending = data.pending;
      } else if (!this.partial) {
        this.pending ??= false;
      }
      if ("communication_disabled_until" in data) {
        this.communicationDisabledUntilTimestamp = data.communication_disabled_until && Date.parse(data.communication_disabled_until);
      }
      if ("flags" in data) {
        this.flags = new GuildMemberFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new GuildMemberFlagsBitField().freeze();
      }
      if (data.avatar_decoration_data) {
        this.avatarDecorationData = {
          asset: data.avatar_decoration_data.asset,
          skuId: data.avatar_decoration_data.sku_id
        };
      } else {
        this.avatarDecorationData = null;
      }
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    get partial() {
      return this.joinedTimestamp === null;
    }
    get roles() {
      return new GuildMemberRoleManager(this);
    }
    get voice() {
      return this.guild.voiceStates.cache.get(this.id) ?? new VoiceState(this.guild, { user_id: this.id });
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.guildMemberAvatar(this.guild.id, this.id, this.avatar, options);
    }
    avatarDecorationURL() {
      return this.avatarDecorationData ? this.client.rest.cdn.avatarDecoration(this.avatarDecorationData.asset) : null;
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.guildMemberBanner(this.guild.id, this.id, this.banner, options);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.user.displayAvatarURL(options);
    }
    displayBannerURL(options) {
      return this.bannerURL(options) ?? this.user.bannerURL(options);
    }
    displayAvatarDecorationURL() {
      return this.avatarDecorationURL() ?? this.user.avatarDecorationURL();
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get communicationDisabledUntil() {
      return this.communicationDisabledUntilTimestamp && new Date(this.communicationDisabledUntilTimestamp);
    }
    get premiumSince() {
      return this.premiumSinceTimestamp && new Date(this.premiumSinceTimestamp);
    }
    get presence() {
      return this.guild.presences.cache.get(this.id) ?? null;
    }
    get displayColor() {
      return this.roles.color?.colors.primaryColor ?? 0;
    }
    get displayHexColor() {
      return this.roles.color?.hexColor ?? "#000000";
    }
    get id() {
      return this.user.id;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    get displayName() {
      return this.nickname ?? this.user.displayName;
    }
    get permissions() {
      if (this.user.id === this.guild.ownerId)
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      return new PermissionsBitField(this.roles.cache.map((role) => role.permissions)).freeze();
    }
    get manageable() {
      if (this.user.id === this.guild.ownerId)
        return false;
      if (this.user.id === this.client.user.id)
        return false;
      if (this.client.user.id === this.guild.ownerId)
        return true;
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
    }
    get kickable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.KickMembers);
    }
    get bannable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.BanMembers);
    }
    get moderatable() {
      return !this.permissions.has(PermissionFlagsBits.Administrator) && this.manageable && (this.guild.members.me?.permissions.has(PermissionFlagsBits.ModerateMembers) ?? false);
    }
    isCommunicationDisabled() {
      return this.communicationDisabledUntilTimestamp > Date.now();
    }
    permissionsIn(channel) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.permissionsFor(this);
    }
    edit(options) {
      return this.guild.members.edit(this, options);
    }
    setFlags(flags, reason) {
      return this.edit({ flags, reason });
    }
    setNickname(nick, reason) {
      return this.edit({ nick, reason });
    }
    createDM(force = false) {
      return this.user.createDM(force);
    }
    deleteDM() {
      return this.user.deleteDM();
    }
    kick(reason) {
      return this.guild.members.kick(this, reason);
    }
    ban(options) {
      return this.guild.bans.create(this, options);
    }
    disableCommunicationUntil(communicationDisabledUntil, reason) {
      return this.edit({ communicationDisabledUntil, reason });
    }
    timeout(timeout, reason) {
      return this.disableCommunicationUntil(timeout && Date.now() + timeout, reason);
    }
    fetch(force = true) {
      return this.guild.members.fetch({ user: this.id, cache: true, force });
    }
    equals(member) {
      return member instanceof this.constructor && this.id === member.id && this.partial === member.partial && this.guild.id === member.guild.id && this.joinedTimestamp === member.joinedTimestamp && this.nickname === member.nickname && this.avatar === member.avatar && this.banner === member.banner && this.pending === member.pending && this.communicationDisabledUntilTimestamp === member.communicationDisabledUntilTimestamp && this.flags.bitfield === member.flags.bitfield && (this._roles === member._roles || this._roles.length === member._roles.length && this._roles.every((role, index) => role === member._roles[index])) && this.avatarDecorationData?.asset === member.avatarDecorationData?.asset && this.avatarDecorationData?.skuId === member.avatarDecorationData?.skuId;
    }
    toString() {
      return this.user.toString();
    }
    toJSON() {
      const json = super.toJSON({
        guild: "guildId",
        user: "userId",
        displayName: true,
        roles: true
      });
      json.avatarURL = this.avatarURL();
      json.bannerURL = this.bannerURL();
      json.displayAvatarURL = this.displayAvatarURL();
      json.displayBannerURL = this.displayBannerURL();
      json.avatarDecorationURL = this.avatarDecorationURL();
      return json;
    }
  }
  TextBasedChannel.applyToClass(GuildMember);
  exports.GuildMember = GuildMember;
});

// ../../node_modules/discord.js/src/managers/MessageManager.js
var require_MessageManager = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Message } = require_Message();
  var MessagePayload = require_MessagePayload();
  var { MakeCacheOverrideSymbol } = require_Symbols();
  var { resolvePartialEmoji } = require_Util();
  var deprecationEmittedForFetchPinned = false;

  class MessageManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = MessageManager;
    constructor(channel, iterable) {
      super(channel.client, Message, iterable);
      this.channel = channel;
    }
    _add(data, cache) {
      return super._add(data, cache);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { message, cache, force } = options;
      const resolvedMessage = this.resolveId(message ?? options);
      if (resolvedMessage)
        return this._fetchSingle({ message: resolvedMessage, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ message, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(message);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channelMessage(this.channel.id, message));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.channelMessages(this.channel.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection);
    }
    async fetchPins(options = {}) {
      const data = await this.client.rest.get(Routes.channelMessagesPins(this.channel.id), {
        query: makeURLSearchParams({
          ...options,
          before: options.before && new Date(options.before).toISOString()
        })
      });
      return {
        items: data.items.map((item) => ({
          pinnedTimestamp: Date.parse(item.pinned_at),
          get pinnedAt() {
            return new Date(this.pinnedTimestamp);
          },
          message: this._add(item.message, options.cache)
        })),
        hasMore: data.has_more
      };
    }
    async fetchPinned(cache = true) {
      if (!deprecationEmittedForFetchPinned) {
        process2.emitWarning("The MessageManager#fetchPinned() method is deprecated. Use MessageManager#fetchPins() instead.", "DeprecationWarning");
        deprecationEmittedForFetchPinned = true;
      }
      const data = await this.client.rest.get(Routes.channelPins(this.channel.id));
      const messages = new Collection;
      for (const message of data)
        messages.set(message.id, this._add(message, cache));
      return messages;
    }
    async edit(message, options) {
      const messageId = this.resolveId(message);
      if (!messageId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const { body, files } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveBody().resolveFiles();
      const d = await this.client.rest.patch(Routes.channelMessage(this.channel.id, messageId), { body, files });
      const existing = this.cache.get(messageId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async crosspost(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const data = await this.client.rest.post(Routes.channelMessageCrosspost(this.channel.id, message));
      return this.cache.get(data.id) ?? this._add(data);
    }
    async pin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.put(Routes.channelMessagesPin(this.channel.id, message), { reason });
    }
    async unpin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelMessagesPin(this.channel.id, message), { reason });
    }
    async react(message, emoji) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      emoji = resolvePartialEmoji(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.EmojiType, "emoji", "EmojiIdentifierResolvable");
      const emojiId = emoji.id ? `${emoji.animated ? "a:" : ""}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);
      await this.client.rest.put(Routes.channelMessageOwnReaction(this.channel.id, message, emojiId));
    }
    async delete(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelMessage(this.channel.id, message));
    }
    async endPoll(messageId) {
      const message = await this.client.rest.post(Routes.expirePoll(this.channel.id, messageId));
      return this._add(message, false);
    }
    async fetchPollAnswerVoters({ messageId, answerId, after, limit }) {
      const voters = await this.client.rest.get(Routes.pollAnswerVoters(this.channel.id, messageId, answerId), {
        query: makeURLSearchParams({ limit, after })
      });
      return voters.users.reduce((acc, user) => acc.set(user.id, this.client.users._add(user, false)), new Collection);
    }
  }
  module.exports = MessageManager;
});

// ../../node_modules/discord.js/src/structures/InteractionWebhook.js
var require_InteractionWebhook = __commonJS((exports, module) => {
  var Webhook = require_Webhook();

  class InteractionWebhook {
    constructor(client, id, token) {
      Object.defineProperty(this, "client", { value: client });
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {}
    fetchMessage() {}
    editMessage() {}
    deleteMessage() {}
    get url() {}
  }
  Webhook.applyToClass(InteractionWebhook, ["sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt"]);
  module.exports = InteractionWebhook;
});

// ../../node_modules/discord.js/src/structures/MessagePayload.js
var require_MessagePayload = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("buffer");
  var { lazy, isJSONEncodable } = require_dist();
  var { DiscordSnowflake } = require_cjs();
  var { MessageFlags, MessageReferenceType } = require_v106();
  var { DiscordjsError, DiscordjsRangeError, ErrorCodes } = require_errors();
  var { resolveFile } = require_DataResolver();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var { basename, verifyString, resolvePartialEmoji } = require_Util();
  var getBaseInteraction = lazy(() => require_BaseInteraction());

  class MessagePayload {
    constructor(target, options) {
      this.target = target;
      this.options = options;
      this.body = null;
      this.files = null;
    }
    get isWebhook() {
      const Webhook = require_Webhook();
      const WebhookClient = require_WebhookClient();
      return this.target instanceof Webhook || this.target instanceof WebhookClient;
    }
    get isUser() {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      return this.target instanceof User || this.target instanceof GuildMember;
    }
    get isMessage() {
      const { Message } = require_Message();
      return this.target instanceof Message;
    }
    get isMessageManager() {
      const MessageManager = require_MessageManager();
      return this.target instanceof MessageManager;
    }
    get isInteraction() {
      const BaseInteraction = getBaseInteraction();
      const InteractionWebhook = require_InteractionWebhook();
      return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;
    }
    makeContent() {
      let content;
      if (this.options.content === null) {
        content = "";
      } else if (this.options.content !== undefined) {
        content = verifyString(this.options.content, DiscordjsRangeError, ErrorCodes.MessageContentType, true);
      }
      return content;
    }
    resolveBody() {
      if (this.body)
        return this;
      const isInteraction = this.isInteraction;
      const isWebhook = this.isWebhook;
      const content = this.makeContent();
      const tts = Boolean(this.options.tts);
      let nonce;
      if (this.options.nonce !== undefined) {
        nonce = this.options.nonce;
        if (typeof nonce === "number" ? !Number.isInteger(nonce) : typeof nonce !== "string") {
          throw new DiscordjsRangeError(ErrorCodes.MessageNonceType);
        }
      }
      let enforce_nonce = Boolean(this.options.enforceNonce);
      if (nonce === undefined) {
        if (this.options.enforceNonce !== false && this.target.client.options.enforceNonce) {
          nonce = DiscordSnowflake.generate().toString();
          enforce_nonce = true;
        } else if (enforce_nonce) {
          throw new DiscordjsError(ErrorCodes.MessageNonceRequired);
        }
      }
      const components = this.options.components?.map((component) => isJSONEncodable(component) ? component.toJSON() : this.target.client.options.jsonTransformer(component));
      let username;
      let avatarURL;
      let threadName;
      let appliedTags;
      if (isWebhook) {
        username = this.options.username ?? this.target.name;
        if (this.options.avatarURL)
          avatarURL = this.options.avatarURL;
        if (this.options.threadName)
          threadName = this.options.threadName;
        if (this.options.appliedTags)
          appliedTags = this.options.appliedTags;
      }
      let flags;
      if (this.options.flags != null) {
        flags = new MessageFlagsBitField(this.options.flags).bitfield;
      }
      if (isInteraction && this.options.ephemeral) {
        flags |= MessageFlags.Ephemeral;
      }
      let allowedMentions = this.options.allowedMentions === undefined ? this.target.client.options.allowedMentions : this.options.allowedMentions;
      if (allowedMentions?.repliedUser !== undefined) {
        allowedMentions = { ...allowedMentions, replied_user: allowedMentions.repliedUser };
        delete allowedMentions.repliedUser;
      }
      let message_reference;
      if (typeof this.options.reply === "object") {
        const reference = this.options.reply.messageReference;
        const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);
        if (message_id) {
          message_reference = {
            message_id,
            fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists
          };
        }
      }
      if (typeof this.options.forward === "object") {
        const reference = this.options.forward.message;
        const channel_id = reference.channelId ?? this.target.client.channels.resolveId(this.options.forward.channel);
        const guild_id = reference.guildId ?? this.target.client.guilds.resolveId(this.options.forward.guild);
        const message_id = this.target.messages.resolveId(reference);
        if (message_id) {
          if (!channel_id)
            throw new DiscordjsError(ErrorCodes.InvalidType, "channelId", "TextBasedChannelResolvable");
          message_reference = {
            type: MessageReferenceType.Forward,
            message_id,
            channel_id,
            guild_id: guild_id ?? undefined
          };
        }
      }
      const attachments = this.options.files?.map((file, index) => ({
        id: index.toString(),
        description: file.description
      }));
      if (Array.isArray(this.options.attachments)) {
        this.options.attachments.push(...attachments ?? []);
      } else {
        this.options.attachments = attachments;
      }
      let poll;
      if (this.options.poll) {
        poll = {
          question: {
            text: this.options.poll.question.text
          },
          answers: this.options.poll.answers.map((answer) => ({
            poll_media: { text: answer.text, emoji: resolvePartialEmoji(answer.emoji) }
          })),
          duration: this.options.poll.duration,
          allow_multiselect: this.options.poll.allowMultiselect,
          layout_type: this.options.poll.layoutType
        };
      }
      this.body = {
        content,
        tts,
        nonce,
        enforce_nonce,
        embeds: this.options.embeds?.map((embed) => isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed)),
        components,
        username,
        avatar_url: avatarURL,
        allowed_mentions: this.isMessage && message_reference === undefined && this.target.author.id !== this.target.client.user.id ? undefined : allowedMentions,
        flags,
        message_reference,
        attachments: this.options.attachments,
        sticker_ids: this.options.stickers?.map((sticker) => sticker.id ?? sticker),
        thread_name: threadName,
        applied_tags: appliedTags,
        poll
      };
      return this;
    }
    async resolveFiles() {
      if (this.files)
        return this;
      this.files = await Promise.all(this.options.files?.map((file) => this.constructor.resolveFile(file)) ?? []);
      return this;
    }
    static async resolveFile(fileLike) {
      let attachment;
      let name;
      const findName = (thing) => {
        if (typeof thing === "string") {
          return basename(thing);
        }
        if (thing.path) {
          return basename(thing.path);
        }
        return "file.jpg";
      };
      const ownAttachment = typeof fileLike === "string" || fileLike instanceof Buffer2 || typeof fileLike.pipe === "function";
      if (ownAttachment) {
        attachment = fileLike;
        name = findName(attachment);
      } else {
        attachment = fileLike.attachment;
        name = fileLike.name ?? findName(attachment);
      }
      const { data, contentType } = await resolveFile(attachment);
      return { data, name, contentType };
    }
    static create(target, options, extra = {}) {
      return new this(target, typeof options !== "object" || options === null ? { content: options, ...extra } : { ...options, ...extra });
    }
  }
  module.exports = MessagePayload;
});

// ../../node_modules/discord.js/src/managers/GuildMessageManager.js
var require_GuildMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class GuildMessageManager extends MessageManager {
  }
  module.exports = GuildMessageManager;
});

// ../../node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var { InteractionType, Routes } = require_v106();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors();
  var { MaxBulkDeletableMessageAge } = require_Constants();
  var InteractionCollector = require_InteractionCollector();
  var MessageCollector = require_MessageCollector();
  var MessagePayload = require_MessagePayload();

  class TextBasedChannel {
    constructor() {
      this.messages = new GuildMessageManager(this);
      this.lastMessageId = null;
      this.lastPinTimestamp = null;
    }
    get lastMessage() {
      return this.messages.resolve(this.lastMessageId);
    }
    get lastPinAt() {
      return this.lastPinTimestamp && new Date(this.lastPinTimestamp);
    }
    async send(options) {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      if (this instanceof User || this instanceof GuildMember) {
        const dm = await this.createDM();
        return dm.send(options);
      }
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const { body, files } = await messagePayload.resolveFiles();
      const d = await this.client.rest.post(Routes.channelMessages(this.id), { body, files });
      return this.messages.cache.get(d.id) ?? this.messages._add(d);
    }
    async sendTyping() {
      await this.client.rest.post(Routes.channelTyping(this.id));
    }
    createMessageCollector(options = {}) {
      return new MessageCollector(this, options);
    }
    awaitMessages(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createMessageCollector(options);
        collector.once("end", (collection, reason) => {
          if (options.errors?.includes(reason)) {
            reject(collection);
          } else {
            resolve(collection);
          }
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        channel: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    async bulkDelete(messages, filterOld = false) {
      if (Array.isArray(messages) || messages instanceof Collection) {
        let messageIds = messages instanceof Collection ? [...messages.keys()] : messages.map((message) => message.id ?? message);
        if (filterOld) {
          messageIds = messageIds.filter((id) => Date.now() - DiscordSnowflake.timestampFrom(id) < MaxBulkDeletableMessageAge);
        }
        if (messageIds.length === 0)
          return new Collection;
        if (messageIds.length === 1) {
          const message = this.client.actions.MessageDelete.getMessage({
            message_id: messageIds[0]
          }, this);
          await this.client.rest.delete(Routes.channelMessage(this.id, messageIds[0]));
          return message ? new Collection([[message.id, message]]) : new Collection;
        }
        await this.client.rest.post(Routes.channelBulkDelete(this.id), { body: { messages: messageIds } });
        return messageIds.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({
          message_id: id
        }, this)), new Collection);
      }
      if (!isNaN(messages)) {
        const msgs = await this.messages.fetch({ limit: messages });
        return this.bulkDelete(msgs, filterOld);
      }
      throw new DiscordjsTypeError(ErrorCodes.MessageBulkDeleteType);
    }
    fetchWebhooks() {
      return this.guild.channels.fetchWebhooks(this.id);
    }
    createWebhook(options) {
      return this.guild.channels.createWebhook({ channel: this.id, ...options });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setNSFW(nsfw = true, reason) {
      return this.edit({ nsfw, reason });
    }
    static applyToClass(structure, full = false, ignore = []) {
      const props = ["send"];
      if (full) {
        props.push("lastMessage", "lastPinAt", "bulkDelete", "sendTyping", "createMessageCollector", "awaitMessages", "createMessageComponentCollector", "awaitMessageComponent", "fetchWebhooks", "createWebhook", "setRateLimitPerUser", "setNSFW");
      }
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));
      }
    }
  }
  module.exports = TextBasedChannel;
  var GuildMessageManager = require_GuildMessageManager();
});

// ../../node_modules/discord.js/src/managers/DMMessageManager.js
var require_DMMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class DMMessageManager extends MessageManager {
  }
  module.exports = DMMessageManager;
});

// ../../node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS((exports, module) => {
  var { userMention } = require_dist7();
  var { ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var DMMessageManager = require_DMMessageManager();
  var Partials = require_Partials();

  class DMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.type = ChannelType.DM;
      this.messages = new DMMessageManager(this);
    }
    _patch(data) {
      super._patch(data);
      if (data.recipients) {
        const recipient = data.recipients[0];
        this.recipientId = recipient.id;
        if ("username" in recipient || this.client.options.partials.includes(Partials.User)) {
          this.client.users._add(recipient);
        }
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);
      } else {
        this.lastPinTimestamp ??= null;
      }
    }
    get partial() {
      return this.lastMessageId === undefined;
    }
    get recipient() {
      return this.client.users.resolve(this.recipientId);
    }
    fetch(force = true) {
      return this.client.users.createDM(this.recipientId, { force });
    }
    toString() {
      return userMention(this.recipientId);
    }
    get lastMessage() {}
    get lastPinAt() {}
    send() {}
    sendTyping() {}
    createMessageCollector() {}
    awaitMessages() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
  }
  TextBasedChannel.applyToClass(DMChannel, true, [
    "bulkDelete",
    "fetchWebhooks",
    "createWebhook",
    "setRateLimitPerUser",
    "setNSFW"
  ]);
  module.exports = DMChannel;
});

// ../../node_modules/discord.js/src/managers/GuildForumThreadManager.js
var require_GuildForumThreadManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var MessagePayload = require_MessagePayload();

  class GuildForumThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      message,
      reason,
      rateLimitPerUser,
      appliedTags
    } = {}) {
      if (!message) {
        throw new DiscordjsTypeError(ErrorCodes.GuildForumMessageRequired);
      }
      const { body, files } = await (message instanceof MessagePayload ? message : MessagePayload.create(this, message)).resolveBody().resolveFiles();
      const data = await this.client.rest.post(Routes.threads(this.channel.id), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          rate_limit_per_user: rateLimitPerUser,
          applied_tags: appliedTags,
          message: body
        },
        files,
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildForumThreadManager;
});

// ../../node_modules/discord.js/src/structures/ThreadOnlyChannel.js
var require_ThreadOnlyChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildForumThreadManager = require_GuildForumThreadManager();
  var { transformAPIGuildForumTag, transformAPIGuildDefaultReaction } = require_Channels();

  class ThreadOnlyChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.threads = new GuildForumThreadManager(this);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("available_tags" in data) {
        this.availableTags = data.available_tags.map((tag) => transformAPIGuildForumTag(tag));
      } else {
        this.availableTags ??= [];
      }
      if ("default_reaction_emoji" in data) {
        this.defaultReactionEmoji = data.default_reaction_emoji ? transformAPIGuildDefaultReaction(data.default_reaction_emoji) : null;
      } else {
        this.defaultReactionEmoji ??= null;
      }
      if ("default_thread_rate_limit_per_user" in data) {
        this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
      } else {
        this.defaultThreadRateLimitPerUser ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      } else {
        this.defaultAutoArchiveDuration ??= null;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      } else {
        this.nsfw ??= false;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("default_sort_order" in data) {
        this.defaultSortOrder = data.default_sort_order;
      } else {
        this.defaultSortOrder ??= null;
      }
    }
    setAvailableTags(availableTags, reason) {
      return this.edit({ availableTags, reason });
    }
    setDefaultReactionEmoji(defaultReactionEmoji, reason) {
      return this.edit({ defaultReactionEmoji, reason });
    }
    setDefaultThreadRateLimitPerUser(defaultThreadRateLimitPerUser, reason) {
      return this.edit({ defaultThreadRateLimitPerUser, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    setDefaultSortOrder(defaultSortOrder, reason) {
      return this.edit({ defaultSortOrder, reason });
    }
    createWebhook() {}
    fetchWebhooks() {}
    setNSFW() {}
    setRateLimitPerUser() {}
  }
  TextBasedChannel.applyToClass(ThreadOnlyChannel, true, [
    "send",
    "lastMessage",
    "lastPinAt",
    "bulkDelete",
    "sendTyping",
    "createMessageCollector",
    "awaitMessages",
    "createMessageComponentCollector",
    "awaitMessageComponent"
  ]);
  module.exports = ThreadOnlyChannel;
});

// ../../node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js
var require_ThreadMemberFlagsBitField = __commonJS((exports, module) => {
  var BitField = require_BitField();

  class ThreadMemberFlagsBitField extends BitField {
    static Flags = {};
  }
  module.exports = ThreadMemberFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/ThreadMember.js
var require_ThreadMember = __commonJS((exports, module) => {
  var Base = require_Base();
  var ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
  var { emitDeprecationWarningForRemoveThreadMember } = require_Util();

  class ThreadMember extends Base {
    constructor(thread, data, extra = {}) {
      super(thread.client);
      this.thread = thread;
      this.joinedTimestamp = null;
      this.flags = null;
      this.id = data.user_id;
      this._patch(data, extra);
    }
    _patch(data, extra = {}) {
      if ("join_timestamp" in data)
        this.joinedTimestamp = Date.parse(data.join_timestamp);
      if ("flags" in data)
        this.flags = new ThreadMemberFlagsBitField(data.flags).freeze();
      if ("member" in data) {
        this.member = this.thread.guild.members._add(data.member, extra.cache);
      } else {
        this.member ??= null;
      }
    }
    get partial() {
      return this.flags === null;
    }
    get guildMember() {
      return this.member ?? this.thread.guild.members.cache.get(this.id) ?? null;
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get user() {
      return this.client.users.cache.get(this.id) ?? null;
    }
    get manageable() {
      return !this.thread.archived && this.thread.editable;
    }
    async remove(reason) {
      if (reason !== undefined) {
        emitDeprecationWarningForRemoveThreadMember(this.constructor.name);
      }
      await this.thread.members.remove(this.id, reason);
      return this;
    }
  }
  module.exports = ThreadMember;
});

// ../../node_modules/discord.js/src/managers/ThreadMemberManager.js
var require_ThreadMemberManager = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var ThreadMember = require_ThreadMember();
  var { emitDeprecationWarningForRemoveThreadMember } = require_Util();
  var deprecationEmittedForAdd = false;

  class ThreadMemberManager extends CachedManager {
    constructor(thread, iterable) {
      super(thread.client, ThreadMember, iterable);
      this.thread = thread;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (cache)
        existing?._patch(data, { cache });
      if (existing)
        return existing;
      const member = new ThreadMember(this.thread, data, { cache });
      if (cache)
        this.cache.set(data.user_id, member);
      return member;
    }
    fetchMe(options) {
      return this.fetch({ ...options, member: this.client.user.id });
    }
    get me() {
      return this.cache.get(this.client.user.id) ?? null;
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userId = this.client.users.resolveId(member);
      if (userId)
        return super.cache.get(userId) ?? null;
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
    async add(member, reason) {
      if (reason !== undefined && !deprecationEmittedForAdd) {
        process2.emitWarning("The reason parameter of ThreadMemberManager#add() is deprecated as Discord does not parse them. It will be removed in the next major version.", "DeprecationWarning");
        deprecationEmittedForAdd = true;
      }
      const id = member === "@me" ? member : this.client.users.resolveId(member);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "member", "UserResolvable");
      await this.client.rest.put(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    async remove(member, reason) {
      if (reason !== undefined) {
        emitDeprecationWarningForRemoveThreadMember(this.constructor.name);
      }
      const id = member === "@me" ? member : this.client.users.resolveId(member);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "member", "UserResolvable");
      await this.client.rest.delete(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { member, withMember, cache, force } = options;
      const resolvedMember = this.resolveId(member ?? options);
      if (resolvedMember)
        return this._fetchSingle({ member: resolvedMember, withMember, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ member, withMember, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(member);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id, member), {
        query: makeURLSearchParams({ with_member: withMember })
      });
      return this._add(data, cache);
    }
    async _fetchMany({ withMember, after, limit, cache } = {}) {
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id), {
        query: makeURLSearchParams({ with_member: withMember, after, limit })
      });
      return data.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection);
    }
  }
  module.exports = ThreadMemberManager;
});

// ../../node_modules/discord.js/src/structures/ThreadChannel.js
var require_ThreadChannel = __commonJS((exports, module) => {
  var { DiscordAPIError } = require_dist5();
  var { lazy } = require_dist();
  var { RESTJSONErrorCodes, ChannelFlags, ChannelType, PermissionFlagsBits, Routes } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var getThreadOnlyChannel = lazy(() => require_ThreadOnlyChannel());
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsRangeError, ErrorCodes } = require_errors();
  var GuildMessageManager = require_GuildMessageManager();
  var ThreadMemberManager = require_ThreadMemberManager();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();

  class ThreadChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(guild?.client ?? client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.ownerId = data.owner_id;
      this.messages = new GuildMessageManager(this);
      this.members = new ThreadMemberManager(this);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("message" in data)
        this.messages._add(data.message);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("thread_metadata" in data) {
        this.locked = data.thread_metadata.locked ?? false;
        this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;
        this.archived = data.thread_metadata.archived;
        this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;
        this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);
        if ("create_timestamp" in data.thread_metadata) {
          this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);
        }
      } else {
        this.locked ??= null;
        this.archived ??= null;
        this.autoArchiveDuration ??= null;
        this.archiveTimestamp ??= null;
        this.invitable ??= null;
      }
      this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      } else {
        this.lastMessageId ??= null;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      } else {
        this.lastPinTimestamp ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user ?? 0;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("message_count" in data) {
        this.messageCount = data.message_count;
      } else {
        this.messageCount ??= null;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("total_message_sent" in data) {
        this.totalMessageSent = data.total_message_sent;
      } else {
        this.totalMessageSent ??= null;
      }
      if (data.member && this.client.user)
        this.members._add({ user_id: this.client.user.id, ...data.member });
      if (data.messages)
        for (const message of data.messages)
          this.messages._add(message);
      if ("applied_tags" in data) {
        this.appliedTags = data.applied_tags;
      } else {
        this.appliedTags ??= [];
      }
    }
    get createdTimestamp() {
      return this._createdTimestamp;
    }
    get guildMembers() {
      return this.members.cache.mapValues((member) => member.guildMember);
    }
    get archivedAt() {
      return this.archiveTimestamp && new Date(this.archiveTimestamp);
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    async join() {
      await this.members.add("@me");
      return this;
    }
    async leave() {
      await this.members.remove("@me");
      return this;
    }
    permissionsFor(memberOrRole, checkAdmin) {
      return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;
    }
    async fetchOwner(options) {
      const member = await this.members._fetchSingle({ ...options, member: this.ownerId }).catch((error) => {
        if (error instanceof DiscordAPIError && error.code === RESTJSONErrorCodes.UnknownMember) {
          return null;
        }
        throw error;
      });
      return member;
    }
    async fetchStarterMessage(options) {
      const channel = this.parent instanceof getThreadOnlyChannel() ? this : this.parent;
      return channel?.messages.fetch({ message: this.id, ...options }) ?? null;
    }
    async edit(options) {
      const newData = await this.client.rest.patch(Routes.channel(this.id), {
        body: {
          name: options.name,
          archived: options.archived,
          auto_archive_duration: options.autoArchiveDuration,
          rate_limit_per_user: options.rateLimitPerUser,
          locked: options.locked,
          invitable: this.type === ChannelType.PrivateThread ? options.invitable : undefined,
          applied_tags: options.appliedTags,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    setArchived(archived = true, reason) {
      return this.edit({ archived, reason });
    }
    setAutoArchiveDuration(autoArchiveDuration, reason) {
      return this.edit({ autoArchiveDuration, reason });
    }
    async setInvitable(invitable = true, reason) {
      if (this.type !== ChannelType.PrivateThread) {
        throw new DiscordjsRangeError(ErrorCodes.ThreadInvitableType, this.type);
      }
      return this.edit({ invitable, reason });
    }
    setLocked(locked = true, reason) {
      return this.edit({ locked, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setAppliedTags(appliedTags, reason) {
      return this.edit({ appliedTags, reason });
    }
    pin(reason) {
      return this.edit({ flags: this.flags.add(ChannelFlags.Pinned), reason });
    }
    unpin(reason) {
      return this.edit({ flags: this.flags.remove(ChannelFlags.Pinned), reason });
    }
    get joined() {
      return this.members.cache.has(this.client.user?.id);
    }
    get editable() {
      return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;
    }
    get joinable() {
      return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel, false);
    }
    get manageable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.ManageThreads, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    get sendable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();
    }
    get unarchivable() {
      return this.archived && this.sendable && (!this.locked || this.manageable);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
    get lastMessage() {}
    get lastPinAt() {}
    send() {}
    sendTyping() {}
    createMessageCollector() {}
    awaitMessages() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
    bulkDelete() {}
  }
  TextBasedChannel.applyToClass(ThreadChannel, true, ["fetchWebhooks", "setRateLimitPerUser", "setNSFW"]);
  module.exports = ThreadChannel;
});

// ../../node_modules/discord.js/src/managers/ThreadManager.js
var require_ThreadManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var ThreadChannel = require_ThreadChannel();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class ThreadManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = ThreadManager;
    constructor(channel, iterable) {
      super(channel.client, ThreadChannel, iterable);
      this.channel = channel;
    }
    _add(thread) {
      const existing = this.cache.get(thread.id);
      if (existing)
        return existing;
      this.cache.set(thread.id, thread);
      return thread;
    }
    fetch(options, { cache, force } = {}) {
      if (!options)
        return this.fetchActive(cache);
      const channel = this.client.channels.resolveId(options);
      if (channel)
        return this.client.channels.fetch(channel, { cache, force });
      if (options.archived) {
        return this.fetchArchived(options.archived, cache);
      }
      return this.fetchActive(cache);
    }
    async fetchArchived({ type = "public", fetchAll = false, before, limit } = {}, cache = true) {
      let path = Routes.channelThreads(this.channel.id, type);
      if (type === "private" && !fetchAll) {
        path = Routes.channelJoinedArchivedThreads(this.channel.id);
      }
      let timestamp;
      let id;
      const query = makeURLSearchParams({ limit });
      if (before !== undefined) {
        if (before instanceof ThreadChannel || /^\d{17,19}$/.test(String(before))) {
          id = this.resolveId(before);
          timestamp = this.resolve(before)?.archivedAt?.toISOString();
          const toUse = type === "private" && !fetchAll ? id : timestamp;
          if (toUse) {
            query.set("before", toUse);
          }
        } else {
          try {
            timestamp = new Date(before).toISOString();
            if (type === "public" || fetchAll) {
              query.set("before", timestamp);
            }
          } catch {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, "before", "DateResolvable or ThreadChannelResolvable");
          }
        }
      }
      const raw = await this.client.rest.get(path, { query });
      return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });
    }
    async fetchActive(cache = true) {
      const data = await this.channel.guild.channels.rawFetchGuildActiveThreads();
      return this.constructor._mapThreads(data, this.client, { parent: this.channel, cache });
    }
    static _mapThreads(rawThreads, client, { parent, guild, cache }) {
      const threads = rawThreads.threads.reduce((coll, raw) => {
        const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });
        if (parent && thread.parentId !== parent.id)
          return coll;
        return coll.set(thread.id, thread);
      }, new Collection);
      const threadMembers = rawThreads.members.reduce((coll, raw) => {
        const thread = threads.get(raw.id);
        return thread ? coll.set(raw.user_id, thread.members._add(raw)) : coll;
      }, new Collection);
      const response = { threads, members: threadMembers };
      if ("has_more" in rawThreads)
        response.hasMore = rawThreads.has_more;
      return response;
    }
  }
  module.exports = ThreadManager;
});

// ../../node_modules/discord.js/src/managers/GuildTextThreadManager.js
var require_GuildTextThreadManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class GuildTextThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      startMessage,
      type,
      invitable,
      reason,
      rateLimitPerUser
    } = {}) {
      let resolvedType = this.channel.type === ChannelType.GuildAnnouncement ? ChannelType.AnnouncementThread : ChannelType.PublicThread;
      let startMessageId;
      if (startMessage) {
        startMessageId = this.channel.messages.resolveId(startMessage);
        if (!startMessageId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "startMessage", "MessageResolvable");
      } else if (this.channel.type !== ChannelType.GuildAnnouncement) {
        resolvedType = type ?? resolvedType;
      }
      const data = await this.client.rest.post(Routes.threads(this.channel.id, startMessageId), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          type: resolvedType,
          invitable: resolvedType === ChannelType.PrivateThread ? invitable : undefined,
          rate_limit_per_user: rateLimitPerUser
        },
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildTextThreadManager;
});

// ../../node_modules/discord.js/src/structures/BaseGuildTextChannel.js
var require_BaseGuildTextChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();

  class BaseGuildTextChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.threads = new GuildTextThreadManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("nsfw" in data) {
        this.nsfw = Boolean(data.nsfw);
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      }
      if ("default_thread_rate_limit_per_user" in data) {
        this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
      } else {
        this.defaultThreadRateLimitPerUser ??= null;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setType(type, reason) {
      return this.edit({ type, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    get lastMessage() {}
    get lastPinAt() {}
    send() {}
    sendTyping() {}
    createMessageCollector() {}
    awaitMessages() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
    bulkDelete() {}
    fetchWebhooks() {}
    createWebhook() {}
    setRateLimitPerUser() {}
    setNSFW() {}
  }
  TextBasedChannel.applyToClass(BaseGuildTextChannel, true);
  module.exports = BaseGuildTextChannel;
});

// ../../node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var BaseGuildTextChannel = require_BaseGuildTextChannel();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class NewsChannel extends BaseGuildTextChannel {
    async addFollower(channel, reason) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      await this.client.rest.post(Routes.channelFollowers(this.id), { body: { webhook_channel_id: channelId }, reason });
      return this;
    }
  }
  module.exports = NewsChannel;
});

// ../../node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js
var require_BaseGuildVoiceChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { PermissionFlagsBits } = require_v106();
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();

  class BaseGuildVoiceChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("rtc_region" in data) {
        this.rtcRegion = data.rtc_region;
      }
      if ("bitrate" in data) {
        this.bitrate = data.bitrate;
      }
      if ("user_limit" in data) {
        this.userLimit = data.user_limit;
      }
      if ("video_quality_mode" in data) {
        this.videoQualityMode = data.video_quality_mode;
      } else {
        this.videoQualityMode ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      }
    }
    get members() {
      const coll = new Collection;
      for (const state of this.guild.voiceStates.cache.values()) {
        if (state.channelId === this.id && state.member) {
          coll.set(state.id, state.member);
        }
      }
      return coll;
    }
    get full() {
      return this.userLimit > 0 && this.members.size >= this.userLimit;
    }
    get joinable() {
      if (!this.viewable)
        return false;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Connect, false);
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setBitrate(bitrate, reason) {
      return this.edit({ bitrate, reason });
    }
    setRTCRegion(rtcRegion, reason) {
      return this.edit({ rtcRegion, reason });
    }
    setUserLimit(userLimit, reason) {
      return this.edit({ userLimit, reason });
    }
    setVideoQualityMode(videoQualityMode, reason) {
      return this.edit({ videoQualityMode, reason });
    }
    get lastMessage() {}
    send() {}
    sendTyping() {}
    createMessageCollector() {}
    awaitMessages() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
    bulkDelete() {}
    fetchWebhooks() {}
    createWebhook() {}
    setRateLimitPerUser() {}
    setNSFW() {}
  }
  TextBasedChannel.applyToClass(BaseGuildVoiceChannel, true, ["lastPinAt"]);
  module.exports = BaseGuildVoiceChannel;
});

// ../../node_modules/discord.js/src/structures/StageChannel.js
var require_StageChannel = __commonJS((exports, module) => {
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class StageChannel extends BaseGuildVoiceChannel {
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
    }
    get stageInstance() {
      return this.guild.stageInstances.cache.find((stageInstance) => stageInstance.channelId === this.id) ?? null;
    }
    createStageInstance(options) {
      return this.guild.stageInstances.create(this.id, options);
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
  }
  module.exports = StageChannel;
});

// ../../node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS((exports, module) => {
  var BaseGuildTextChannel = require_BaseGuildTextChannel();

  class TextChannel extends BaseGuildTextChannel {
    _patch(data) {
      super._patch(data);
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
  }
  module.exports = TextChannel;
});

// ../../node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS((exports, module) => {
  var { PermissionFlagsBits, Routes } = require_v106();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class VoiceChannel extends BaseGuildVoiceChannel {
    get joinable() {
      if (!super.joinable)
        return false;
      if (this.full && !this.permissionsFor(this.client.user).has(PermissionFlagsBits.MoveMembers, false))
        return false;
      return true;
    }
    get speakable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Speak, false);
    }
    async sendSoundboardSound(sound) {
      await this.client.rest.post(Routes.sendSoundboardSound(this.id), {
        body: {
          sound_id: sound.soundId,
          source_guild_id: sound.guildId ?? undefined
        }
      });
    }
  }
  module.exports = VoiceChannel;
});

// ../../node_modules/discord.js/src/structures/DirectoryChannel.js
var require_DirectoryChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();

  class DirectoryChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(client, data);
      this.guild = guild;
      this.guildId = guild.id;
    }
    _patch(data) {
      super._patch(data);
      this.name = data.name;
    }
  }
  module.exports = DirectoryChannel;
});

// ../../node_modules/discord.js/src/managers/PartialGroupDMMessageManager.js
var require_PartialGroupDMMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class PartialGroupDMMessageManager extends MessageManager {
  }
  module.exports = PartialGroupDMMessageManager;
});

// ../../node_modules/discord.js/src/structures/PartialGroupDMChannel.js
var require_PartialGroupDMChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var PartialGroupDMMessageManager = require_PartialGroupDMMessageManager();

  class PartialGroupDMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.flags = null;
      this.name = data.name;
      this.icon = data.icon ?? null;
      this.recipients = data.recipients ?? [];
      this.messages = new PartialGroupDMMessageManager(this);
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      } else {
        this.ownerId ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      } else {
        this.lastMessageId ??= null;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      } else {
        this.lastPinTimestamp ??= null;
      }
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.channelIcon(this.id, this.icon, options);
    }
    async fetchOwner(options) {
      if (!this.ownerId) {
        throw new DiscordjsError(ErrorCodes.FetchOwnerId, "group DM");
      }
      return this.client.users.fetch(this.ownerId, options);
    }
    async delete() {
      throw new DiscordjsError(ErrorCodes.DeleteGroupDMChannel);
    }
    async fetch() {
      throw new DiscordjsError(ErrorCodes.FetchGroupDMChannel);
    }
    get lastMessage() {}
    get lastPinAt() {}
    createMessageComponentCollector() {}
    awaitMessageComponent() {}
  }
  TextBasedChannel.applyToClass(PartialGroupDMChannel, true, [
    "bulkDelete",
    "send",
    "sendTyping",
    "createMessageCollector",
    "awaitMessages",
    "fetchWebhooks",
    "createWebhook",
    "setRateLimitPerUser",
    "setNSFW"
  ]);
  module.exports = PartialGroupDMChannel;
});

// ../../node_modules/discord.js/src/structures/ForumChannel.js
var require_ForumChannel = __commonJS((exports, module) => {
  var ThreadOnlyChannel = require_ThreadOnlyChannel();

  class ForumChannel extends ThreadOnlyChannel {
    _patch(data) {
      super._patch(data);
      this.defaultForumLayout = data.default_forum_layout;
    }
    setDefaultForumLayout(defaultForumLayout, reason) {
      return this.edit({ defaultForumLayout, reason });
    }
  }
  module.exports = ForumChannel;
});

// ../../node_modules/discord.js/src/structures/MediaChannel.js
var require_MediaChannel = __commonJS((exports, module) => {
  var ThreadOnlyChannel = require_ThreadOnlyChannel();

  class MediaChannel extends ThreadOnlyChannel {
  }
  module.exports = MediaChannel;
});

// ../../node_modules/discord.js/src/util/Channels.js
var require_Channels = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var { ChannelType } = require_v106();
  var getCategoryChannel = lazy(() => require_CategoryChannel());
  var getDMChannel = lazy(() => require_DMChannel());
  var getNewsChannel = lazy(() => require_NewsChannel());
  var getStageChannel = lazy(() => require_StageChannel());
  var getTextChannel = lazy(() => require_TextChannel());
  var getThreadChannel = lazy(() => require_ThreadChannel());
  var getVoiceChannel = lazy(() => require_VoiceChannel());
  var getDirectoryChannel = lazy(() => require_DirectoryChannel());
  var getPartialGroupDMChannel = lazy(() => require_PartialGroupDMChannel());
  var getForumChannel = lazy(() => require_ForumChannel());
  var getMediaChannel = lazy(() => require_MediaChannel());
  function createChannel(client, data, guild, { allowUnknownGuild } = {}) {
    let channel;
    if (!data.guild_id && !guild) {
      if (data.recipients && data.type !== ChannelType.GroupDM || data.type === ChannelType.DM) {
        channel = new (getDMChannel())(client, data);
      } else if (data.type === ChannelType.GroupDM) {
        channel = new (getPartialGroupDMChannel())(client, data);
      }
    } else {
      guild ??= client.guilds.cache.get(data.guild_id);
      if (guild || allowUnknownGuild) {
        switch (data.type) {
          case ChannelType.GuildText: {
            channel = new (getTextChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildVoice: {
            channel = new (getVoiceChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildCategory: {
            channel = new (getCategoryChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildAnnouncement: {
            channel = new (getNewsChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildStageVoice: {
            channel = new (getStageChannel())(guild, data, client);
            break;
          }
          case ChannelType.AnnouncementThread:
          case ChannelType.PublicThread:
          case ChannelType.PrivateThread: {
            channel = new (getThreadChannel())(guild, data, client);
            if (!allowUnknownGuild)
              channel.parent?.threads.cache.set(channel.id, channel);
            break;
          }
          case ChannelType.GuildDirectory:
            channel = new (getDirectoryChannel())(guild, data, client);
            break;
          case ChannelType.GuildForum:
            channel = new (getForumChannel())(guild, data, client);
            break;
          case ChannelType.GuildMedia:
            channel = new (getMediaChannel())(guild, data, client);
            break;
        }
        if (channel && !allowUnknownGuild)
          guild.channels?.cache.set(channel.id, channel);
      }
    }
    return channel;
  }
  function transformAPIGuildForumTag(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji: tag.emoji_id ?? tag.emoji_name ? {
        id: tag.emoji_id,
        name: tag.emoji_name
      } : null
    };
  }
  function transformGuildForumTag(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji_id: tag.emoji?.id ?? null,
      emoji_name: tag.emoji?.name ?? null
    };
  }
  function transformAPIGuildDefaultReaction(defaultReaction) {
    return {
      id: defaultReaction.emoji_id,
      name: defaultReaction.emoji_name
    };
  }
  function transformGuildDefaultReaction(defaultReaction) {
    return {
      emoji_id: defaultReaction.id,
      emoji_name: defaultReaction.name
    };
  }
  module.exports = {
    createChannel,
    transformAPIGuildForumTag,
    transformGuildForumTag,
    transformAPIGuildDefaultReaction,
    transformGuildDefaultReaction
  };
});

// ../../node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var { createChannel } = require_Channels();

  class ChannelUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      let channel = client.channels.cache.get(data.id);
      if (channel) {
        const old = channel._update(data);
        if (channel.type !== data.type) {
          const newChannel = createChannel(this.client, data, channel.guild);
          if (!newChannel) {
            this.client.channels.cache.delete(channel.id);
            return {};
          }
          if (channel.isTextBased() && newChannel.isTextBased()) {
            for (const [id, message] of channel.messages.cache)
              newChannel.messages.cache.set(id, message);
          }
          channel = newChannel;
          this.client.channels.cache.set(channel.id, channel);
        }
        return {
          old,
          updated: channel
        };
      } else {
        client.channels._add(data);
      }
      return {};
    }
  }
  module.exports = ChannelUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/EntitlementCreate.js
var require_EntitlementCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class EntitlementCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const entitlement = client.application.entitlements._add(data);
      client.emit(Events.EntitlementCreate, entitlement);
      return {};
    }
  }
  module.exports = EntitlementCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/EntitlementDelete.js
var require_EntitlementDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class EntitlementDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const entitlement = client.application.entitlements._add(data, false);
      client.application.entitlements.cache.delete(entitlement.id);
      client.emit(Events.EntitlementDelete, entitlement);
      return {};
    }
  }
  module.exports = EntitlementDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/EntitlementUpdate.js
var require_EntitlementUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class EntitlementUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const oldEntitlement = client.application.entitlements.cache.get(data.id)?._clone() ?? null;
      const newEntitlement = client.application.entitlements._add(data);
      client.emit(Events.EntitlementUpdate, oldEntitlement, newEntitlement);
      return {};
    }
  }
  module.exports = EntitlementUpdateAction;
});

// ../../node_modules/discord.js/src/structures/AutoModerationRule.js
var require_AutoModerationRule = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationRule extends Base {
    constructor(client, data, guild) {
      super(client);
      this.id = data.id;
      this.guild = guild;
      this.creatorId = data.creator_id;
      this.triggerType = data.trigger_type;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("event_type" in data) {
        this.eventType = data.event_type;
      }
      if ("trigger_metadata" in data) {
        this.triggerMetadata = {
          keywordFilter: data.trigger_metadata.keyword_filter ?? [],
          regexPatterns: data.trigger_metadata.regex_patterns ?? [],
          presets: data.trigger_metadata.presets ?? [],
          allowList: data.trigger_metadata.allow_list ?? [],
          mentionTotalLimit: data.trigger_metadata.mention_total_limit ?? null,
          mentionRaidProtectionEnabled: data.trigger_metadata.mention_raid_protection_enabled ?? false
        };
      }
      if ("actions" in data) {
        this.actions = data.actions.map((action) => _transformAPIAutoModerationAction(action));
      }
      if ("enabled" in data) {
        this.enabled = data.enabled;
      }
      if ("exempt_roles" in data) {
        this.exemptRoles = new Collection(data.exempt_roles.map((exemptRole) => [exemptRole, this.guild.roles.cache.get(exemptRole)]));
      }
      if ("exempt_channels" in data) {
        this.exemptChannels = new Collection(data.exempt_channels.map((exemptChannel) => [exemptChannel, this.guild.channels.cache.get(exemptChannel)]));
      }
    }
    edit(options) {
      return this.guild.autoModerationRules.edit(this.id, options);
    }
    delete(reason) {
      return this.guild.autoModerationRules.delete(this.id, reason);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setEventType(eventType, reason) {
      return this.edit({ eventType, reason });
    }
    setKeywordFilter(keywordFilter, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, keywordFilter }, reason });
    }
    setRegexPatterns(regexPatterns, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, regexPatterns }, reason });
    }
    setPresets(presets, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, presets }, reason });
    }
    setAllowList(allowList, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, allowList }, reason });
    }
    setMentionTotalLimit(mentionTotalLimit, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionTotalLimit }, reason });
    }
    setMentionRaidProtectionEnabled(mentionRaidProtectionEnabled, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionRaidProtectionEnabled }, reason });
    }
    setActions(actions, reason) {
      return this.edit({ actions, reason });
    }
    setEnabled(enabled = true, reason) {
      return this.edit({ enabled, reason });
    }
    setExemptRoles(exemptRoles, reason) {
      return this.edit({ exemptRoles, reason });
    }
    setExemptChannels(exemptChannels, reason) {
      return this.edit({ exemptChannels, reason });
    }
  }
  module.exports = AutoModerationRule;
});

// ../../node_modules/discord.js/src/structures/GuildOnboardingPromptOption.js
var require_GuildOnboardingPromptOption = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class GuildOnboardingPromptOption extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      const guild = this.guild;
      this.id = data.id;
      this.channels = data.channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.roles = data.role_ids.reduce((roles, roleId) => roles.set(roleId, guild.roles.cache.get(roleId)), new Collection);
      this._emoji = data.emoji;
      this.title = data.title;
      this.description = data.description;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
    get emoji() {
      if (!this._emoji.id && !this._emoji.name)
        return null;
      return this.client.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
  }
  exports.GuildOnboardingPromptOption = GuildOnboardingPromptOption;
});

// ../../node_modules/discord.js/src/structures/GuildOnboardingPrompt.js
var require_GuildOnboardingPrompt = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { GuildOnboardingPromptOption } = require_GuildOnboardingPromptOption();

  class GuildOnboardingPrompt extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      this.id = data.id;
      this.options = data.options.reduce((options, option) => options.set(option.id, new GuildOnboardingPromptOption(client, option, guildId)), new Collection);
      this.title = data.title;
      this.singleSelect = data.single_select;
      this.required = data.required;
      this.inOnboarding = data.in_onboarding;
      this.type = data.type;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboardingPrompt = GuildOnboardingPrompt;
});

// ../../node_modules/discord.js/src/structures/Integration.js
var require_Integration = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var Base = require_Base();
  var IntegrationApplication = require_IntegrationApplication();

  class Integration extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.id = data.id;
      this.name = data.name;
      this.type = data.type;
      this.enabled = data.enabled ?? null;
      if ("syncing" in data) {
        this.syncing = data.syncing;
      } else {
        this.syncing ??= null;
      }
      this.role = this.guild.roles.resolve(data.role_id);
      if ("enable_emoticons" in data) {
        this.enableEmoticons = data.enable_emoticons;
      } else {
        this.enableEmoticons ??= null;
      }
      if (data.user) {
        this.user = this.client.users._add(data.user);
      } else {
        this.user ??= null;
      }
      this.account = data.account;
      if ("synced_at" in data) {
        this.syncedTimestamp = Date.parse(data.synced_at);
      } else {
        this.syncedTimestamp ??= null;
      }
      if ("subscriber_count" in data) {
        this.subscriberCount = data.subscriber_count;
      } else {
        this.subscriberCount ??= null;
      }
      if ("revoked" in data) {
        this.revoked = data.revoked;
      } else {
        this.revoked ??= null;
      }
      this._patch(data);
    }
    get syncedAt() {
      return this.syncedTimestamp && new Date(this.syncedTimestamp);
    }
    get roles() {
      const roles = this.guild.roles.cache;
      return roles.filter((role) => role.tags?.integrationId === this.id);
    }
    _patch(data) {
      if ("expire_behavior" in data) {
        this.expireBehavior = data.expire_behavior;
      } else {
        this.expireBehavior ??= null;
      }
      if ("expire_grace_period" in data) {
        this.expireGracePeriod = data.expire_grace_period;
      } else {
        this.expireGracePeriod ??= null;
      }
      if ("application" in data) {
        if (this.application) {
          this.application._patch(data.application);
        } else {
          this.application = new IntegrationApplication(this.client, data.application);
        }
      } else {
        this.application ??= null;
      }
      if ("scopes" in data) {
        this.scopes = data.scopes;
      } else {
        this.scopes ??= [];
      }
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.guildIntegration(this.guild.id, this.id), { reason });
      return this;
    }
    toJSON() {
      return super.toJSON({
        role: "roleId",
        guild: "guildId",
        user: "userId"
      });
    }
  }
  module.exports = Integration;
});

// ../../node_modules/discord.js/src/structures/StageInstance.js
var require_StageInstance = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();

  class StageInstance extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this._patch(data);
    }
    _patch(data) {
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("privacy_level" in data) {
        this.privacyLevel = data.privacy_level;
      }
      if ("discoverable_disabled" in data) {
        this.discoverableDisabled = data.discoverable_disabled;
      } else {
        this.discoverableDisabled ??= null;
      }
      if ("guild_scheduled_event_id" in data) {
        this.guildScheduledEventId = data.guild_scheduled_event_id;
      } else {
        this.guildScheduledEventId ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get guildScheduledEvent() {
      return this.guild?.scheduledEvents.resolve(this.guildScheduledEventId) ?? null;
    }
    edit(options) {
      return this.guild.stageInstances.edit(this.channelId, options);
    }
    async delete() {
      await this.guild.stageInstances.delete(this.channelId);
      const clone = this._clone();
      return clone;
    }
    setTopic(topic) {
      return this.guild.stageInstances.edit(this.channelId, { topic });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
  }
  exports.StageInstance = StageInstance;
});

// ../../node_modules/discord.js/src/structures/GuildAuditLogsEntry.js
var require_GuildAuditLogsEntry = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var { AuditLogOptionsType, AuditLogEvent } = require_v106();
  var AutoModerationRule = require_AutoModerationRule();
  var { GuildOnboardingPrompt } = require_GuildOnboardingPrompt();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var Integration = require_Integration();
  var Invite = require_Invite();
  var { StageInstance } = require_StageInstance();
  var { Sticker } = require_Sticker();
  var Webhook = require_Webhook();
  var Partials = require_Partials();
  var { flatten } = require_Util();
  var Targets = {
    All: "All",
    Guild: "Guild",
    GuildScheduledEvent: "GuildScheduledEvent",
    Channel: "Channel",
    User: "User",
    Role: "Role",
    Invite: "Invite",
    Webhook: "Webhook",
    Emoji: "Emoji",
    Message: "Message",
    Integration: "Integration",
    StageInstance: "StageInstance",
    Sticker: "Sticker",
    Thread: "Thread",
    ApplicationCommand: "ApplicationCommand",
    AutoModeration: "AutoModeration",
    GuildOnboarding: "GuildOnboarding",
    GuildOnboardingPrompt: "GuildOnboardingPrompt",
    SoundboardSound: "SoundboardSound",
    Unknown: "Unknown"
  };
  function changesReduce(changes, initialData = {}) {
    return changes.reduce((accumulator, change) => {
      accumulator[change.key] = change.new ?? change.old;
      return accumulator;
    }, initialData);
  }

  class GuildAuditLogsEntry {
    static Targets = Targets;
    constructor(guild, data, logs) {
      this.targetType = GuildAuditLogsEntry.targetType(data.action_type);
      const targetType = this.targetType;
      this.actionType = GuildAuditLogsEntry.actionType(data.action_type);
      this.action = data.action_type;
      this.reason = data.reason ?? null;
      this.executorId = data.user_id;
      this.executor = data.user_id ? guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.user_id }) : guild.client.users.cache.get(data.user_id) ?? null : null;
      this.changes = data.changes?.map((change) => ({
        key: change.key,
        ..."old_value" in change ? { old: change.old_value } : {},
        ..."new_value" in change ? { new: change.new_value } : {}
      })) ?? [];
      this.id = data.id;
      this.extra = null;
      switch (data.action_type) {
        case AuditLogEvent.MemberPrune:
          this.extra = {
            removed: Number(data.options.members_removed),
            days: Number(data.options.delete_member_days)
          };
          break;
        case AuditLogEvent.MemberMove:
        case AuditLogEvent.MessageDelete:
          this.extra = {
            channel: guild.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.MessagePin:
        case AuditLogEvent.MessageUnpin:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            messageId: data.options.message_id
          };
          break;
        case AuditLogEvent.MessageBulkDelete:
        case AuditLogEvent.MemberDisconnect:
          this.extra = {
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.ChannelOverwriteCreate:
        case AuditLogEvent.ChannelOverwriteUpdate:
        case AuditLogEvent.ChannelOverwriteDelete:
          switch (data.options.type) {
            case AuditLogOptionsType.Role:
              this.extra = guild.roles.cache.get(data.options.id) ?? {
                id: data.options.id,
                name: data.options.role_name,
                type: AuditLogOptionsType.Role
              };
              break;
            case AuditLogOptionsType.Member:
              this.extra = guild.members.cache.get(data.options.id) ?? {
                id: data.options.id,
                type: AuditLogOptionsType.Member
              };
              break;
            default:
              break;
          }
          break;
        case AuditLogEvent.StageInstanceCreate:
        case AuditLogEvent.StageInstanceDelete:
        case AuditLogEvent.StageInstanceUpdate:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        case AuditLogEvent.ApplicationCommandPermissionUpdate:
          this.extra = {
            applicationId: data.options.application_id
          };
          break;
        case AuditLogEvent.AutoModerationBlockMessage:
        case AuditLogEvent.AutoModerationFlagToChannel:
        case AuditLogEvent.AutoModerationUserCommunicationDisabled:
          this.extra = {
            autoModerationRuleName: data.options.auto_moderation_rule_name,
            autoModerationRuleTriggerType: data.options.auto_moderation_rule_trigger_type,
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        case AuditLogEvent.MemberKick:
        case AuditLogEvent.MemberRoleUpdate: {
          if (data.integration_type) {
            this.extra = {
              integrationType: data.integration_type
            };
          }
          break;
        }
        default:
          break;
      }
      this.targetId = data.target_id;
      this.target = null;
      if (targetType === Targets.Unknown) {
        this.target = changesReduce(this.changes);
        this.target.id = data.target_id;
      } else if (targetType === Targets.User && data.target_id) {
        this.target = guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.target_id }) : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Guild) {
        this.target = guild.client.guilds.cache.get(data.target_id);
      } else if (targetType === Targets.Webhook) {
        this.target = logs?.webhooks.get(data.target_id) ?? new Webhook(guild.client, changesReduce(this.changes, {
          id: data.target_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Invite) {
        const inviteChange = this.changes.find(({ key }) => key === "code");
        this.target = guild.invites.cache.get(inviteChange.new ?? inviteChange.old) ?? new Invite(guild.client, changesReduce(this.changes, { guild }));
      } else if (targetType === Targets.Message) {
        this.target = data.action_type === AuditLogEvent.MessageBulkDelete ? guild.channels.cache.get(data.target_id) ?? { id: data.target_id } : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Integration) {
        this.target = logs?.integrations.get(data.target_id) ?? new Integration(guild.client, changesReduce(this.changes, { id: data.target_id }), guild);
      } else if (targetType === Targets.Channel || targetType === Targets.Thread) {
        this.target = guild.channels.cache.get(data.target_id) ?? changesReduce(this.changes, { id: data.target_id });
      } else if (targetType === Targets.StageInstance) {
        this.target = guild.stageInstances.cache.get(data.target_id) ?? new StageInstance(guild.client, changesReduce(this.changes, {
          id: data.target_id,
          channel_id: data.options?.channel_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Sticker) {
        this.target = guild.stickers.cache.get(data.target_id) ?? new Sticker(guild.client, changesReduce(this.changes, { id: data.target_id }));
      } else if (targetType === Targets.GuildScheduledEvent) {
        this.target = guild.scheduledEvents.cache.get(data.target_id) ?? new GuildScheduledEvent(guild.client, changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }));
      } else if (targetType === Targets.ApplicationCommand) {
        this.target = logs?.applicationCommands.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.AutoModeration) {
        this.target = guild.autoModerationRules.cache.get(data.target_id) ?? new AutoModerationRule(guild.client, changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }), guild);
      } else if (targetType === Targets.GuildOnboardingPrompt) {
        this.target = data.action_type === AuditLogEvent.OnboardingPromptCreate ? new GuildOnboardingPrompt(guild.client, changesReduce(this.changes, { id: data.target_id }), guild.id) : changesReduce(this.changes, { id: data.target_id });
      } else if (targetType === Targets.Role) {
        this.target = guild.roles.cache.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.Emoji) {
        this.target = guild.emojis.cache.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.SoundboardSound) {
        this.target = guild.soundboardSounds.cache.get(data.target_id) ?? { id: data.target_id };
      } else if (data.target_id) {
        this.target = { id: data.target_id };
      }
    }
    static targetType(target) {
      if (target < 10)
        return Targets.Guild;
      if (target < 20)
        return Targets.Channel;
      if (target < 30)
        return Targets.User;
      if (target < 40)
        return Targets.Role;
      if (target < 50)
        return Targets.Invite;
      if (target < 60)
        return Targets.Webhook;
      if (target < 70)
        return Targets.Emoji;
      if (target < 80)
        return Targets.Message;
      if (target < 83)
        return Targets.Integration;
      if (target < 86)
        return Targets.StageInstance;
      if (target < 100)
        return Targets.Sticker;
      if (target < 110)
        return Targets.GuildScheduledEvent;
      if (target < 120)
        return Targets.Thread;
      if (target < 130)
        return Targets.ApplicationCommand;
      if (target < 140)
        return Targets.SoundboardSound;
      if (target < 143)
        return Targets.AutoModeration;
      if (target < 146)
        return Targets.User;
      if (target >= 163 && target <= 165)
        return Targets.GuildOnboardingPrompt;
      if (target >= 160 && target < 170)
        return Targets.GuildOnboarding;
      return Targets.Unknown;
    }
    static actionType(action) {
      if ([
        AuditLogEvent.ChannelCreate,
        AuditLogEvent.ChannelOverwriteCreate,
        AuditLogEvent.MemberBanRemove,
        AuditLogEvent.BotAdd,
        AuditLogEvent.RoleCreate,
        AuditLogEvent.InviteCreate,
        AuditLogEvent.WebhookCreate,
        AuditLogEvent.EmojiCreate,
        AuditLogEvent.MessagePin,
        AuditLogEvent.IntegrationCreate,
        AuditLogEvent.StageInstanceCreate,
        AuditLogEvent.StickerCreate,
        AuditLogEvent.GuildScheduledEventCreate,
        AuditLogEvent.ThreadCreate,
        AuditLogEvent.SoundboardSoundCreate,
        AuditLogEvent.AutoModerationRuleCreate,
        AuditLogEvent.AutoModerationBlockMessage,
        AuditLogEvent.OnboardingPromptCreate,
        AuditLogEvent.OnboardingCreate
      ].includes(action)) {
        return "Create";
      }
      if ([
        AuditLogEvent.ChannelDelete,
        AuditLogEvent.ChannelOverwriteDelete,
        AuditLogEvent.MemberKick,
        AuditLogEvent.MemberPrune,
        AuditLogEvent.MemberBanAdd,
        AuditLogEvent.MemberDisconnect,
        AuditLogEvent.RoleDelete,
        AuditLogEvent.InviteDelete,
        AuditLogEvent.WebhookDelete,
        AuditLogEvent.EmojiDelete,
        AuditLogEvent.MessageDelete,
        AuditLogEvent.MessageBulkDelete,
        AuditLogEvent.MessageUnpin,
        AuditLogEvent.IntegrationDelete,
        AuditLogEvent.StageInstanceDelete,
        AuditLogEvent.StickerDelete,
        AuditLogEvent.GuildScheduledEventDelete,
        AuditLogEvent.ThreadDelete,
        AuditLogEvent.SoundboardSoundDelete,
        AuditLogEvent.AutoModerationRuleDelete,
        AuditLogEvent.OnboardingPromptDelete
      ].includes(action)) {
        return "Delete";
      }
      if ([
        AuditLogEvent.GuildUpdate,
        AuditLogEvent.ChannelUpdate,
        AuditLogEvent.ChannelOverwriteUpdate,
        AuditLogEvent.MemberUpdate,
        AuditLogEvent.MemberRoleUpdate,
        AuditLogEvent.MemberMove,
        AuditLogEvent.RoleUpdate,
        AuditLogEvent.InviteUpdate,
        AuditLogEvent.WebhookUpdate,
        AuditLogEvent.EmojiUpdate,
        AuditLogEvent.IntegrationUpdate,
        AuditLogEvent.StageInstanceUpdate,
        AuditLogEvent.StickerUpdate,
        AuditLogEvent.GuildScheduledEventUpdate,
        AuditLogEvent.ThreadUpdate,
        AuditLogEvent.SoundboardSoundUpdate,
        AuditLogEvent.ApplicationCommandPermissionUpdate,
        AuditLogEvent.AutoModerationRuleUpdate,
        AuditLogEvent.AutoModerationBlockMessage,
        AuditLogEvent.AutoModerationFlagToChannel,
        AuditLogEvent.AutoModerationUserCommunicationDisabled,
        AuditLogEvent.OnboardingPromptUpdate,
        AuditLogEvent.OnboardingUpdate
      ].includes(action)) {
        return "Update";
      }
      return "All";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toJSON() {
      return flatten(this, { createdTimestamp: true });
    }
  }
  module.exports = GuildAuditLogsEntry;
});

// ../../node_modules/discord.js/src/client/actions/GuildAuditLogEntryCreate.js
var require_GuildAuditLogEntryCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Events = require_Events();

  class GuildAuditLogEntryCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let auditLogEntry;
      if (guild) {
        auditLogEntry = new GuildAuditLogsEntry(guild, data);
        client.emit(Events.GuildAuditLogEntryCreate, auditLogEntry, guild);
      }
      return { auditLogEntry };
    }
  }
  module.exports = GuildAuditLogEntryCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildBanAdd.js
var require_GuildBanAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildBanAdd extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildBanAdd, guild.bans._add(data));
    }
  }
  module.exports = GuildBanAdd;
});

// ../../node_modules/discord.js/src/structures/GuildBan.js
var require_GuildBan = __commonJS((exports, module) => {
  var Base = require_Base();

  class GuildBan extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("reason" in data) {
        this.reason = data.reason;
      }
    }
    get partial() {
      return !("reason" in this);
    }
    fetch(force = true) {
      return this.guild.bans.fetch({ user: this.user, cache: true, force });
    }
  }
  module.exports = GuildBan;
});

// ../../node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildBan = require_GuildBan();
  var Events = require_Events();

  class GuildBanRemove extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);
        guild.bans.cache.delete(ban.user.id);
        client.emit(Events.GuildBanRemove, ban);
      }
    }
  }
  module.exports = GuildBanRemove;
});

// ../../node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildChannelsPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialChannel of data.channels) {
          const channel = guild.channels.cache.get(partialChannel.id);
          if (channel)
            channel.rawPosition = partialChannel.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildChannelsPositionUpdate;
});

// ../../node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      let guild = client.guilds.cache.get(data.id);
      if (guild) {
        if (data.unavailable) {
          guild.available = false;
          client.emit(Events.GuildUnavailable, guild);
          return;
        }
        for (const channel of guild.channels.cache.values())
          this.client.channels._remove(channel.id);
        client.voice.adapters.get(data.id)?.destroy();
        client.guilds.cache.delete(guild.id);
        client.emit(Events.GuildDelete, guild);
      }
    }
  }
  module.exports = GuildDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiCreateAction extends Action {
    handle(guild, createdEmoji) {
      const already = guild.emojis.cache.has(createdEmoji.id);
      const emoji = guild.emojis._add(createdEmoji);
      if (!already)
        this.client.emit(Events.GuildEmojiCreate, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiDeleteAction extends Action {
    handle(emoji) {
      emoji.guild.emojis.cache.delete(emoji.id);
      this.client.emit(Events.GuildEmojiDelete, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildEmojiUpdate, old, current);
      return { emoji: current };
    }
  }
  module.exports = GuildEmojiUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildEmojisUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.emojis)
        return;
      const deletions = new Map(guild.emojis.cache);
      for (const emoji of data.emojis) {
        const cachedEmoji = guild.emojis.cache.get(emoji.id);
        if (cachedEmoji) {
          deletions.delete(emoji.id);
          if (!cachedEmoji.equals(emoji)) {
            this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
          }
        } else {
          this.client.actions.GuildEmojiCreate.handle(guild, emoji);
        }
      }
      for (const emoji of deletions.values()) {
        this.client.actions.GuildEmojiDelete.handle(emoji);
      }
    }
  }
  module.exports = GuildEmojisUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildIntegrationsUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildIntegrationsUpdate, guild);
    }
  }
  module.exports = GuildIntegrationsUpdate;
});

// ../../node_modules/discord.js/src/util/Status.js
var require_Status = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "Ready",
    "Connecting",
    "Reconnecting",
    "Idle",
    "Nearly",
    "Disconnected",
    "WaitingForGuilds",
    "Identifying",
    "Resuming"
  ]);
});

// ../../node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberRemoveAction extends Action {
    handle(data, shard) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let member = null;
      if (guild) {
        member = this.getMember({ user: data.user }, guild);
        guild.memberCount--;
        if (member) {
          guild.members.cache.delete(member.id);
          if (shard.status === Status.Ready)
            client.emit(Events.GuildMemberRemove, member);
        }
        guild.presences.cache.delete(data.user.id);
        guild.voiceStates.cache.delete(data.user.id);
      }
      return { guild, member };
    }
  }
  module.exports = GuildMemberRemoveAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberUpdateAction extends Action {
    handle(data, shard) {
      const { client } = this;
      if (data.user.username) {
        const user = client.users.cache.get(data.user.id);
        if (!user) {
          client.users._add(data.user);
        } else if (!user._equals(data.user)) {
          client.actions.UserUpdate.handle(data.user);
        }
      }
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const member = this.getMember({ user: data.user }, guild);
        if (member) {
          const old = member._update(data);
          if (shard.status === Status.Ready && !member.equals(old))
            client.emit(Events.GuildMemberUpdate, old, member);
        } else {
          const newMember = guild.members._add(data);
          this.client.emit(Events.GuildMemberAvailable, newMember);
        }
      }
    }
  }
  module.exports = GuildMemberUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleCreate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        const already = guild.roles.cache.has(data.role.id);
        role = guild.roles._add(data.role);
        if (!already)
          client.emit(Events.GuildRoleCreate, role);
      }
      return { role };
    }
  }
  module.exports = GuildRoleCreate;
});

// ../../node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        role = guild.roles.cache.get(data.role_id);
        if (role) {
          guild.roles.cache.delete(data.role_id);
          client.emit(Events.GuildRoleDelete, role);
        }
      }
      return { role };
    }
  }
  module.exports = GuildRoleDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        let old = null;
        const role = guild.roles.cache.get(data.role.id);
        if (role) {
          old = role._update(data.role);
          client.emit(Events.GuildRoleUpdate, old, role);
        }
        return {
          old,
          updated: role
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildRoleUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildRolesPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialRole of data.roles) {
          const role = guild.roles.cache.get(partialRole.id);
          if (role)
            role.rawPosition = partialRole.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildRolesPositionUpdate;
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js
var require_GuildScheduledEventCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventCreate, guildScheduledEvent);
        return { guildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js
var require_GuildScheduledEventDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        if (guildScheduledEvent) {
          guild.scheduledEvents.cache.delete(guildScheduledEvent.id);
          client.emit(Events.GuildScheduledEventDelete, guildScheduledEvent);
          return { guildScheduledEvent };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js
var require_GuildScheduledEventUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldGuildScheduledEvent = guild.scheduledEvents.cache.get(data.id)?._clone() ?? null;
        const newGuildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventUpdate, oldGuildScheduledEvent, newGuildScheduledEvent);
        return { oldGuildScheduledEvent, newGuildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js
var require_GuildScheduledEventUserAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserAddAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserAdd, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserAddAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js
var require_GuildScheduledEventUserRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserRemoveAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserRemove, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserRemoveAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildSoundboardSoundDelete.js
var require_GuildSoundboardSoundDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildSoundboardSoundDeleteAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild)
        return {};
      const soundboardSound = this.getSoundboardSound(data, guild);
      if (soundboardSound) {
        guild.soundboardSounds.cache.delete(soundboardSound.soundId);
        this.client.emit(Events.GuildSoundboardSoundDelete, soundboardSound);
      }
      return { soundboardSound };
    }
  }
  module.exports = GuildSoundboardSoundDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildStickerCreate.js
var require_GuildStickerCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerCreateAction extends Action {
    handle(guild, createdSticker) {
      const already = guild.stickers.cache.has(createdSticker.id);
      const sticker = guild.stickers._add(createdSticker);
      if (!already)
        this.client.emit(Events.GuildStickerCreate, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildStickerDelete.js
var require_GuildStickerDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerDeleteAction extends Action {
    handle(sticker) {
      sticker.guild.stickers.cache.delete(sticker.id);
      this.client.emit(Events.GuildStickerDelete, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildStickerUpdate.js
var require_GuildStickerUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildStickerUpdate, old, current);
      return { sticker: current };
    }
  }
  module.exports = GuildStickerUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildStickersUpdate.js
var require_GuildStickersUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildStickersUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.stickers)
        return;
      const deletions = new Map(guild.stickers.cache);
      for (const sticker of data.stickers) {
        const cachedSticker = guild.stickers.cache.get(sticker.id);
        if (cachedSticker) {
          deletions.delete(sticker.id);
          if (!cachedSticker.equals(sticker)) {
            this.client.actions.GuildStickerUpdate.handle(cachedSticker, sticker);
          }
        } else {
          this.client.actions.GuildStickerCreate.handle(guild, sticker);
        }
      }
      for (const sticker of deletions.values()) {
        this.client.actions.GuildStickerDelete.handle(sticker);
      }
    }
  }
  module.exports = GuildStickersUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.id);
      if (guild) {
        const old = guild._update(data);
        client.emit(Events.GuildUpdate, old, guild);
        return {
          old,
          updated: guild
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildUpdateAction;
});

// ../../node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js
var require_CommandInteractionOptionResolver = __commonJS((exports, module) => {
  var { ApplicationCommandOptionType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class CommandInteractionOptionResolver {
    constructor(client, options, resolved) {
      Object.defineProperty(this, "client", { value: client });
      this._group = null;
      this._subcommand = null;
      this._hoistedOptions = options;
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.SubcommandGroup) {
        this._group = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.Subcommand) {
        this._subcommand = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      Object.defineProperty(this, "data", { value: Object.freeze([...options]) });
      Object.defineProperty(this, "resolved", { value: resolved ? Object.freeze(resolved) : null });
    }
    get(name, required = false) {
      const option = this._hoistedOptions.find((opt) => opt.name === name);
      if (!option) {
        if (required) {
          throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNotFound, name);
        }
        return null;
      }
      return option;
    }
    _getTypedOption(name, allowedTypes, properties, required) {
      const option = this.get(name, required);
      if (!option) {
        return null;
      } else if (!allowedTypes.includes(option.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionType, name, option.type, allowedTypes.join(", "));
      } else if (required && properties.every((prop) => option[prop] === null || option[prop] === undefined)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionEmpty, name, option.type);
      }
      return option;
    }
    getSubcommand(required = true) {
      if (required && !this._subcommand) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommand);
      }
      return this._subcommand;
    }
    getSubcommandGroup(required = false) {
      if (required && !this._group) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommandGroup);
      }
      return this._group;
    }
    getBoolean(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Boolean], ["value"], required);
      return option?.value ?? null;
    }
    getChannel(name, required = false, channelTypes = []) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Channel], ["channel"], required);
      const channel = option?.channel ?? null;
      if (channel && channelTypes.length > 0 && !channelTypes.includes(channel.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionInvalidChannelType, name, channel.type, channelTypes.join(", "));
      }
      return channel;
    }
    getString(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.String], ["value"], required);
      return option?.value ?? null;
    }
    getInteger(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Integer], ["value"], required);
      return option?.value ?? null;
    }
    getNumber(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Number], ["value"], required);
      return option?.value ?? null;
    }
    getUser(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["user"], required);
      return option?.user ?? null;
    }
    getMember(name) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["member"], false);
      return option?.member ?? null;
    }
    getRole(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Role, ApplicationCommandOptionType.Mentionable], ["role"], required);
      return option?.role ?? null;
    }
    getAttachment(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Attachment], ["attachment"], required);
      return option?.attachment ?? null;
    }
    getMentionable(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Mentionable], ["user", "member", "role"], required);
      return option?.member ?? option?.user ?? option?.role ?? null;
    }
    getMessage(name, required = false) {
      const option = this._getTypedOption(name, ["_MESSAGE"], ["message"], required);
      return option?.message ?? null;
    }
    getFocused(getFull = false) {
      const focusedOption = this._hoistedOptions.find((option) => option.focused);
      if (!focusedOption)
        throw new DiscordjsTypeError(ErrorCodes.AutocompleteInteractionOptionNoFocusedOption);
      return getFull ? focusedOption : focusedOption.value;
    }
  }
  module.exports = CommandInteractionOptionResolver;
});

// ../../node_modules/discord.js/src/structures/AutocompleteInteraction.js
var require_AutocompleteInteraction = __commonJS((exports, module) => {
  var { InteractionResponseType, Routes } = require_v106();
  var BaseInteraction = require_BaseInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class AutocompleteInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.responded = false;
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options ?? []);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    async respond(options) {
      if (this.responded)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ApplicationCommandAutocompleteResult,
          data: {
            choices: options.map(({ nameLocalizations, ...option }) => ({
              ...this.client.options.jsonTransformer(option),
              name_localizations: nameLocalizations
            }))
          }
        },
        auth: false
      });
      this.responded = true;
    }
  }
  module.exports = AutocompleteInteraction;
});

// ../../node_modules/discord.js/src/structures/InteractionCallback.js
var require_InteractionCallback = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();

  class InteractionCallback {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      this.id = data.id;
      this.type = data.type;
      this.activityInstanceId = data.activity_instance_id ?? null;
      this.responseMessageId = data.response_message_id ?? null;
      this.responseMessageLoading = data.response_message_loading ?? null;
      this.responseMessageEphemeral = data.response_message_ephemeral ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
  }
  module.exports = InteractionCallback;
});

// ../../node_modules/discord.js/src/structures/InteractionCallbackResource.js
var require_InteractionCallbackResource = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var getMessage = lazy(() => require_Message().Message);

  class InteractionCallbackResource {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      this.type = data.type;
      this.activityInstance = data.activity_instance ?? null;
      if ("message" in data) {
        this.message = this.client.channels.cache.get(data.message.channel_id)?.messages._add(data.message) ?? new (getMessage())(client, data.message);
      } else {
        this.message = null;
      }
    }
  }
  module.exports = InteractionCallbackResource;
});

// ../../node_modules/discord.js/src/structures/InteractionCallbackResponse.js
var require_InteractionCallbackResponse = __commonJS((exports, module) => {
  var InteractionCallback = require_InteractionCallback();
  var InteractionCallbackResource = require_InteractionCallbackResource();

  class InteractionCallbackResponse {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      this.interaction = new InteractionCallback(client, data.interaction);
      this.resource = data.resource ? new InteractionCallbackResource(client, data.resource) : null;
    }
  }
  module.exports = InteractionCallbackResponse;
});

// ../../node_modules/discord.js/src/structures/InteractionResponse.js
var require_InteractionResponse = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_cjs();
  var { InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class InteractionResponse {
    constructor(interaction, id) {
      this.interaction = interaction;
      this.id = id ?? interaction.id;
      this.client = interaction.client;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionResponse: this,
        interactionType: InteractionType.MessageComponent
      });
    }
    fetch() {
      return this.interaction.fetchReply();
    }
    delete() {
      return this.interaction.deleteReply();
    }
    edit(options) {
      return this.interaction.editReply(options);
    }
  }
  var InteractionCollector = require_InteractionCollector();
  module.exports = InteractionResponse;
});

// ../../node_modules/discord.js/src/structures/interfaces/InteractionResponses.js
var require_InteractionResponses = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { deprecate } = __require("util");
  var { makeURLSearchParams } = require_dist5();
  var { isJSONEncodable } = require_dist();
  var { InteractionResponseType, MessageFlags, Routes, InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var InteractionCallbackResponse = require_InteractionCallbackResponse();
  var InteractionCollector = require_InteractionCollector();
  var InteractionResponse = require_InteractionResponse();
  var MessagePayload = require_MessagePayload();
  var deprecationEmittedForEphemeralOption = false;
  var deprecationEmittedForFetchReplyOption = false;

  class InteractionResponses {
    async deferReply(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if ("ephemeral" in options) {
        if (!deprecationEmittedForEphemeralOption) {
          process2.emitWarning(`Supplying "ephemeral" for interaction response options is deprecated. Utilize flags instead.`);
          deprecationEmittedForEphemeralOption = true;
        }
      }
      if ("fetchReply" in options) {
        if (!deprecationEmittedForFetchReplyOption) {
          process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
          deprecationEmittedForFetchReplyOption = true;
        }
      }
      const flags = new MessageFlagsBitField(options.flags);
      if (options.ephemeral) {
        flags.add(MessageFlags.Ephemeral);
      }
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredChannelMessageWithSource,
          data: {
            flags: flags.bitfield
          }
        },
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.deferred = true;
      this.ephemeral = flags.has(MessageFlags.Ephemeral);
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    async reply(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if (typeof options !== "string") {
        if ("ephemeral" in options) {
          if (!deprecationEmittedForEphemeralOption) {
            process2.emitWarning(`Supplying "ephemeral" for interaction response options is deprecated. Utilize flags instead.`);
            deprecationEmittedForEphemeralOption = true;
          }
        }
        if ("fetchReply" in options) {
          if (!deprecationEmittedForFetchReplyOption) {
            process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
            deprecationEmittedForFetchReplyOption = true;
          }
        }
      }
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ChannelMessageWithSource,
          data
        },
        files,
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.ephemeral = Boolean(data.flags & MessageFlags.Ephemeral);
      this.replied = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    fetchReply(message = "@original") {
      return this.webhook.fetchMessage(message);
    }
    async editReply(options) {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      const msg = await this.webhook.editMessage(options.message ?? "@original", options);
      this.replied = true;
      return msg;
    }
    async deleteReply(message = "@original") {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      await this.webhook.deleteMessage(message);
    }
    async followUp(options) {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      const msg = await this.webhook.send(options);
      this.replied = true;
      return msg;
    }
    async deferUpdate(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if ("fetchReply" in options) {
        if (!deprecationEmittedForFetchReplyOption) {
          process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
          deprecationEmittedForFetchReplyOption = true;
        }
      }
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredMessageUpdate
        },
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.deferred = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interactionMetadata?.id);
    }
    async update(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      if (typeof options !== "string" && "fetchReply" in options) {
        if (!deprecationEmittedForFetchReplyOption) {
          process2.emitWarning(`Supplying "fetchReply" for interaction response options is deprecated. Utilize "withResponse" instead or fetch the response after using the method.`);
          deprecationEmittedForFetchReplyOption = true;
        }
      }
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.UpdateMessage,
          data
        },
        files,
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.replied = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interactionMetadata?.id);
    }
    async launchActivity({ withResponse } = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        query: makeURLSearchParams({ with_response: withResponse ?? false }),
        body: {
          type: InteractionResponseType.LaunchActivity
        },
        auth: false
      });
      this.replied = true;
      return withResponse ? new InteractionCallbackResponse(this.client, response) : undefined;
    }
    async showModal(modal, options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      const response = await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.Modal,
          data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)
        },
        auth: false,
        query: makeURLSearchParams({ with_response: options.withResponse ?? false })
      });
      this.replied = true;
      return options.withResponse ? new InteractionCallbackResponse(this.client, response) : undefined;
    }
    async sendPremiumRequired() {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.PremiumRequired
        },
        auth: false
      });
      this.replied = true;
    }
    async awaitModalSubmit(options) {
      if (typeof options.time !== "number")
        throw new DiscordjsError(ErrorCodes.InvalidType, "time", "number");
      const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };
      return new Promise((resolve, reject) => {
        const collector = new InteractionCollector(this.client, _options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    static applyToClass(structure, ignore = []) {
      const props = [
        "deferReply",
        "reply",
        "fetchReply",
        "editReply",
        "deleteReply",
        "followUp",
        "deferUpdate",
        "update",
        "launchActivity",
        "showModal",
        "sendPremiumRequired",
        "awaitModalSubmit"
      ];
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop));
      }
    }
  }
  InteractionResponses.prototype.sendPremiumRequired = deprecate(InteractionResponses.prototype.sendPremiumRequired, "InteractionResponses#sendPremiumRequired() is deprecated. Sending a premium-style button is the new Discord behaviour.");
  module.exports = InteractionResponses;
});

// ../../node_modules/discord.js/src/structures/MessageComponentInteraction.js
var require_MessageComponentInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();
  var { findComponentByCustomId } = require_Components();
  var getMessage = lazy(() => require_Message().Message);

  class MessageComponentInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(client, data.message);
      this.customId = data.data.custom_id;
      this.componentType = data.data.component_type;
      this.deferred = false;
      this.ephemeral = null;
      this.replied = false;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get component() {
      return findComponentByCustomId(this.message.components, this.customId);
    }
    deferReply() {}
    reply() {}
    fetchReply() {}
    editReply() {}
    deleteReply() {}
    followUp() {}
    deferUpdate() {}
    update() {}
    launchActivity() {}
    showModal() {}
    sendPremiumRequired() {}
    awaitModalSubmit() {}
  }
  InteractionResponses.applyToClass(MessageComponentInteraction);
  module.exports = MessageComponentInteraction;
});

// ../../node_modules/discord.js/src/structures/ButtonInteraction.js
var require_ButtonInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ButtonInteraction extends MessageComponentInteraction {
  }
  module.exports = ButtonInteraction;
});

// ../../node_modules/discord.js/src/structures/ChannelSelectMenuInteraction.js
var require_ChannelSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ChannelSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.channels = new Collection;
      for (const channel of Object.values(resolved?.channels ?? {})) {
        this.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
      }
    }
  }
  module.exports = ChannelSelectMenuInteraction;
});

// ../../node_modules/discord.js/src/structures/CommandInteraction.js
var require_CommandInteraction = __commonJS((exports, module) => {
  var Attachment = require_Attachment();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();

  class CommandInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    transformOption(option, resolved) {
      const result = {
        name: option.name,
        type: option.type
      };
      if ("value" in option)
        result.value = option.value;
      if ("options" in option)
        result.options = option.options.map((opt) => this.transformOption(opt, resolved));
      if (resolved) {
        const user = resolved.users?.[option.value];
        if (user)
          result.user = this.client.users._add(user);
        const member = resolved.members?.[option.value];
        if (member)
          result.member = this.guild?.members._add({ user, ...member }) ?? member;
        const channel = resolved.channels?.[option.value];
        if (channel)
          result.channel = this.client.channels._add(channel, this.guild) ?? channel;
        const role = resolved.roles?.[option.value];
        if (role)
          result.role = this.guild?.roles._add(role) ?? role;
        const attachment = resolved.attachments?.[option.value];
        if (attachment)
          result.attachment = new Attachment(attachment);
      }
      return result;
    }
    deferReply() {}
    reply() {}
    fetchReply() {}
    editReply() {}
    deleteReply() {}
    followUp() {}
    launchActivity() {}
    showModal() {}
    sendPremiumRequired() {}
    awaitModalSubmit() {}
  }
  InteractionResponses.applyToClass(CommandInteraction, ["deferUpdate", "update"]);
  module.exports = CommandInteraction;
});

// ../../node_modules/discord.js/src/structures/ChatInputCommandInteraction.js
var require_ChatInputCommandInteraction = __commonJS((exports, module) => {
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { transformResolved } = require_Util();

  class ChatInputCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options?.map((option) => this.transformOption(option, data.data.resolved)) ?? [], transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved));
    }
    toString() {
      const properties = [
        this.commandName,
        this.options._group,
        this.options._subcommand,
        ...this.options._hoistedOptions.map((option) => `${option.name}:${option.value}`)
      ];
      return `/${properties.filter(Boolean).join(" ")}`;
    }
  }
  module.exports = ChatInputCommandInteraction;
});

// ../../node_modules/discord.js/src/structures/MentionableSelectMenuInteraction.js
var require_MentionableSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class MentionableSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      const { members, users, roles } = resolved ?? {};
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      this.roles = new Collection;
      if (members) {
        for (const [id, member] of Object.entries(members)) {
          const user = users[id];
          if (!user) {
            this.client.emit(Events.Debug, `[MentionableSelectMenuInteraction] Received a member without a user, skipping ${id}`);
            continue;
          }
          this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
        }
      }
      if (users) {
        for (const user of Object.values(users)) {
          this.users.set(user.id, this.client.users._add(user));
        }
      }
      if (roles) {
        for (const role of Object.values(roles)) {
          this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
        }
      }
    }
  }
  module.exports = MentionableSelectMenuInteraction;
});

// ../../node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js
var require_ContextMenuCommandInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var { ApplicationCommandOptionType } = require_v106();
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { transformResolved } = require_Util();
  var getMessage = lazy(() => require_Message().Message);

  class ContextMenuCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, this.resolveContextMenuOptions(data.data), transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved));
      this.targetId = data.data.target_id;
    }
    resolveContextMenuOptions({ target_id, resolved }) {
      const result = [];
      if (resolved.users?.[target_id]) {
        result.push(this.transformOption({ name: "user", type: ApplicationCommandOptionType.User, value: target_id }, resolved));
      }
      if (resolved.messages?.[target_id]) {
        result.push({
          name: "message",
          type: "_MESSAGE",
          value: target_id,
          message: this.channel?.messages._add(resolved.messages[target_id]) ?? new (getMessage())(this.client, resolved.messages[target_id])
        });
      }
      return result;
    }
  }
  module.exports = ContextMenuCommandInteraction;
});

// ../../node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js
var require_MessageContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class MessageContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetMessage() {
      return this.options.getMessage("message");
    }
  }
  module.exports = MessageContextMenuCommandInteraction;
});

// ../../node_modules/discord.js/src/structures/ModalSubmitFields.js
var require_ModalSubmitFields = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { ComponentType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class ModalSubmitFields {
    constructor(components) {
      this.components = components;
      this.fields = components.reduce((accumulator, next) => {
        next.components.forEach((component) => accumulator.set(component.customId, component));
        return accumulator;
      }, new Collection);
    }
    getField(customId, type) {
      const field = this.fields.get(customId);
      if (!field)
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldNotFound, customId);
      if (type !== undefined && type !== field.type) {
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldType, customId, field.type, type);
      }
      return field;
    }
    getTextInputValue(customId) {
      return this.getField(customId, ComponentType.TextInput).value;
    }
  }
  module.exports = ModalSubmitFields;
});

// ../../node_modules/discord.js/src/structures/ModalSubmitInteraction.js
var require_ModalSubmitInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var ModalSubmitFields = require_ModalSubmitFields();
  var InteractionResponses = require_InteractionResponses();
  var getMessage = lazy(() => require_Message().Message);

  class ModalSubmitInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.customId = data.data.custom_id;
      if ("message" in data) {
        this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(this.client, data.message);
      } else {
        this.message = null;
      }
      this.components = data.data.components?.map((component) => ModalSubmitInteraction.transformComponent(component));
      this.fields = new ModalSubmitFields(this.components);
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    static transformComponent(rawComponent) {
      return rawComponent.components ? {
        type: rawComponent.type,
        components: rawComponent.components.map((component) => this.transformComponent(component))
      } : {
        value: rawComponent.value,
        type: rawComponent.type,
        customId: rawComponent.custom_id
      };
    }
    isFromMessage() {
      return Boolean(this.message);
    }
    deferReply() {}
    reply() {}
    fetchReply() {}
    editReply() {}
    deleteReply() {}
    followUp() {}
    deferUpdate() {}
    update() {}
    sendPremiumRequired() {}
    launchActivity() {}
  }
  InteractionResponses.applyToClass(ModalSubmitInteraction, "showModal");
  module.exports = ModalSubmitInteraction;
});

// ../../node_modules/discord.js/src/structures/PrimaryEntryPointCommandInteraction.js
var require_PrimaryEntryPointCommandInteraction = __commonJS((exports, module) => {
  var CommandInteraction = require_CommandInteraction();

  class PrimaryEntryPointCommandInteraction extends CommandInteraction {
  }
  module.exports = PrimaryEntryPointCommandInteraction;
});

// ../../node_modules/discord.js/src/structures/RoleSelectMenuInteraction.js
var require_RoleSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class RoleSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.roles = new Collection;
      for (const role of Object.values(resolved?.roles ?? {})) {
        this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
      }
    }
  }
  module.exports = RoleSelectMenuInteraction;
});

// ../../node_modules/discord.js/src/structures/StringSelectMenuInteraction.js
var require_StringSelectMenuInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class StringSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      this.values = data.data.values ?? [];
    }
  }
  module.exports = StringSelectMenuInteraction;
});

// ../../node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js
var require_UserContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class UserContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetUser() {
      return this.options.getUser("user");
    }
    get targetMember() {
      return this.options.getMember("user");
    }
  }
  module.exports = UserContextMenuCommandInteraction;
});

// ../../node_modules/discord.js/src/structures/UserSelectMenuInteraction.js
var require_UserSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class UserSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      for (const user of Object.values(resolved?.users ?? {})) {
        this.users.set(user.id, this.client.users._add(user));
      }
      for (const [id, member] of Object.entries(resolved?.members ?? {})) {
        const user = resolved.users[id];
        if (!user) {
          this.client.emit(Events.Debug, `[UserSelectMenuInteraction] Received a member without a user, skipping ${id}`);
          continue;
        }
        this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
      }
    }
  }
  module.exports = UserSelectMenuInteraction;
});

// ../../node_modules/discord.js/src/client/actions/InteractionCreate.js
var require_InteractionCreate = __commonJS((exports, module) => {
  var { InteractionType, ComponentType, ApplicationCommandType } = require_v106();
  var Action = require_Action();
  var AutocompleteInteraction = require_AutocompleteInteraction();
  var ButtonInteraction = require_ButtonInteraction();
  var ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  var ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  var MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  var MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  var ModalSubmitInteraction = require_ModalSubmitInteraction();
  var PrimaryEntryPointCommandInteraction = require_PrimaryEntryPointCommandInteraction();
  var RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  var UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  var Events = require_Events();

  class InteractionCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = data.channel && this.getChannel(data.channel);
      let InteractionClass;
      switch (data.type) {
        case InteractionType.ApplicationCommand:
          switch (data.data.type) {
            case ApplicationCommandType.ChatInput:
              InteractionClass = ChatInputCommandInteraction;
              break;
            case ApplicationCommandType.User:
              InteractionClass = UserContextMenuCommandInteraction;
              break;
            case ApplicationCommandType.Message:
              if (channel && !channel.isTextBased())
                return;
              InteractionClass = MessageContextMenuCommandInteraction;
              break;
            case ApplicationCommandType.PrimaryEntryPoint:
              InteractionClass = PrimaryEntryPointCommandInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received application command interaction with unknown type: ${data.data.type}`);
              return;
          }
          break;
        case InteractionType.MessageComponent:
          if (channel && !channel.isTextBased())
            return;
          switch (data.data.component_type) {
            case ComponentType.Button:
              InteractionClass = ButtonInteraction;
              break;
            case ComponentType.StringSelect:
              InteractionClass = StringSelectMenuInteraction;
              break;
            case ComponentType.UserSelect:
              InteractionClass = UserSelectMenuInteraction;
              break;
            case ComponentType.RoleSelect:
              InteractionClass = RoleSelectMenuInteraction;
              break;
            case ComponentType.MentionableSelect:
              InteractionClass = MentionableSelectMenuInteraction;
              break;
            case ComponentType.ChannelSelect:
              InteractionClass = ChannelSelectMenuInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received component interaction with unknown type: ${data.data.component_type}`);
              return;
          }
          break;
        case InteractionType.ApplicationCommandAutocomplete:
          InteractionClass = AutocompleteInteraction;
          break;
        case InteractionType.ModalSubmit:
          InteractionClass = ModalSubmitInteraction;
          break;
        default:
          client.emit(Events.Debug, `[INTERACTION] Received interaction with unknown type: ${data.type}`);
          return;
      }
      const interaction = new InteractionClass(client, data);
      client.emit(Events.InteractionCreate, interaction);
    }
  }
  module.exports = InteractionCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class InviteCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = guild.invites._add(inviteData);
      client.emit(Events.InviteCreate, invite);
      return { invite };
    }
  }
  module.exports = InviteCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Invite = require_Invite();
  var Events = require_Events();

  class InviteDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = new Invite(client, inviteData);
      guild.invites.cache.delete(invite.code);
      client.emit(Events.InviteDelete, invite);
      return { invite };
    }
  }
  module.exports = InviteDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({
        id: data.channel_id,
        author: data.author,
        ..."guild_id" in data && { guild_id: data.guild_id }
      });
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread()) {
          channel.messageCount++;
          channel.totalMessageSent++;
        }
        const existing = channel.messages.cache.get(data.id);
        if (existing && existing.author?.id !== this.client.user.id)
          return { message: existing };
        const message = existing ?? channel.messages._add(data);
        channel.lastMessageId = data.id;
        client.emit(Events.MessageCreate, message);
        return { message };
      }
      return {};
    }
  }
  module.exports = MessageCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      let message;
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount--;
        message = this.getMessage(data, channel);
        if (message) {
          channel.messages.cache.delete(message.id);
          client.emit(Events.MessageDelete, message);
        }
      }
      return { message };
    }
  }
  module.exports = MessageDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteBulkAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount -= data.ids.length;
        const ids = data.ids;
        const messages = new Collection;
        for (const id of ids) {
          const message = this.getMessage({
            id,
            guild_id: data.guild_id
          }, channel, false);
          if (message) {
            messages.set(message.id, message);
            channel.messages.cache.delete(id);
          }
        }
        if (messages.size > 0)
          client.emit(Events.MessageBulkDelete, messages, channel);
        return { messages };
      }
      return {};
    }
  }
  module.exports = MessageDeleteBulkAction;
});

// ../../node_modules/discord.js/src/client/actions/MessagePollVoteAdd.js
var require_MessagePollVoteAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessagePollVoteAddAction extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const { poll } = message;
      const answer = poll?.answers.get(data.answer_id);
      if (!answer)
        return false;
      answer.voteCount++;
      this.client.emit(Events.MessagePollVoteAdd, answer, data.user_id);
      return { poll };
    }
  }
  module.exports = MessagePollVoteAddAction;
});

// ../../node_modules/discord.js/src/client/actions/MessagePollVoteRemove.js
var require_MessagePollVoteRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessagePollVoteRemoveAction extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const { poll } = message;
      const answer = poll?.answers.get(data.answer_id);
      if (!answer)
        return false;
      answer.voteCount--;
      this.client.emit(Events.MessagePollVoteRemove, answer, data.user_id);
      return { poll };
    }
  }
  module.exports = MessagePollVoteRemoveAction;
});

// ../../node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Partials = require_Partials();

  class MessageReactionAdd extends Action {
    handle(data, fromStructure = false) {
      if (!data.emoji)
        return false;
      const user = this.getUserFromMember(data);
      if (!user)
        return false;
      const channel = this.getChannel({
        id: data.channel_id,
        ..."guild_id" in data && { guild_id: data.guild_id },
        user_id: data.user_id,
        ...this.spreadInjectedData(data)
      });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const includePartial = this.client.options.partials.includes(Partials.Reaction);
      if (message.partial && !includePartial)
        return false;
      const reaction = message.reactions._add({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user.id === this.client.user.id,
        burst_colors: data.burst_colors
      });
      if (!reaction)
        return false;
      reaction._add(user, data.burst);
      if (fromStructure)
        return { message, reaction, user };
      this.client.emit(Events.MessageReactionAdd, reaction, user, { type: data.type, burst: data.burst });
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionAdd;
});

// ../../node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemove extends Action {
    handle(data) {
      if (!data.emoji)
        return false;
      const user = this.getUser(data);
      if (!user)
        return false;
      const channel = this.getChannel({
        id: data.channel_id,
        ..."guild_id" in data && { guild_id: data.guild_id },
        user_id: data.user_id
      });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message, user);
      if (!reaction)
        return false;
      reaction._remove(user, data.burst);
      this.client.emit(Events.MessageReactionRemove, reaction, user, { type: data.type, burst: data.burst });
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionRemove;
});

// ../../node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveAll extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const removed = message.reactions.cache.clone();
      message.reactions.cache.clear();
      this.client.emit(Events.MessageReactionRemoveAll, message, removed);
      return { message };
    }
  }
  module.exports = MessageReactionRemoveAll;
});

// ../../node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveEmoji extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message);
      if (!reaction)
        return false;
      if (!message.partial)
        message.reactions.cache.delete(reaction.emoji.id ?? reaction.emoji.name);
      this.client.emit(Events.MessageReactionRemoveEmoji, reaction);
      return { reaction };
    }
  }
  module.exports = MessageReactionRemoveEmoji;
});

// ../../node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class MessageUpdateAction extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (channel) {
        if (!channel.isTextBased())
          return {};
        const { id, channel_id, guild_id, author, timestamp, type } = data;
        const message = this.getMessage({ id, channel_id, guild_id, author, timestamp, type }, channel);
        if (message) {
          const old = message._update(data);
          return {
            old,
            updated: message
          };
        }
      }
      return {};
    }
  }
  module.exports = MessageUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Partials = require_Partials();

  class PresenceUpdateAction extends Action {
    handle(data) {
      let user = this.client.users.cache.get(data.user.id);
      if (!user && (("username" in data.user) || this.client.options.partials.includes(Partials.User))) {
        user = this.client.users._add(data.user);
      }
      if (!user)
        return;
      if (data.user.username) {
        if (!user._equals(data.user))
          this.client.actions.UserUpdate.handle(data.user);
      }
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild)
        return;
      const oldPresence = guild.presences.cache.get(user.id)?._clone() ?? null;
      let member = guild.members.cache.get(user.id);
      if (!member && data.status !== "offline") {
        member = guild.members._add({
          user,
          deaf: false,
          mute: false
        });
        this.client.emit(Events.GuildMemberAvailable, member);
      }
      const newPresence = guild.presences._add(Object.assign(data, { guild }));
      if (this.client.listenerCount(Events.PresenceUpdate) && !newPresence.equals(oldPresence)) {
        this.client.emit(Events.PresenceUpdate, oldPresence, newPresence);
      }
    }
  }
  module.exports = PresenceUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/StageInstanceCreate.js
var require_StageInstanceCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceCreate, stageInstance);
        return { stageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/StageInstanceDelete.js
var require_StageInstanceDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        if (stageInstance) {
          channel.guild.stageInstances.cache.delete(stageInstance.id);
          client.emit(Events.StageInstanceDelete, stageInstance);
          return { stageInstance };
        }
      }
      return {};
    }
  }
  module.exports = StageInstanceDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/StageInstanceUpdate.js
var require_StageInstanceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel({ id: data.channel_id, guild_id: data.guild_id });
      if (channel) {
        const oldStageInstance = channel.guild.stageInstances.cache.get(data.id)?._clone() ?? null;
        const newStageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceUpdate, oldStageInstance, newStageInstance);
        return { oldStageInstance, newStageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/ThreadCreate.js
var require_ThreadCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const thread = client.channels._add(data);
      if (!existing && thread) {
        client.emit(Events.ThreadCreate, thread, data.newly_created ?? false);
      }
      return { thread };
    }
  }
  module.exports = ThreadCreateAction;
});

// ../../node_modules/discord.js/src/client/actions/ThreadDelete.js
var require_ThreadDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        client.channels._remove(thread.id);
        client.emit(Events.ThreadDelete, thread);
      }
      return { thread };
    }
  }
  module.exports = ThreadDeleteAction;
});

// ../../node_modules/discord.js/src/client/actions/ThreadListSync.js
var require_ThreadListSync = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadListSyncAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (!guild)
        return {};
      if (data.channel_ids) {
        for (const id of data.channel_ids) {
          const channel = client.channels.cache.get(id);
          if (channel)
            this.removeStale(channel);
        }
      } else {
        for (const channel of guild.channels.cache.values()) {
          this.removeStale(channel);
        }
      }
      const syncedThreads = data.threads.reduce((coll, rawThread) => {
        const thread = client.channels._add(rawThread);
        return coll.set(thread.id, thread);
      }, new Collection);
      for (const rawMember of Object.values(data.members)) {
        const thread = client.channels.cache.get(rawMember.id);
        if (thread) {
          thread.members._add(rawMember);
        }
      }
      client.emit(Events.ThreadListSync, syncedThreads, guild);
      return {
        syncedThreads
      };
    }
    removeStale(channel) {
      channel.threads?.cache.forEach((thread) => {
        if (!thread.archived) {
          this.client.channels._remove(thread.id);
        }
      });
    }
  }
  module.exports = ThreadListSyncAction;
});

// ../../node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js
var require_ThreadMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMemberUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        const member = thread.members.cache.get(data.user_id);
        if (!member) {
          const newMember = thread.members._add(data);
          return { newMember };
        }
        const old = member._update(data);
        client.emit(Events.ThreadMemberUpdate, old, member);
      }
      return {};
    }
  }
  module.exports = ThreadMemberUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js
var require_ThreadMembersUpdate = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMembersUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        thread.memberCount = data.member_count;
        const addedMembers = new Collection;
        const removedMembers = new Collection;
        data.added_members?.reduce((_addedMembers, addedMember) => _addedMembers.set(addedMember.user_id, thread.members._add(addedMember)), addedMembers);
        data.removed_member_ids?.reduce((removedMembersIds, removedMembersId) => {
          const threadMember = this.getThreadMember(removedMembersId, thread.members);
          if (threadMember)
            removedMembersIds.set(threadMember.id, threadMember);
          thread.members.cache.delete(removedMembersId);
          return removedMembersIds;
        }, removedMembers);
        if (addedMembers.size === 0 && removedMembers.size === 0) {
          return {};
        }
        client.emit(Events.ThreadMembersUpdate, addedMembers, removedMembers, thread);
      }
      return {};
    }
  }
  module.exports = ThreadMembersUpdateAction;
});

// ../../node_modules/discord.js/src/structures/Typing.js
var require_Typing = __commonJS((exports, module) => {
  var Base = require_Base();

  class Typing extends Base {
    constructor(channel, user, data) {
      super(channel.client);
      this.channel = channel;
      this.user = user;
      this._patch(data);
    }
    _patch(data) {
      if ("timestamp" in data) {
        this.startedTimestamp = data.timestamp * 1000;
      }
    }
    inGuild() {
      return this.guild !== null;
    }
    get startedAt() {
      return new Date(this.startedTimestamp);
    }
    get guild() {
      return this.channel.guild ?? null;
    }
    get member() {
      return this.guild?.members.resolve(this.user) ?? null;
    }
  }
  module.exports = Typing;
});

// ../../node_modules/discord.js/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS((exports, module) => {
  var Action = require_Action();
  var Typing = require_Typing();
  var Events = require_Events();

  class TypingStart extends Action {
    handle(data) {
      const channel = this.getChannel({ id: data.channel_id, ..."guild_id" in data && { guild_id: data.guild_id } });
      if (!channel)
        return;
      if (!channel.isTextBased()) {
        this.client.emit(Events.Warn, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
        return;
      }
      const user = this.getUserFromMember(data);
      if (user) {
        this.client.emit(Events.TypingStart, new Typing(channel, user, data));
      }
    }
  }
  module.exports = TypingStart;
});

// ../../node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class UserUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const newUser = data.id === client.user.id ? client.user : client.users.cache.get(data.id);
      const oldUser = newUser._update(data);
      if (!oldUser.equals(newUser)) {
        client.emit(Events.UserUpdate, oldUser, newUser);
        return {
          old: oldUser,
          updated: newUser
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = UserUpdateAction;
});

// ../../node_modules/discord.js/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var VoiceState = require_VoiceState();
  var Events = require_Events();

  class VoiceStateUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldState = guild.voiceStates.cache.get(data.user_id)?._clone() ?? new VoiceState(guild, { user_id: data.user_id });
        const newState = guild.voiceStates._add(data);
        let member = guild.members.cache.get(data.user_id);
        if (member && data.member) {
          member._patch(data.member);
        } else if (data.member?.user && data.member.joined_at) {
          member = guild.members._add(data.member);
        }
        if (member?.user.id === client.user.id) {
          client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
          client.voice.onVoiceStateUpdate(data);
        }
        client.emit(Events.VoiceStateUpdate, oldState, newState);
      }
    }
  }
  module.exports = VoiceStateUpdate;
});

// ../../node_modules/discord.js/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS((exports, module) => {
  var process2 = __require("process");
  var Action = require_Action();
  var deprecationEmitted = false;

  class WebhooksUpdate extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (!channel)
        return;
      client.emit("webhooksUpdate", channel);
      if (client.emit("webhookUpdate", channel) && !deprecationEmitted) {
        deprecationEmitted = true;
        process2.emitWarning("The webhookUpdate event is deprecated. Use webhooksUpdate instead.", "DeprecationWarning");
      }
    }
  }
  module.exports = WebhooksUpdate;
});

// ../../node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS((exports, module) => {
  class ActionsManager {
    injectedUser = Symbol("djs.actions.injectedUser");
    injectedChannel = Symbol("djs.actions.injectedChannel");
    injectedMessage = Symbol("djs.actions.injectedMessage");
    constructor(client) {
      this.client = client;
      this.register(require_ApplicationCommandPermissionsUpdate());
      this.register(require_AutoModerationActionExecution2());
      this.register(require_AutoModerationRuleCreate());
      this.register(require_AutoModerationRuleDelete());
      this.register(require_AutoModerationRuleUpdate());
      this.register(require_ChannelCreate());
      this.register(require_ChannelDelete());
      this.register(require_ChannelUpdate());
      this.register(require_EntitlementCreate());
      this.register(require_EntitlementDelete());
      this.register(require_EntitlementUpdate());
      this.register(require_GuildAuditLogEntryCreate());
      this.register(require_GuildBanAdd());
      this.register(require_GuildBanRemove());
      this.register(require_GuildChannelsPositionUpdate());
      this.register(require_GuildDelete());
      this.register(require_GuildEmojiCreate());
      this.register(require_GuildEmojiDelete());
      this.register(require_GuildEmojiUpdate());
      this.register(require_GuildEmojisUpdate());
      this.register(require_GuildIntegrationsUpdate());
      this.register(require_GuildMemberRemove());
      this.register(require_GuildMemberUpdate());
      this.register(require_GuildRoleCreate());
      this.register(require_GuildRoleDelete());
      this.register(require_GuildRoleUpdate());
      this.register(require_GuildRolesPositionUpdate());
      this.register(require_GuildScheduledEventCreate());
      this.register(require_GuildScheduledEventDelete());
      this.register(require_GuildScheduledEventUpdate());
      this.register(require_GuildScheduledEventUserAdd());
      this.register(require_GuildScheduledEventUserRemove());
      this.register(require_GuildSoundboardSoundDelete());
      this.register(require_GuildStickerCreate());
      this.register(require_GuildStickerDelete());
      this.register(require_GuildStickerUpdate());
      this.register(require_GuildStickersUpdate());
      this.register(require_GuildUpdate());
      this.register(require_InteractionCreate());
      this.register(require_InviteCreate());
      this.register(require_InviteDelete());
      this.register(require_MessageCreate());
      this.register(require_MessageDelete());
      this.register(require_MessageDeleteBulk());
      this.register(require_MessagePollVoteAdd());
      this.register(require_MessagePollVoteRemove());
      this.register(require_MessageReactionAdd());
      this.register(require_MessageReactionRemove());
      this.register(require_MessageReactionRemoveAll());
      this.register(require_MessageReactionRemoveEmoji());
      this.register(require_MessageUpdate());
      this.register(require_PresenceUpdate());
      this.register(require_StageInstanceCreate());
      this.register(require_StageInstanceDelete());
      this.register(require_StageInstanceUpdate());
      this.register(require_ThreadCreate());
      this.register(require_ThreadDelete());
      this.register(require_ThreadListSync());
      this.register(require_ThreadMemberUpdate());
      this.register(require_ThreadMembersUpdate());
      this.register(require_TypingStart());
      this.register(require_UserUpdate());
      this.register(require_VoiceStateUpdate());
      this.register(require_WebhooksUpdate());
    }
    register(Action) {
      this[Action.name.replace(/Action$/, "")] = new Action(this.client);
    }
  }
  module.exports = ActionsManager;
});

// ../../node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS((exports, module) => {
  var Events = require_Events();

  class ClientVoiceManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
      this.adapters = new Map;
      client.on(Events.ShardDisconnect, (_, shardId) => {
        for (const [guildId, adapter] of this.adapters.entries()) {
          if (client.guilds.cache.get(guildId)?.shardId === shardId) {
            adapter.destroy();
          }
        }
      });
    }
    onVoiceServer(payload) {
      this.adapters.get(payload.guild_id)?.onVoiceServerUpdate(payload);
    }
    onVoiceStateUpdate(payload) {
      if (payload.guild_id && payload.session_id && payload.user_id === this.client.user?.id) {
        this.adapters.get(payload.guild_id)?.onVoiceStateUpdate(payload);
      }
    }
  }
  module.exports = ClientVoiceManager;
});

// ../../node_modules/@discordjs/ws/node_modules/@discordjs/collection/dist/index.js
var require_dist9 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    findLast(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const val = entries[index][1];
        const key = entries[index][0];
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findLastKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const key = entries[index][0];
        const val = entries[index][1];
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    reduceRight(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      const entries = [...this.entries()];
      let accumulator;
      let index;
      if (initialValue === undefined) {
        if (entries.length === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = entries[entries.length - 1][1];
        index = entries.length - 1;
      } else {
        accumulator = initialValue;
        index = entries.length;
      }
      while (--index >= 0) {
        const key = entries[index][0];
        const val = entries[index][1];
        accumulator = fn(accumulator, val, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersection(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    union(other) {
      const coll = new this.constructor[Symbol.species](this);
      for (const [key, value] of other) {
        if (!coll.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    symmetricDifference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    toReversed() {
      return new this.constructor[Symbol.species](this).reverse();
    }
    toSorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.entries()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "2.1.1";
});

// ../../node_modules/@discordjs/ws/dist/index.js
var require_dist10 = __commonJS((exports, module) => {
  var __dirname = "/Users/roshan/Documents/Aigis/node_modules/@discordjs/ws/dist";
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    CloseCodes: () => CloseCodes,
    CompressionMethod: () => CompressionMethod,
    DefaultDeviceProperty: () => DefaultDeviceProperty,
    DefaultWebSocketManagerOptions: () => DefaultWebSocketManagerOptions,
    Encoding: () => Encoding,
    ImportantGatewayOpcodes: () => ImportantGatewayOpcodes,
    KnownNetworkErrorCodes: () => KnownNetworkErrorCodes,
    SimpleContextFetchingStrategy: () => SimpleContextFetchingStrategy,
    SimpleIdentifyThrottler: () => SimpleIdentifyThrottler,
    SimpleShardingStrategy: () => SimpleShardingStrategy,
    WebSocketManager: () => WebSocketManager,
    WebSocketShard: () => WebSocketShard,
    WebSocketShardDestroyRecovery: () => WebSocketShardDestroyRecovery,
    WebSocketShardEvents: () => WebSocketShardEvents,
    WebSocketShardStatus: () => WebSocketShardStatus,
    WorkerBootstrapper: () => WorkerBootstrapper,
    WorkerContextFetchingStrategy: () => WorkerContextFetchingStrategy,
    WorkerReceivePayloadOp: () => WorkerReceivePayloadOp,
    WorkerSendPayloadOp: () => WorkerSendPayloadOp,
    WorkerShardingStrategy: () => WorkerShardingStrategy,
    getInitialSendRateLimitState: () => getInitialSendRateLimitState,
    managerToFetchingStrategyOptions: () => managerToFetchingStrategyOptions,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  async function managerToFetchingStrategyOptions(manager) {
    const {
      buildIdentifyThrottler,
      buildStrategy,
      retrieveSessionInfo,
      updateSessionInfo,
      shardCount,
      shardIds,
      rest,
      ...managerOptions
    } = manager.options;
    return {
      ...managerOptions,
      gatewayInformation: await manager.fetchGatewayInformation(),
      shardCount: await manager.getShardCount()
    };
  }
  __name(managerToFetchingStrategyOptions, "managerToFetchingStrategyOptions");
  var SimpleContextFetchingStrategy = class _SimpleContextFetchingStrategy {
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    static {
      __name(this, "SimpleContextFetchingStrategy");
    }
    static throttlerCache = /* @__PURE__ */ new WeakMap;
    static async ensureThrottler(manager) {
      const throttler = _SimpleContextFetchingStrategy.throttlerCache.get(manager);
      if (throttler) {
        return throttler;
      }
      const newThrottler = await manager.options.buildIdentifyThrottler(manager);
      _SimpleContextFetchingStrategy.throttlerCache.set(manager, newThrottler);
      return newThrottler;
    }
    async retrieveSessionInfo(shardId) {
      return this.manager.options.retrieveSessionInfo(shardId);
    }
    updateSessionInfo(shardId, sessionInfo) {
      return this.manager.options.updateSessionInfo(shardId, sessionInfo);
    }
    async waitForIdentify(shardId, signal) {
      const throttler = await _SimpleContextFetchingStrategy.ensureThrottler(this.manager);
      await throttler.waitForIdentify(shardId, signal);
    }
  };
  var import_node_worker_threads2 = __require("worker_threads");
  var import_collection2 = require_dist9();
  var import_node_events = __require("events");
  var import_node_path = __require("path");
  var import_node_worker_threads = __require("worker_threads");
  var import_collection = require_dist9();
  var WorkerSendPayloadOp = /* @__PURE__ */ ((WorkerSendPayloadOp2) => {
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Connect"] = 0] = "Connect";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Destroy"] = 1] = "Destroy";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Send"] = 2] = "Send";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["SessionInfoResponse"] = 3] = "SessionInfoResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["ShardIdentifyResponse"] = 4] = "ShardIdentifyResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["FetchStatus"] = 5] = "FetchStatus";
    return WorkerSendPayloadOp2;
  })(WorkerSendPayloadOp || {});
  var WorkerReceivePayloadOp = /* @__PURE__ */ ((WorkerReceivePayloadOp2) => {
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Connected"] = 0] = "Connected";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Destroyed"] = 1] = "Destroyed";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Event"] = 2] = "Event";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["RetrieveSessionInfo"] = 3] = "RetrieveSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["UpdateSessionInfo"] = 4] = "UpdateSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WaitForIdentify"] = 5] = "WaitForIdentify";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["FetchStatusResponse"] = 6] = "FetchStatusResponse";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WorkerReady"] = 7] = "WorkerReady";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["CancelIdentify"] = 8] = "CancelIdentify";
    return WorkerReceivePayloadOp2;
  })(WorkerReceivePayloadOp || {});
  var WorkerShardingStrategy = class {
    static {
      __name(this, "WorkerShardingStrategy");
    }
    manager;
    options;
    #workers = [];
    #workerByShardId = new import_collection.Collection;
    connectPromises = new import_collection.Collection;
    destroyPromises = new import_collection.Collection;
    fetchStatusPromises = new import_collection.Collection;
    waitForIdentifyControllers = new import_collection.Collection;
    throttler;
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    async spawn(shardIds) {
      const shardsPerWorker = this.options.shardsPerWorker === "all" ? shardIds.length : this.options.shardsPerWorker;
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      const loops = Math.ceil(shardIds.length / shardsPerWorker);
      const promises = [];
      for (let idx = 0;idx < loops; idx++) {
        const slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);
        const workerData2 = {
          ...strategyOptions,
          shardIds: slice
        };
        promises.push(this.setupWorker(workerData2));
      }
      await Promise.all(promises);
    }
    async connect() {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 0,
          shardId
        };
        const promise = new Promise((resolve2) => this.connectPromises.set(shardId, resolve2));
        worker.postMessage(payload);
        promises.push(promise);
      }
      await Promise.all(promises);
    }
    async destroy(options = {}) {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 1,
          shardId,
          options
        };
        promises.push(new Promise((resolve2) => this.destroyPromises.set(shardId, resolve2)).then(async () => worker.terminate()));
        worker.postMessage(payload);
      }
      this.#workers = [];
      this.#workerByShardId.clear();
      await Promise.all(promises);
    }
    send(shardId, data) {
      const worker = this.#workerByShardId.get(shardId);
      if (!worker) {
        throw new Error(`No worker found for shard ${shardId}`);
      }
      const payload = {
        op: 2,
        shardId,
        payload: data
      };
      worker.postMessage(payload);
    }
    async fetchStatus() {
      const statuses = new import_collection.Collection;
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const nonce = Math.random();
        const payload = {
          op: 5,
          shardId,
          nonce
        };
        const promise = new Promise((resolve2) => this.fetchStatusPromises.set(nonce, resolve2));
        worker.postMessage(payload);
        const status = await promise;
        statuses.set(shardId, status);
      }
      return statuses;
    }
    async setupWorker(workerData2) {
      const worker = new import_node_worker_threads.Worker(this.resolveWorkerPath(), { workerData: workerData2 });
      await (0, import_node_events.once)(worker, "online");
      await this.waitForWorkerReady(worker);
      worker.on("error", (err) => {
        throw err;
      }).on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => {
        if ("op" in payload) {
          await this.onMessage(worker, payload);
        } else {
          await this.options.unknownPayloadHandler?.(payload);
        }
      });
      this.#workers.push(worker);
      for (const shardId of workerData2.shardIds) {
        this.#workerByShardId.set(shardId, worker);
      }
    }
    resolveWorkerPath() {
      const path = this.options.workerPath;
      if (!path) {
        return (0, import_node_path.join)(__dirname, "defaultWorker.js");
      }
      if ((0, import_node_path.isAbsolute)(path)) {
        return path;
      }
      if (/^\.\.?[/\\]/.test(path)) {
        return (0, import_node_path.resolve)(path);
      }
      try {
        return __require.resolve(path);
      } catch {
        return (0, import_node_path.resolve)(path);
      }
    }
    async waitForWorkerReady(worker) {
      return new Promise((resolve2) => {
        const handler = /* @__PURE__ */ __name((payload) => {
          if (payload.op === 7) {
            resolve2();
            worker.off("message", handler);
          }
        }, "handler");
        worker.on("message", handler);
      });
    }
    async onMessage(worker, payload) {
      switch (payload.op) {
        case 0: {
          this.connectPromises.get(payload.shardId)?.();
          this.connectPromises.delete(payload.shardId);
          break;
        }
        case 1: {
          this.destroyPromises.get(payload.shardId)?.();
          this.destroyPromises.delete(payload.shardId);
          break;
        }
        case 2: {
          this.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });
          break;
        }
        case 3: {
          const session = await this.manager.options.retrieveSessionInfo(payload.shardId);
          const response = {
            op: 3,
            nonce: payload.nonce,
            session
          };
          worker.postMessage(response);
          break;
        }
        case 4: {
          await this.manager.options.updateSessionInfo(payload.shardId, payload.session);
          break;
        }
        case 5: {
          const throttler = await this.ensureThrottler();
          try {
            const controller = new AbortController;
            this.waitForIdentifyControllers.set(payload.nonce, controller);
            await throttler.waitForIdentify(payload.shardId, controller.signal);
          } catch {
            return;
          }
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: true
          };
          worker.postMessage(response);
          break;
        }
        case 6: {
          this.fetchStatusPromises.get(payload.nonce)?.(payload.status);
          this.fetchStatusPromises.delete(payload.nonce);
          break;
        }
        case 7: {
          break;
        }
        case 8: {
          this.waitForIdentifyControllers.get(payload.nonce)?.abort();
          this.waitForIdentifyControllers.delete(payload.nonce);
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: false
          };
          worker.postMessage(response);
          break;
        }
        default: {
          await this.options.unknownPayloadHandler?.(payload);
          break;
        }
      }
    }
    async ensureThrottler() {
      this.throttler ??= await this.manager.options.buildIdentifyThrottler(this.manager);
      return this.throttler;
    }
  };
  var WorkerContextFetchingStrategy = class {
    constructor(options) {
      this.options = options;
      if (import_node_worker_threads2.isMainThread) {
        throw new Error("Cannot instantiate WorkerContextFetchingStrategy on the main thread");
      }
      import_node_worker_threads2.parentPort.on("message", (payload) => {
        if (payload.op === 3) {
          this.sessionPromises.get(payload.nonce)?.(payload.session);
          this.sessionPromises.delete(payload.nonce);
        }
        if (payload.op === 4) {
          const promise = this.waitForIdentifyPromises.get(payload.nonce);
          if (payload.ok) {
            promise?.resolve();
          } else {
            promise?.reject(promise.signal.reason);
          }
          this.waitForIdentifyPromises.delete(payload.nonce);
        }
      });
    }
    static {
      __name(this, "WorkerContextFetchingStrategy");
    }
    sessionPromises = new import_collection2.Collection;
    waitForIdentifyPromises = new import_collection2.Collection;
    async retrieveSessionInfo(shardId) {
      const nonce = Math.random();
      const payload = {
        op: 3,
        shardId,
        nonce
      };
      const promise = new Promise((resolve2) => this.sessionPromises.set(nonce, resolve2));
      import_node_worker_threads2.parentPort.postMessage(payload);
      return promise;
    }
    updateSessionInfo(shardId, sessionInfo) {
      const payload = {
        op: 4,
        shardId,
        session: sessionInfo
      };
      import_node_worker_threads2.parentPort.postMessage(payload);
    }
    async waitForIdentify(shardId, signal) {
      const nonce = Math.random();
      const payload = {
        op: 5,
        nonce,
        shardId
      };
      const promise = new Promise((resolve2, reject) => this.waitForIdentifyPromises.set(nonce, { signal, resolve: resolve2, reject }));
      import_node_worker_threads2.parentPort.postMessage(payload);
      const listener = /* @__PURE__ */ __name(() => {
        const payload2 = {
          op: 8,
          nonce
        };
        import_node_worker_threads2.parentPort.postMessage(payload2);
      }, "listener");
      signal.addEventListener("abort", listener);
      try {
        await promise;
      } finally {
        signal.removeEventListener("abort", listener);
      }
    }
  };
  var import_collection6 = require_dist9();
  var import_node_buffer = __require("buffer");
  var import_node_events2 = __require("events");
  var import_node_timers = __require("timers");
  var import_promises2 = __require("timers/promises");
  var import_node_url = __require("url");
  var import_node_util = __require("util");
  var import_node_zlib = __require("zlib");
  var import_collection5 = require_dist9();
  var import_util2 = require_dist();
  var import_async_queue2 = require_cjs2();
  var import_async_event_emitter = require_dist3();
  var import_v102 = require_v106();
  var import_ws = __require("ws");
  var import_node_process = __toESM2(__require("process"));
  var import_collection4 = require_dist9();
  var import_util = require_dist();
  var import_v10 = require_v106();
  var import_promises = __require("timers/promises");
  var import_collection3 = require_dist9();
  var import_async_queue = require_cjs2();
  var SimpleIdentifyThrottler = class {
    constructor(maxConcurrency) {
      this.maxConcurrency = maxConcurrency;
    }
    static {
      __name(this, "SimpleIdentifyThrottler");
    }
    states = new import_collection3.Collection;
    async waitForIdentify(shardId, signal) {
      const key = shardId % this.maxConcurrency;
      const state = this.states.ensure(key, () => {
        return {
          queue: new import_async_queue.AsyncQueue,
          resetsAt: Number.POSITIVE_INFINITY
        };
      });
      await state.queue.wait({ signal });
      try {
        const diff = state.resetsAt - Date.now();
        if (diff > 0 && diff <= 5000) {
          const time = diff + Math.random() * 1500;
          await (0, import_promises.setTimeout)(time);
        }
        state.resetsAt = Date.now() + 5000;
      } finally {
        state.queue.shift();
      }
    }
  };
  var Encoding = /* @__PURE__ */ ((Encoding2) => {
    Encoding2["JSON"] = "json";
    return Encoding2;
  })(Encoding || {});
  var CompressionMethod = /* @__PURE__ */ ((CompressionMethod2) => {
    CompressionMethod2["ZlibStream"] = "zlib-stream";
    return CompressionMethod2;
  })(CompressionMethod || {});
  var DefaultDeviceProperty = `@discordjs/ws 1.2.3`;
  var getDefaultSessionStore = (0, import_util.lazy)(() => new import_collection4.Collection);
  var DefaultWebSocketManagerOptions = {
    async buildIdentifyThrottler(manager) {
      const info = await manager.fetchGatewayInformation();
      return new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);
    },
    buildStrategy: /* @__PURE__ */ __name((manager) => new SimpleShardingStrategy(manager), "buildStrategy"),
    shardCount: null,
    shardIds: null,
    largeThreshold: null,
    initialPresence: null,
    identifyProperties: {
      browser: DefaultDeviceProperty,
      device: DefaultDeviceProperty,
      os: import_node_process.default.platform
    },
    version: import_v10.APIVersion,
    encoding: "json",
    compression: null,
    retrieveSessionInfo(shardId) {
      const store = getDefaultSessionStore();
      return store.get(shardId) ?? null;
    },
    updateSessionInfo(shardId, info) {
      const store = getDefaultSessionStore();
      if (info) {
        store.set(shardId, info);
      } else {
        store.delete(shardId);
      }
    },
    handshakeTimeout: 30000,
    helloTimeout: 60000,
    readyTimeout: 15000
  };
  var ImportantGatewayOpcodes = /* @__PURE__ */ new Set([
    import_v10.GatewayOpcodes.Heartbeat,
    import_v10.GatewayOpcodes.Identify,
    import_v10.GatewayOpcodes.Resume
  ]);
  function getInitialSendRateLimitState() {
    return {
      sent: 0,
      resetAt: Date.now() + 60000
    };
  }
  __name(getInitialSendRateLimitState, "getInitialSendRateLimitState");
  var KnownNetworkErrorCodes = /* @__PURE__ */ new Set(["ECONNRESET", "ECONNREFUSED", "ETIMEDOUT", "EAI_AGAIN"]);
  var getZlibSync = (0, import_util2.lazy)(async () => import("zlib-sync").then((mod) => mod.default).catch(() => null));
  var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
    WebSocketShardEvents2["Closed"] = "closed";
    WebSocketShardEvents2["Debug"] = "debug";
    WebSocketShardEvents2["Dispatch"] = "dispatch";
    WebSocketShardEvents2["Error"] = "error";
    WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
    WebSocketShardEvents2["Hello"] = "hello";
    WebSocketShardEvents2["Ready"] = "ready";
    WebSocketShardEvents2["Resumed"] = "resumed";
    return WebSocketShardEvents2;
  })(WebSocketShardEvents || {});
  var WebSocketShardStatus = /* @__PURE__ */ ((WebSocketShardStatus2) => {
    WebSocketShardStatus2[WebSocketShardStatus2["Idle"] = 0] = "Idle";
    WebSocketShardStatus2[WebSocketShardStatus2["Connecting"] = 1] = "Connecting";
    WebSocketShardStatus2[WebSocketShardStatus2["Resuming"] = 2] = "Resuming";
    WebSocketShardStatus2[WebSocketShardStatus2["Ready"] = 3] = "Ready";
    return WebSocketShardStatus2;
  })(WebSocketShardStatus || {});
  var WebSocketShardDestroyRecovery = /* @__PURE__ */ ((WebSocketShardDestroyRecovery2) => {
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Reconnect"] = 0] = "Reconnect";
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Resume"] = 1] = "Resume";
    return WebSocketShardDestroyRecovery2;
  })(WebSocketShardDestroyRecovery || {});
  var CloseCodes = /* @__PURE__ */ ((CloseCodes2) => {
    CloseCodes2[CloseCodes2["Normal"] = 1000] = "Normal";
    CloseCodes2[CloseCodes2["Resuming"] = 4200] = "Resuming";
    return CloseCodes2;
  })(CloseCodes || {});
  var WebSocketConstructor = (0, import_util2.shouldUseGlobalFetchAndWebSocket)() ? globalThis.WebSocket : import_ws.WebSocket;
  var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "WebSocketShard");
    }
    connection = null;
    useIdentifyCompress = false;
    inflate = null;
    textDecoder = new import_node_util.TextDecoder;
    replayedEvents = 0;
    isAck = true;
    sendRateLimitState = getInitialSendRateLimitState();
    initialHeartbeatTimeoutController = null;
    heartbeatInterval = null;
    lastHeartbeatAt = -1;
    initialConnectResolved = false;
    failedToConnectDueToNetworkError = false;
    sendQueue = new import_async_queue2.AsyncQueue;
    timeoutAbortControllers = new import_collection5.Collection;
    strategy;
    id;
    #status = 0;
    get status() {
      return this.#status;
    }
    constructor(strategy, id) {
      super();
      this.strategy = strategy;
      this.id = id;
    }
    async connect() {
      const controller = new AbortController;
      let promise;
      if (!this.initialConnectResolved) {
        promise = Promise.race([
          (0, import_node_events2.once)(this, "ready", { signal: controller.signal }),
          (0, import_node_events2.once)(this, "resumed", { signal: controller.signal })
        ]);
      }
      this.internalConnect();
      try {
        await promise;
      } catch ({ error }) {
        throw error;
      } finally {
        controller.abort();
      }
      this.initialConnectResolved = true;
    }
    async internalConnect() {
      if (this.#status !== 0) {
        throw new Error("Tried to connect a shard that wasn't idle");
      }
      const { version: version2, encoding, compression } = this.strategy.options;
      const params = new import_node_url.URLSearchParams({ v: version2, encoding });
      if (compression) {
        const zlib = await getZlibSync();
        if (zlib) {
          params.append("compress", compression);
          this.inflate = new zlib.Inflate({
            chunkSize: 65535,
            to: "string"
          });
        } else if (!this.useIdentifyCompress) {
          this.useIdentifyCompress = true;
          console.warn("WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress");
        }
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
      this.debug([`Connecting to ${url}`]);
      const connection = new WebSocketConstructor(url, [], {
        handshakeTimeout: this.strategy.options.handshakeTimeout ?? undefined
      });
      connection.binaryType = "arraybuffer";
      connection.onmessage = (event) => {
        this.onMessage(event.data, event.data instanceof ArrayBuffer);
      };
      connection.onerror = (event) => {
        this.onError(event.error);
      };
      connection.onclose = (event) => {
        this.onClose(event.code);
      };
      connection.onopen = () => {
        this.sendRateLimitState = getInitialSendRateLimitState();
      };
      this.connection = connection;
      this.#status = 1;
      const { ok } = await this.waitForEvent("hello", this.strategy.options.helloTimeout);
      if (!ok) {
        return;
      }
      if (session?.shardCount === this.strategy.options.shardCount) {
        await this.resume(session);
      } else {
        await this.identify();
      }
    }
    async destroy(options = {}) {
      if (this.#status === 0) {
        this.debug(["Tried to destroy a shard that was idle"]);
        return;
      }
      if (!options.code) {
        options.code = options.recover === 1 ? 4200 : 1000;
      }
      this.debug([
        "Destroying shard",
        `Reason: ${options.reason ?? "none"}`,
        `Code: ${options.code}`,
        `Recover: ${options.recover === undefined ? "none" : WebSocketShardDestroyRecovery[options.recover]}`
      ]);
      this.isAck = true;
      if (this.heartbeatInterval) {
        (0, import_node_timers.clearInterval)(this.heartbeatInterval);
      }
      if (this.initialHeartbeatTimeoutController) {
        this.initialHeartbeatTimeoutController.abort();
        this.initialHeartbeatTimeoutController = null;
      }
      this.lastHeartbeatAt = -1;
      for (const controller of this.timeoutAbortControllers.values()) {
        controller.abort();
      }
      this.timeoutAbortControllers.clear();
      this.failedToConnectDueToNetworkError = false;
      if (options.recover !== 1) {
        await this.strategy.updateSessionInfo(this.id, null);
      }
      if (this.connection) {
        this.connection.onmessage = null;
        this.connection.onclose = null;
        const shouldClose = this.connection.readyState === import_ws.WebSocket.OPEN;
        this.debug([
          "Connection status during destroy",
          `Needs closing: ${shouldClose}`,
          `Ready state: ${this.connection.readyState}`
        ]);
        if (shouldClose) {
          let outerResolve;
          const promise = new Promise((resolve2) => {
            outerResolve = resolve2;
          });
          this.connection.onclose = outerResolve;
          this.connection.close(options.code, options.reason);
          await promise;
          this.emit("closed", { code: options.code });
        }
        this.connection.onerror = null;
      } else {
        this.debug(["Destroying a shard that has no connection; please open an issue on GitHub"]);
      }
      this.#status = 0;
      if (options.recover !== undefined) {
        await (0, import_promises2.setTimeout)(500);
        return this.internalConnect();
      }
    }
    async waitForEvent(event, timeoutDuration) {
      this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
      const timeoutController = new AbortController;
      const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;
      this.timeoutAbortControllers.set(event, timeoutController);
      const closeController = new AbortController;
      try {
        const closed = await Promise.race([
          (0, import_node_events2.once)(this, event, { signal: timeoutController.signal }).then(() => false),
          (0, import_node_events2.once)(this, "closed", { signal: closeController.signal }).then(() => true)
        ]);
        return { ok: !closed };
      } catch {
        this.destroy({
          code: 1000,
          reason: "Something timed out or went wrong while waiting for an event",
          recover: 0
        });
        return { ok: false };
      } finally {
        if (timeout) {
          (0, import_node_timers.clearTimeout)(timeout);
        }
        this.timeoutAbortControllers.delete(event);
        if (!closeController.signal.aborted) {
          closeController.abort();
        }
      }
    }
    async send(payload) {
      if (!this.connection) {
        throw new Error("WebSocketShard wasn't connected");
      }
      if (ImportantGatewayOpcodes.has(payload.op)) {
        this.connection.send(JSON.stringify(payload));
        return;
      }
      if (this.#status !== 3 && !ImportantGatewayOpcodes.has(payload.op)) {
        this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
        try {
          await (0, import_node_events2.once)(this, "ready");
        } catch {
          return this.send(payload);
        }
      }
      await this.sendQueue.wait();
      const now = Date.now();
      if (now >= this.sendRateLimitState.resetAt) {
        this.sendRateLimitState = getInitialSendRateLimitState();
      }
      if (this.sendRateLimitState.sent + 1 >= 115) {
        const sleepFor = this.sendRateLimitState.resetAt - now + Math.random() * 1500;
        this.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);
        const controller = new AbortController;
        const interrupted = await Promise.race([
          (0, import_promises2.setTimeout)(sleepFor).then(() => false),
          (0, import_node_events2.once)(this, "closed", { signal: controller.signal }).then(() => true)
        ]);
        if (interrupted) {
          this.debug(["Connection closed while waiting for the send rate limit to reset, re-queueing payload"]);
          this.sendQueue.shift();
          return this.send(payload);
        }
        controller.abort();
      }
      this.sendRateLimitState.sent++;
      this.sendQueue.shift();
      this.connection.send(JSON.stringify(payload));
    }
    async identify() {
      this.debug(["Waiting for identify throttle"]);
      const controller = new AbortController;
      const closeHandler = /* @__PURE__ */ __name(() => {
        controller.abort();
      }, "closeHandler");
      this.on("closed", closeHandler);
      try {
        await this.strategy.waitForIdentify(this.id, controller.signal);
      } catch {
        if (controller.signal.aborted) {
          this.debug(["Was waiting for an identify, but the shard closed in the meantime"]);
          return;
        }
        this.debug([
          "IContextFetchingStrategy#waitForIdentify threw an unknown error.",
          "If you're using a custom strategy, this is probably nothing to worry about.",
          "If you're not, please open an issue on GitHub."
        ]);
        await this.destroy({
          reason: "Identify throttling logic failed",
          recover: 1
        });
      } finally {
        this.off("closed", closeHandler);
      }
      this.debug([
        "Identifying",
        `shard id: ${this.id.toString()}`,
        `shard count: ${this.strategy.options.shardCount}`,
        `intents: ${this.strategy.options.intents}`,
        `compression: ${this.inflate ? "zlib-stream" : this.useIdentifyCompress ? "identify" : "none"}`
      ]);
      const d = {
        token: this.strategy.options.token,
        properties: this.strategy.options.identifyProperties,
        intents: this.strategy.options.intents,
        compress: this.useIdentifyCompress,
        shard: [this.id, this.strategy.options.shardCount]
      };
      if (this.strategy.options.largeThreshold) {
        d.large_threshold = this.strategy.options.largeThreshold;
      }
      if (this.strategy.options.initialPresence) {
        d.presence = this.strategy.options.initialPresence;
      }
      await this.send({
        op: import_v102.GatewayOpcodes.Identify,
        d
      });
      await this.waitForEvent("ready", this.strategy.options.readyTimeout);
    }
    async resume(session) {
      this.debug([
        "Resuming session",
        `resume url: ${session.resumeURL}`,
        `sequence: ${session.sequence}`,
        `shard id: ${this.id.toString()}`
      ]);
      this.#status = 2;
      this.replayedEvents = 0;
      return this.send({
        op: import_v102.GatewayOpcodes.Resume,
        d: {
          token: this.strategy.options.token,
          seq: session.sequence,
          session_id: session.sessionId
        }
      });
    }
    async heartbeat(requested = false) {
      if (!this.isAck && !requested) {
        return this.destroy({ reason: "Zombie connection", recover: 1 });
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      await this.send({
        op: import_v102.GatewayOpcodes.Heartbeat,
        d: session?.sequence ?? null
      });
      this.lastHeartbeatAt = Date.now();
      this.isAck = false;
    }
    async unpackMessage(data, isBinary) {
      if (!isBinary) {
        try {
          return JSON.parse(data);
        } catch {
          return null;
        }
      }
      const decompressable = new Uint8Array(data);
      if (this.useIdentifyCompress) {
        return new Promise((resolve2, reject) => {
          (0, import_node_zlib.inflate)(decompressable, { chunkSize: 65535 }, (err, result) => {
            if (err) {
              reject(err);
              return;
            }
            resolve2(JSON.parse(this.textDecoder.decode(result)));
          });
        });
      }
      if (this.inflate) {
        const l = decompressable.length;
        const flush = l >= 4 && decompressable[l - 4] === 0 && decompressable[l - 3] === 0 && decompressable[l - 2] === 255 && decompressable[l - 1] === 255;
        const zlib = await getZlibSync();
        this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
        if (this.inflate.err) {
          this.emit("error", {
            error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
          });
        }
        if (!flush) {
          return null;
        }
        const { result } = this.inflate;
        if (!result) {
          return null;
        }
        return JSON.parse(typeof result === "string" ? result : this.textDecoder.decode(result));
      }
      this.debug([
        "Received a message we were unable to decompress",
        `isBinary: ${isBinary.toString()}`,
        `useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,
        `inflate: ${Boolean(this.inflate).toString()}`
      ]);
      return null;
    }
    async onMessage(data, isBinary) {
      const payload = await this.unpackMessage(data, isBinary);
      if (!payload) {
        return;
      }
      switch (payload.op) {
        case import_v102.GatewayOpcodes.Dispatch: {
          if (this.#status === 2) {
            this.replayedEvents++;
          }
          switch (payload.t) {
            case import_v102.GatewayDispatchEvents.Ready: {
              this.#status = 3;
              const session2 = {
                sequence: payload.s,
                sessionId: payload.d.session_id,
                shardId: this.id,
                shardCount: this.strategy.options.shardCount,
                resumeURL: payload.d.resume_gateway_url
              };
              await this.strategy.updateSessionInfo(this.id, session2);
              this.emit("ready", { data: payload.d });
              break;
            }
            case import_v102.GatewayDispatchEvents.Resumed: {
              this.#status = 3;
              this.debug([`Resumed and replayed ${this.replayedEvents} events`]);
              this.emit("resumed");
              break;
            }
            default: {
              break;
            }
          }
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (session) {
            if (payload.s > session.sequence) {
              await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
            }
          } else {
            this.debug([
              `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
            ]);
          }
          this.emit("dispatch", { data: payload });
          break;
        }
        case import_v102.GatewayOpcodes.Heartbeat: {
          await this.heartbeat(true);
          break;
        }
        case import_v102.GatewayOpcodes.Reconnect: {
          await this.destroy({
            reason: "Told to reconnect by Discord",
            recover: 1
          });
          break;
        }
        case import_v102.GatewayOpcodes.InvalidSession: {
          this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (payload.d && session) {
            await this.resume(session);
          } else {
            await this.destroy({
              reason: "Invalid session",
              recover: 0
            });
          }
          break;
        }
        case import_v102.GatewayOpcodes.Hello: {
          this.emit("hello");
          const jitter = Math.random();
          const firstWait = Math.floor(payload.d.heartbeat_interval * jitter);
          this.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);
          try {
            const controller = new AbortController;
            this.initialHeartbeatTimeoutController = controller;
            await (0, import_promises2.setTimeout)(firstWait, undefined, { signal: controller.signal });
          } catch {
            this.debug(["Cancelled initial heartbeat due to #destroy being called"]);
            return;
          } finally {
            this.initialHeartbeatTimeoutController = null;
          }
          await this.heartbeat();
          this.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);
          this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
          break;
        }
        case import_v102.GatewayOpcodes.HeartbeatAck: {
          this.isAck = true;
          const ackAt = Date.now();
          this.emit("heartbeat", {
            ackAt,
            heartbeatAt: this.lastHeartbeatAt,
            latency: ackAt - this.lastHeartbeatAt
          });
          break;
        }
      }
    }
    onError(error) {
      if ("code" in error && KnownNetworkErrorCodes.has(error.code)) {
        this.debug(["Failed to connect to the gateway URL specified due to a network error"]);
        this.failedToConnectDueToNetworkError = true;
        return;
      }
      this.emit("error", { error });
    }
    async onClose(code) {
      this.emit("closed", { code });
      switch (code) {
        case 1000: {
          return this.destroy({
            code,
            reason: "Got disconnected by Discord",
            recover: 0
          });
        }
        case 4200: {
          break;
        }
        case import_v102.GatewayCloseCodes.UnknownError: {
          this.debug([`An unknown error occurred: ${code}`]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.UnknownOpcode: {
          this.debug(["An invalid opcode was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.DecodeError: {
          this.debug(["An invalid payload was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.NotAuthenticated: {
          this.debug(["A request was somehow sent before the identify/resume payload."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.AuthenticationFailed: {
          this.emit("error", {
            error: new Error("Authentication failed")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.AlreadyAuthenticated: {
          this.debug(["More than one auth payload was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.InvalidSeq: {
          this.debug(["An invalid sequence was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.RateLimited: {
          this.debug(["The WebSocket rate limit has been hit, this should never happen"]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.SessionTimedOut: {
          this.debug(["Session timed out."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.InvalidShard: {
          this.emit("error", {
            error: new Error("Invalid shard")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.ShardingRequired: {
          this.emit("error", {
            error: new Error("Sharding is required")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidAPIVersion: {
          this.emit("error", {
            error: new Error("Used an invalid API version")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidIntents: {
          this.emit("error", {
            error: new Error("Used invalid intents")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.DisallowedIntents: {
          this.emit("error", {
            error: new Error("Used disallowed intents")
          });
          return this.destroy({ code });
        }
        default: {
          this.debug([
            `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
          ]);
          return this.destroy({
            code,
            recover: this.failedToConnectDueToNetworkError ? 0 : 1
          });
        }
      }
    }
    debug(messages) {
      this.emit("debug", { message: messages.join(`
	`) });
    }
  };
  var SimpleShardingStrategy = class {
    static {
      __name(this, "SimpleShardingStrategy");
    }
    manager;
    shards = new import_collection6.Collection;
    constructor(manager) {
      this.manager = manager;
    }
    async spawn(shardIds) {
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      for (const shardId of shardIds) {
        const strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);
        const shard = new WebSocketShard(strategy, shardId);
        for (const event of Object.values(WebSocketShardEvents)) {
          shard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));
        }
        this.shards.set(shardId, shard);
      }
    }
    async connect() {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.connect());
      }
      await Promise.all(promises);
    }
    async destroy(options) {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.destroy(options));
      }
      await Promise.all(promises);
      this.shards.clear();
    }
    async send(shardId, payload) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} not found`);
      }
      return shard.send(payload);
    }
    async fetchStatus() {
      return this.shards.mapValues((shard) => shard.status);
    }
  };
  var import_node_worker_threads3 = __require("worker_threads");
  var import_collection7 = require_dist9();
  var WorkerBootstrapper = class {
    static {
      __name(this, "WorkerBootstrapper");
    }
    data = import_node_worker_threads3.workerData;
    shards = new import_collection7.Collection;
    constructor() {
      if (import_node_worker_threads3.isMainThread) {
        throw new Error("Expected WorkerBootstrap to not be used within the main thread");
      }
    }
    async connect(shardId) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.connect();
    }
    async destroy(shardId, options) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.destroy(options);
    }
    setupThreadEvents() {
      import_node_worker_threads3.parentPort.on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => {
        switch (payload.op) {
          case 0: {
            await this.connect(payload.shardId);
            const response = {
              op: 0,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 1: {
            await this.destroy(payload.shardId, payload.options);
            const response = {
              op: 1,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 2: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new RangeError(`Shard ${payload.shardId} does not exist`);
            }
            await shard.send(payload.payload);
            break;
          }
          case 3: {
            break;
          }
          case 4: {
            break;
          }
          case 5: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new Error(`Shard ${payload.shardId} does not exist`);
            }
            const response = {
              op: 6,
              status: shard.status,
              nonce: payload.nonce
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
        }
      });
    }
    async bootstrap(options = {}) {
      for (const shardId of this.data.shardIds) {
        const shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);
        for (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {
          shard.on(event, (data) => {
            const payload = {
              op: 2,
              event,
              data,
              shardId
            };
            import_node_worker_threads3.parentPort.postMessage(payload);
          });
        }
        await options.shardCallback?.(shard);
        this.shards.set(shardId, shard);
      }
      this.setupThreadEvents();
      const message = {
        op: 7
      };
      import_node_worker_threads3.parentPort.postMessage(message);
    }
  };
  var import_util3 = require_dist();
  var import_util4 = require_dist();
  var import_async_event_emitter2 = require_dist3();
  var import_v103 = require_v106();
  (0, import_util4.polyfillDispose)();
  var WebSocketManager = class extends import_async_event_emitter2.AsyncEventEmitter {
    static {
      __name(this, "WebSocketManager");
    }
    options;
    gatewayInformation = null;
    shardIds = null;
    strategy;
    constructor(options) {
      super();
      this.options = { ...DefaultWebSocketManagerOptions, ...options };
      this.strategy = this.options.buildStrategy(this);
    }
    async fetchGatewayInformation(force = false) {
      if (this.gatewayInformation) {
        if (this.gatewayInformation.expiresAt <= Date.now()) {
          this.gatewayInformation = null;
        } else if (!force) {
          return this.gatewayInformation.data;
        }
      }
      const data = await this.options.rest.get(import_v103.Routes.gatewayBot());
      this.gatewayInformation = { data, expiresAt: Date.now() + (data.session_start_limit.reset_after || 5000) };
      return this.gatewayInformation.data;
    }
    async updateShardCount(shardCount) {
      await this.strategy.destroy({ reason: "User is adjusting their shards" });
      this.options.shardCount = shardCount;
      const shardIds = await this.getShardIds(true);
      await this.strategy.spawn(shardIds);
      return this;
    }
    async getShardCount() {
      if (this.options.shardCount) {
        return this.options.shardCount;
      }
      const shardIds = await this.getShardIds();
      return Math.max(...shardIds) + 1;
    }
    async getShardIds(force = false) {
      if (this.shardIds && !force) {
        return this.shardIds;
      }
      let shardIds;
      if (this.options.shardIds) {
        if (Array.isArray(this.options.shardIds)) {
          shardIds = this.options.shardIds;
        } else {
          const { start, end } = this.options.shardIds;
          shardIds = [...(0, import_util3.range)({ start, end: end + 1 })];
        }
      } else {
        const data = await this.fetchGatewayInformation();
        shardIds = [...(0, import_util3.range)(this.options.shardCount ?? data.shards)];
      }
      this.shardIds = shardIds;
      return shardIds;
    }
    async connect() {
      const shardCount = await this.getShardCount();
      await this.updateShardCount(shardCount);
      const shardIds = await this.getShardIds();
      const data = await this.fetchGatewayInformation();
      if (data.session_start_limit.remaining < shardIds.length) {
        throw new Error(`Not enough sessions remaining to spawn ${shardIds.length} shards; only ${data.session_start_limit.remaining} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`);
      }
      await this.strategy.connect();
    }
    destroy(options) {
      return this.strategy.destroy(options);
    }
    send(shardId, payload) {
      return this.strategy.send(shardId, payload);
    }
    fetchStatus() {
      return this.strategy.fetchStatus();
    }
    async[Symbol.asyncDispose]() {
      await this.destroy();
    }
  };
  var version = "1.2.3";
});

// ../../node_modules/discord.js/src/util/WebSocketShardEvents.js
var require_WebSocketShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Close: "close",
    Destroyed: "destroyed",
    InvalidSession: "invalidSession",
    Ready: "ready",
    Resumed: "resumed",
    AllReady: "allReady"
  };
});

// ../../node_modules/discord.js/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var process2 = __require("process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("timers");
  var { GatewayIntentBits } = require_v106();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var deprecationEmittedForImportant = false;

  class WebSocketShard extends EventEmitter {
    constructor(manager, id) {
      super();
      this.manager = manager;
      this.id = id;
      this.status = Status.Idle;
      this.closeSequence = 0;
      this.ping = -1;
      this.lastPingTimestamp = -1;
      Object.defineProperty(this, "expectedGuilds", { value: null, writable: true });
      Object.defineProperty(this, "readyTimeout", { value: null, writable: true });
      Object.defineProperty(this, "sessionInfo", { value: null, writable: true });
    }
    debug(messages) {
      this.manager.debug(messages, this.id);
    }
    emitClose(event = {
      code: 1011,
      reason: "INTERNAL_ERROR",
      wasClean: false
    }) {
      this.debug([
        "[CLOSE]",
        `Event Code: ${event.code}`,
        `Clean     : ${event.wasClean}`,
        `Reason    : ${event.reason ?? "No reason received"}`
      ]);
      this.emit(WebSocketShardEvents.Close, event);
    }
    onReadyPacket(packet) {
      if (!packet) {
        this.debug([`Received broken packet: '${packet}'.`]);
        return;
      }
      this.emit(WebSocketShardEvents.Ready);
      this.expectedGuilds = new Set(packet.guilds.map((guild) => guild.id));
      this.status = Status.WaitingForGuilds;
    }
    gotGuild(guildId) {
      this.expectedGuilds.delete(guildId);
      this.checkReady();
    }
    checkReady() {
      if (this.readyTimeout) {
        clearTimeout2(this.readyTimeout);
        this.readyTimeout = null;
      }
      if (!this.expectedGuilds.size) {
        this.debug(["Shard received all its guilds. Marking as fully ready."]);
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady);
        return;
      }
      const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);
      const { waitGuildTimeout } = this.manager.client.options;
      this.readyTimeout = setTimeout2(() => {
        this.debug([
          hasGuildsIntent ? `Shard did not receive any guild packets in ${waitGuildTimeout} ms.` : "Shard will not receive anymore guild packets.",
          `Unavailable guild count: ${this.expectedGuilds.size}`
        ]);
        this.readyTimeout = null;
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);
      }, hasGuildsIntent ? waitGuildTimeout : 0).unref();
    }
    send(data, important = false) {
      if (important && !deprecationEmittedForImportant) {
        process2.emitWarning("Sending important payloads explicitly is deprecated. They are determined by their opcode implicitly now.", "DeprecationWarning");
        deprecationEmittedForImportant = true;
      }
      this.manager._ws.send(this.id, data);
    }
  }
  module.exports = WebSocketShard;
});

// ../../node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js
var require_APPLICATION_COMMAND_PERMISSIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ApplicationCommandPermissionsUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js
var require_AUTO_MODERATION_ACTION_EXECUTION = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationActionExecution.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js
var require_AUTO_MODERATION_RULE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js
var require_AUTO_MODERATION_RULE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js
var require_AUTO_MODERATION_RULE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js
var require_CHANNEL_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js
var require_CHANNEL_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js
var require_CHANNEL_PINS_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const channel = client.channels.cache.get(data.channel_id);
    const time = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
    if (channel) {
      channel.lastPinTimestamp = time;
      client.emit(Events.ChannelPinsUpdate, channel, time);
    }
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js
var require_CHANNEL_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ChannelUpdate, old, updated);
    }
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/ENTITLEMENT_CREATE.js
var require_ENTITLEMENT_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.EntitlementCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/ENTITLEMENT_DELETE.js
var require_ENTITLEMENT_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.EntitlementDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/ENTITLEMENT_UPDATE.js
var require_ENTITLEMENT_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.EntitlementUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js
var require_GUILD_AUDIT_LOG_ENTRY_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildAuditLogEntryCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js
var require_GUILD_BAN_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanAdd.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js
var require_GUILD_BAN_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanRemove.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js
var require_GUILD_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    let guild = client.guilds.cache.get(data.id);
    if (guild) {
      if (!guild.available && !data.unavailable) {
        guild._patch(data);
        client.emit(Events.GuildAvailable, guild);
      }
    } else {
      data.shardId = shard.id;
      guild = client.guilds._add(data);
      if (client.ws.status === Status.Ready) {
        client.emit(Events.GuildCreate, guild);
      }
    }
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js
var require_GUILD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js
var require_GUILD_EMOJIS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildEmojisUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js
var require_GUILD_INTEGRATIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildIntegrationsUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js
var require_GUILD_MEMBERS_CHUNK = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const members = new Collection;
    for (const member of data.members)
      members.set(member.user.id, guild.members._add(member));
    if (data.presences) {
      for (const presence of data.presences)
        guild.presences._add(Object.assign(presence, { guild }));
    }
    client.emit(Events.GuildMembersChunk, members, guild, {
      index: data.chunk_index,
      count: data.chunk_count,
      notFound: data.not_found,
      nonce: data.nonce
    });
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js
var require_GUILD_MEMBER_ADD = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (guild) {
      guild.memberCount++;
      const member = guild.members._add(data);
      if (shard.status === Status.Ready) {
        client.emit(Events.GuildMemberAdd, member);
      }
    }
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js
var require_GUILD_MEMBER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberRemove.handle(packet.d, shard);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js
var require_GUILD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberUpdate.handle(packet.d, shard);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js
var require_GUILD_ROLE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js
var require_GUILD_ROLE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js
var require_GUILD_ROLE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js
var require_GUILD_SCHEDULED_EVENT_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js
var require_GUILD_SCHEDULED_EVENT_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js
var require_GUILD_SCHEDULED_EVENT_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js
var require_GUILD_SCHEDULED_EVENT_USER_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserAdd.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js
var require_GUILD_SCHEDULED_EVENT_USER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserRemove.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUNDS_UPDATE.js
var require_GUILD_SOUNDBOARD_SOUNDS_UPDATE = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const soundboardSounds = new Collection;
    for (const soundboardSound of data.soundboard_sounds) {
      soundboardSounds.set(soundboardSound.sound_id, guild.soundboardSounds._add(soundboardSound));
    }
    client.emit(Events.GuildSoundboardSoundsUpdate, soundboardSounds, guild);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUND_CREATE.js
var require_GUILD_SOUNDBOARD_SOUND_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const soundboardSound = guild.soundboardSounds._add(data);
    client.emit(Events.GuildSoundboardSoundCreate, soundboardSound);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUND_DELETE.js
var require_GUILD_SOUNDBOARD_SOUND_DELETE = __commonJS((exports, module) => {
  module.exports = (client, { d: data }) => {
    client.actions.GuildSoundboardSoundDelete.handle(data);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SOUNDBOARD_SOUND_UPDATE.js
var require_GUILD_SOUNDBOARD_SOUND_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const oldGuildSoundboardSound = guild.soundboardSounds.cache.get(data.sound_id)?._clone() ?? null;
    const newGuildSoundboardSound = guild.soundboardSounds._add(data);
    client.emit(Events.GuildSoundboardSoundUpdate, oldGuildSoundboardSound, newGuildSoundboardSound);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js
var require_GUILD_STICKERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildStickersUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js
var require_GUILD_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js
var require_INTERACTION_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InteractionCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js
var require_INVITE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js
var require_INVITE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js
var require_MESSAGE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js
var require_MESSAGE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js
var require_MESSAGE_DELETE_BULK = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDeleteBulk.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_POLL_VOTE_ADD.js
var require_MESSAGE_POLL_VOTE_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessagePollVoteAdd.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_POLL_VOTE_REMOVE.js
var require_MESSAGE_POLL_VOTE_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessagePollVoteRemove.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js
var require_MESSAGE_REACTION_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionAdd.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js
var require_MESSAGE_REACTION_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemove.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js
var require_MESSAGE_REACTION_REMOVE_ALL = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveAll.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js
var require_MESSAGE_REACTION_REMOVE_EMOJI = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveEmoji.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js
var require_MESSAGE_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.MessageUpdate, old, updated);
    }
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js
var require_PRESENCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.PresenceUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var User = require_User();
  var { resolveImage } = require_DataResolver();

  class ClientUser extends User {
    _patch(data) {
      super._patch(data);
      if ("verified" in data) {
        this.verified = data.verified;
      }
      if ("mfa_enabled" in data) {
        this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
      } else {
        this.mfaEnabled ??= null;
      }
      if ("token" in data)
        this.client.token = data.token;
    }
    get presence() {
      return this.client.presence;
    }
    async edit({ username, avatar, banner }) {
      const data = await this.client.rest.patch(Routes.user(), {
        body: {
          username,
          avatar: avatar && await resolveImage(avatar),
          banner: banner && await resolveImage(banner)
        }
      });
      const { updated } = this.client.actions.UserUpdate.handle(data);
      return updated ?? this;
    }
    setUsername(username) {
      return this.edit({ username });
    }
    setAvatar(avatar) {
      return this.edit({ avatar });
    }
    setBanner(banner) {
      return this.edit({ banner });
    }
    setPresence(data) {
      return this.client.presence.set(data);
    }
    setStatus(status, shardId) {
      return this.setPresence({ status, shardId });
    }
    setActivity(name, options = {}) {
      if (!name)
        return this.setPresence({ activities: [], shardId: options.shardId });
      const activity = Object.assign({}, options, typeof name === "object" ? name : { name });
      return this.setPresence({ activities: [activity], shardId: activity.shardId });
    }
    setAFK(afk = true, shardId) {
      return this.setPresence({ afk, shardId });
    }
  }
  module.exports = ClientUser;
});

// ../../node_modules/discord.js/src/client/websocket/handlers/READY.js
var require_READY = __commonJS((exports, module) => {
  var ClientApplication = require_ClientApplication();
  var ClientUser;
  module.exports = (client, { d: data }, shard) => {
    if (client.user) {
      client.user._patch(data.user);
    } else {
      ClientUser ??= require_ClientUser();
      client.user = new ClientUser(client, data.user);
      client.users.cache.set(client.user.id, client.user);
    }
    for (const guild of data.guilds) {
      guild.shardId = shard.id;
      client.guilds._add(guild);
    }
    if (client.application) {
      client.application._patch(data.application);
    } else {
      client.application = new ClientApplication(client, data.application);
    }
    shard.checkReady();
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/RESUMED.js
var require_RESUMED = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet, shard) => {
    const replayed = shard.sessionInfo.sequence - shard.closeSequence;
    client.emit(Events.ShardResume, shard.id, replayed);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/SOUNDBOARD_SOUNDS.js
var require_SOUNDBOARD_SOUNDS = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const soundboardSounds = new Collection;
    for (const soundboardSound of data.soundboard_sounds) {
      soundboardSounds.set(soundboardSound.sound_id, guild.soundboardSounds._add(soundboardSound));
    }
    client.emit(Events.SoundboardSounds, soundboardSounds, guild);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js
var require_STAGE_INSTANCE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js
var require_STAGE_INSTANCE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js
var require_STAGE_INSTANCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/SUBSCRIPTION_CREATE.js
var require_SUBSCRIPTION_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const subscription = client.application.subscriptions._add(data);
    client.emit(Events.SubscriptionCreate, subscription);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/SUBSCRIPTION_DELETE.js
var require_SUBSCRIPTION_DELETE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const subscription = client.application.subscriptions._add(data, false);
    client.application.subscriptions.cache.delete(subscription.id);
    client.emit(Events.SubscriptionDelete, subscription);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/SUBSCRIPTION_UPDATE.js
var require_SUBSCRIPTION_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const oldSubscription = client.application.subscriptions.cache.get(data.id)?._clone() ?? null;
    const newSubscription = client.application.subscriptions._add(data);
    client.emit(Events.SubscriptionUpdate, oldSubscription, newSubscription);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js
var require_THREAD_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadCreate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js
var require_THREAD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadDelete.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js
var require_THREAD_LIST_SYNC = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadListSync.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js
var require_THREAD_MEMBERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMembersUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js
var require_THREAD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMemberUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js
var require_THREAD_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ThreadUpdate, old, updated);
    }
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js
var require_TYPING_START = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.TypingStart.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js
var require_USER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.UserUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/structures/VoiceChannelEffect.js
var require_VoiceChannelEffect = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class VoiceChannelEffect {
    constructor(data, guild) {
      this.guild = guild;
      this.channelId = data.channel_id;
      this.userId = data.user_id;
      this.emoji = data.emoji ? new Emoji(guild.client, data.emoji) : null;
      this.animationType = data.animation_type ?? null;
      this.animationId = data.animation_id ?? null;
      this.soundId = data.sound_id ?? null;
      this.soundVolume = data.sound_volume ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get soundboardSound() {
      return this.guild.soundboardSounds.cache.get(this.soundId) ?? null;
    }
  }
  module.exports = VoiceChannelEffect;
});

// ../../node_modules/discord.js/src/client/websocket/handlers/VOICE_CHANNEL_EFFECT_SEND.js
var require_VOICE_CHANNEL_EFFECT_SEND = __commonJS((exports, module) => {
  var VoiceChannelEffect = require_VoiceChannelEffect();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    client.emit(Events.VoiceChannelEffectSend, new VoiceChannelEffect(data, guild));
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js
var require_VOICE_SERVER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.emit("debug", `[VOICE] received voice server: ${JSON.stringify(packet)}`);
    client.voice.onVoiceServer(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js
var require_VOICE_STATE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.VoiceStateUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js
var require_WEBHOOKS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.WebhooksUpdate.handle(packet.d);
  };
});

// ../../node_modules/discord.js/src/client/websocket/handlers/index.js
var require_handlers = __commonJS((exports, module) => {
  var handlers = Object.fromEntries([
    ["APPLICATION_COMMAND_PERMISSIONS_UPDATE", require_APPLICATION_COMMAND_PERMISSIONS_UPDATE()],
    ["AUTO_MODERATION_ACTION_EXECUTION", require_AUTO_MODERATION_ACTION_EXECUTION()],
    ["AUTO_MODERATION_RULE_CREATE", require_AUTO_MODERATION_RULE_CREATE()],
    ["AUTO_MODERATION_RULE_DELETE", require_AUTO_MODERATION_RULE_DELETE()],
    ["AUTO_MODERATION_RULE_UPDATE", require_AUTO_MODERATION_RULE_UPDATE()],
    ["CHANNEL_CREATE", require_CHANNEL_CREATE()],
    ["CHANNEL_DELETE", require_CHANNEL_DELETE()],
    ["CHANNEL_PINS_UPDATE", require_CHANNEL_PINS_UPDATE()],
    ["CHANNEL_UPDATE", require_CHANNEL_UPDATE()],
    ["ENTITLEMENT_CREATE", require_ENTITLEMENT_CREATE()],
    ["ENTITLEMENT_DELETE", require_ENTITLEMENT_DELETE()],
    ["ENTITLEMENT_UPDATE", require_ENTITLEMENT_UPDATE()],
    ["GUILD_AUDIT_LOG_ENTRY_CREATE", require_GUILD_AUDIT_LOG_ENTRY_CREATE()],
    ["GUILD_BAN_ADD", require_GUILD_BAN_ADD()],
    ["GUILD_BAN_REMOVE", require_GUILD_BAN_REMOVE()],
    ["GUILD_CREATE", require_GUILD_CREATE()],
    ["GUILD_DELETE", require_GUILD_DELETE()],
    ["GUILD_EMOJIS_UPDATE", require_GUILD_EMOJIS_UPDATE()],
    ["GUILD_INTEGRATIONS_UPDATE", require_GUILD_INTEGRATIONS_UPDATE()],
    ["GUILD_MEMBERS_CHUNK", require_GUILD_MEMBERS_CHUNK()],
    ["GUILD_MEMBER_ADD", require_GUILD_MEMBER_ADD()],
    ["GUILD_MEMBER_REMOVE", require_GUILD_MEMBER_REMOVE()],
    ["GUILD_MEMBER_UPDATE", require_GUILD_MEMBER_UPDATE()],
    ["GUILD_ROLE_CREATE", require_GUILD_ROLE_CREATE()],
    ["GUILD_ROLE_DELETE", require_GUILD_ROLE_DELETE()],
    ["GUILD_ROLE_UPDATE", require_GUILD_ROLE_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_CREATE", require_GUILD_SCHEDULED_EVENT_CREATE()],
    ["GUILD_SCHEDULED_EVENT_DELETE", require_GUILD_SCHEDULED_EVENT_DELETE()],
    ["GUILD_SCHEDULED_EVENT_UPDATE", require_GUILD_SCHEDULED_EVENT_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_USER_ADD", require_GUILD_SCHEDULED_EVENT_USER_ADD()],
    ["GUILD_SCHEDULED_EVENT_USER_REMOVE", require_GUILD_SCHEDULED_EVENT_USER_REMOVE()],
    ["GUILD_SOUNDBOARD_SOUNDS_UPDATE", require_GUILD_SOUNDBOARD_SOUNDS_UPDATE()],
    ["GUILD_SOUNDBOARD_SOUND_CREATE", require_GUILD_SOUNDBOARD_SOUND_CREATE()],
    ["GUILD_SOUNDBOARD_SOUND_DELETE", require_GUILD_SOUNDBOARD_SOUND_DELETE()],
    ["GUILD_SOUNDBOARD_SOUND_UPDATE", require_GUILD_SOUNDBOARD_SOUND_UPDATE()],
    ["GUILD_STICKERS_UPDATE", require_GUILD_STICKERS_UPDATE()],
    ["GUILD_UPDATE", require_GUILD_UPDATE()],
    ["INTERACTION_CREATE", require_INTERACTION_CREATE()],
    ["INVITE_CREATE", require_INVITE_CREATE()],
    ["INVITE_DELETE", require_INVITE_DELETE()],
    ["MESSAGE_CREATE", require_MESSAGE_CREATE()],
    ["MESSAGE_DELETE", require_MESSAGE_DELETE()],
    ["MESSAGE_DELETE_BULK", require_MESSAGE_DELETE_BULK()],
    ["MESSAGE_POLL_VOTE_ADD", require_MESSAGE_POLL_VOTE_ADD()],
    ["MESSAGE_POLL_VOTE_REMOVE", require_MESSAGE_POLL_VOTE_REMOVE()],
    ["MESSAGE_REACTION_ADD", require_MESSAGE_REACTION_ADD()],
    ["MESSAGE_REACTION_REMOVE", require_MESSAGE_REACTION_REMOVE()],
    ["MESSAGE_REACTION_REMOVE_ALL", require_MESSAGE_REACTION_REMOVE_ALL()],
    ["MESSAGE_REACTION_REMOVE_EMOJI", require_MESSAGE_REACTION_REMOVE_EMOJI()],
    ["MESSAGE_UPDATE", require_MESSAGE_UPDATE()],
    ["PRESENCE_UPDATE", require_PRESENCE_UPDATE()],
    ["READY", require_READY()],
    ["RESUMED", require_RESUMED()],
    ["SOUNDBOARD_SOUNDS", require_SOUNDBOARD_SOUNDS()],
    ["STAGE_INSTANCE_CREATE", require_STAGE_INSTANCE_CREATE()],
    ["STAGE_INSTANCE_DELETE", require_STAGE_INSTANCE_DELETE()],
    ["STAGE_INSTANCE_UPDATE", require_STAGE_INSTANCE_UPDATE()],
    ["SUBSCRIPTION_CREATE", require_SUBSCRIPTION_CREATE()],
    ["SUBSCRIPTION_DELETE", require_SUBSCRIPTION_DELETE()],
    ["SUBSCRIPTION_UPDATE", require_SUBSCRIPTION_UPDATE()],
    ["THREAD_CREATE", require_THREAD_CREATE()],
    ["THREAD_DELETE", require_THREAD_DELETE()],
    ["THREAD_LIST_SYNC", require_THREAD_LIST_SYNC()],
    ["THREAD_MEMBERS_UPDATE", require_THREAD_MEMBERS_UPDATE()],
    ["THREAD_MEMBER_UPDATE", require_THREAD_MEMBER_UPDATE()],
    ["THREAD_UPDATE", require_THREAD_UPDATE()],
    ["TYPING_START", require_TYPING_START()],
    ["USER_UPDATE", require_USER_UPDATE()],
    ["VOICE_CHANNEL_EFFECT_SEND", require_VOICE_CHANNEL_EFFECT_SEND()],
    ["VOICE_SERVER_UPDATE", require_VOICE_SERVER_UPDATE()],
    ["VOICE_STATE_UPDATE", require_VOICE_STATE_UPDATE()],
    ["WEBHOOKS_UPDATE", require_WEBHOOKS_UPDATE()]
  ]);
  module.exports = handlers;
});

// ../../node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var process2 = __require("process");
  var { setImmediate: setImmediate2 } = __require("timers");
  var { Collection } = require_dist6();
  var {
    WebSocketManager: WSWebSocketManager,
    WebSocketShardEvents: WSWebSocketShardEvents,
    CompressionMethod,
    CloseCodes
  } = require_dist10();
  var { GatewayCloseCodes, GatewayDispatchEvents } = require_v106();
  var WebSocketShard = require_WebSocketShard();
  var PacketHandlers = require_handlers();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var Events = require_Events();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var zlib;
  var deprecationEmitted = false;
  try {
    zlib = (()=>{throw new Error("Cannot require module "+"zlib-sync");})();
  } catch {}
  var BeforeReadyWhitelist = [
    GatewayDispatchEvents.Ready,
    GatewayDispatchEvents.Resumed,
    GatewayDispatchEvents.GuildCreate,
    GatewayDispatchEvents.GuildDelete,
    GatewayDispatchEvents.GuildMembersChunk,
    GatewayDispatchEvents.GuildMemberAdd,
    GatewayDispatchEvents.GuildMemberRemove
  ];
  var WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];
  var UNRECOVERABLE_CLOSE_CODES = [
    GatewayCloseCodes.AuthenticationFailed,
    GatewayCloseCodes.InvalidShard,
    GatewayCloseCodes.ShardingRequired,
    GatewayCloseCodes.InvalidAPIVersion,
    GatewayCloseCodes.InvalidIntents,
    GatewayCloseCodes.DisallowedIntents
  ];
  var reasonIsDeprecated = "the reason property is deprecated, use the code property to determine the reason";
  var deprecationEmittedForInvalidSessionEvent = false;
  var deprecationEmittedForDestroyedEvent = false;

  class WebSocketManager extends EventEmitter {
    constructor(client) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.gateway = null;
      this.shards = new Collection;
      Object.defineProperty(this, "packetQueue", { value: [] });
      this.status = Status.Idle;
      this.destroyed = false;
      this._ws = null;
    }
    get ping() {
      const sum = this.shards.reduce((a, b) => a + b.ping, 0);
      return sum / this.shards.size;
    }
    debug(messages, shardId) {
      this.client.emit(Events.Debug, `[WS => ${typeof shardId === "number" ? `Shard ${shardId}` : "Manager"}] ${messages.join(`
	`)}`);
    }
    async connect() {
      const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);
      const { shards, shardCount, intents, ws } = this.client.options;
      if (this._ws && this._ws.options.token !== this.client.token) {
        await this._ws.destroy({ code: CloseCodes.Normal, reason: "Login with differing token requested" });
        this._ws = null;
      }
      if (!this._ws) {
        const wsOptions = {
          intents: intents.bitfield,
          rest: this.client.rest,
          token: this.client.token,
          largeThreshold: ws.large_threshold,
          version: ws.version,
          shardIds: shards === "auto" ? null : shards,
          shardCount: shards === "auto" ? null : shardCount,
          initialPresence: ws.presence,
          retrieveSessionInfo: (shardId) => this.shards.get(shardId).sessionInfo,
          updateSessionInfo: (shardId, sessionInfo) => {
            this.shards.get(shardId).sessionInfo = sessionInfo;
          },
          compression: zlib ? CompressionMethod.ZlibStream : null
        };
        if (ws.buildIdentifyThrottler)
          wsOptions.buildIdentifyThrottler = ws.buildIdentifyThrottler;
        if (ws.buildStrategy)
          wsOptions.buildStrategy = ws.buildStrategy;
        this._ws = new WSWebSocketManager(wsOptions);
        this.attachEvents();
      }
      const {
        url: gatewayURL,
        shards: recommendedShards,
        session_start_limit: sessionStartLimit
      } = await this._ws.fetchGatewayInformation().catch((error) => {
        throw error.status === 401 ? invalidToken : error;
      });
      const { total, remaining } = sessionStartLimit;
      this.debug(["Fetched Gateway Information", `URL: ${gatewayURL}`, `Recommended Shards: ${recommendedShards}`]);
      this.debug(["Session Limit Information", `Total: ${total}`, `Remaining: ${remaining}`]);
      this.gateway = `${gatewayURL}/`;
      this.client.options.shardCount = await this._ws.getShardCount();
      this.client.options.shards = await this._ws.getShardIds();
      this.totalShards = this.client.options.shards.length;
      for (const id of this.client.options.shards) {
        if (!this.shards.has(id)) {
          const shard = new WebSocketShard(this, id);
          this.shards.set(id, shard);
          shard.on(WebSocketShardEvents.AllReady, (unavailableGuilds) => {
            this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);
            this.checkShardsReady();
          });
          shard.status = Status.Connecting;
        }
      }
      await this._ws.connect();
      this.shards.forEach((shard) => {
        if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {
          process2.emitWarning("The WebSocketShard#invalidSession event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForInvalidSessionEvent = true;
        }
        if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {
          process2.emitWarning("The WebSocketShard#destroyed event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForDestroyedEvent = true;
        }
      });
    }
    attachEvents() {
      this._ws.on(WSWebSocketShardEvents.Debug, ({ message, shardId }) => this.debug([message], shardId));
      this._ws.on(WSWebSocketShardEvents.Dispatch, ({ data, shardId }) => {
        this.client.emit(Events.Raw, data, shardId);
        this.emit(data.t, data.d, shardId);
        const shard = this.shards.get(shardId);
        this.handlePacket(data, shard);
        if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {
          shard.gotGuild(data.d.id);
        }
      });
      this._ws.on(WSWebSocketShardEvents.Ready, ({ data, shardId }) => {
        this.shards.get(shardId).onReadyPacket(data);
      });
      this._ws.on(WSWebSocketShardEvents.Closed, ({ code, shardId }) => {
        const shard = this.shards.get(shardId);
        shard.emit(WebSocketShardEvents.Close, { code, reason: reasonIsDeprecated, wasClean: true });
        if (UNRECOVERABLE_CLOSE_CODES.includes(code)) {
          shard.status = Status.Disconnected;
          this.client.emit(Events.ShardDisconnect, { code, reason: reasonIsDeprecated, wasClean: true }, shardId);
          this.debug([`Shard not recoverable: ${code} (${GatewayCloseCodes[code] ?? CloseCodes[code]})`], shardId);
          return;
        }
        this.shards.get(shardId).status = Status.Connecting;
        this.client.emit(Events.ShardReconnecting, shardId);
      });
      this._ws.on(WSWebSocketShardEvents.Hello, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        if (shard.sessionInfo) {
          shard.closeSequence = shard.sessionInfo.sequence;
          shard.status = Status.Resuming;
        } else {
          shard.status = Status.Identifying;
        }
      });
      this._ws.on(WSWebSocketShardEvents.Resumed, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        shard.status = Status.Ready;
        shard.emit(WebSocketShardEvents.Resumed);
      });
      this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({ heartbeatAt, latency, shardId }) => {
        this.debug([`Heartbeat acknowledged, latency of ${latency}ms.`], shardId);
        const shard = this.shards.get(shardId);
        shard.lastPingTimestamp = heartbeatAt;
        shard.ping = latency;
      });
      this._ws.on(WSWebSocketShardEvents.Error, ({ error, shardId }) => {
        this.client.emit(Events.ShardError, error, shardId);
      });
    }
    broadcast(packet) {
      for (const shardId of this.shards.keys())
        this._ws.send(shardId, packet);
    }
    async destroy() {
      if (this.destroyed)
        return;
      this.debug([Object.assign(new Error, { name: "Manager was destroyed:" }).stack]);
      this.destroyed = true;
      await this._ws?.destroy({ code: CloseCodes.Normal, reason: "Manager was destroyed" });
    }
    handlePacket(packet, shard) {
      if (packet && this.status !== Status.Ready) {
        if (!BeforeReadyWhitelist.includes(packet.t)) {
          this.packetQueue.push({ packet, shard });
          return false;
        }
      }
      if (this.packetQueue.length) {
        const item = this.packetQueue.shift();
        setImmediate2(() => {
          this.handlePacket(item.packet, item.shard);
        }).unref();
      }
      if (packet && PacketHandlers[packet.t]) {
        PacketHandlers[packet.t](this.client, packet, shard);
      }
      return true;
    }
    checkShardsReady() {
      if (this.status === Status.Ready)
        return;
      if (this.shards.size !== this.totalShards || this.shards.some((shard) => shard.status !== Status.Ready)) {
        return;
      }
      this.triggerClientReady();
    }
    triggerClientReady() {
      this.status = Status.Ready;
      this.client.readyTimestamp = Date.now();
      if (this.client.emit("ready", this.client) && !deprecationEmitted) {
        deprecationEmitted = true;
        process2.emitWarning("The ready event has been renamed to clientReady to distinguish it from the gateway READY event and will only emit under that name in v15. Please use clientReady instead.", "DeprecationWarning");
      }
      this.client.emit(Events.ClientReady, this.client);
      this.handlePacket();
    }
  }
  module.exports = WebSocketManager;
});

// ../../node_modules/discord.js/src/managers/BaseGuildEmojiManager.js
var require_BaseGuildEmojiManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var ApplicationEmoji = require_ApplicationEmoji();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var { parseEmoji } = require_Util();

  class BaseGuildEmojiManager extends CachedManager {
    constructor(client, iterable) {
      super(client, GuildEmoji, iterable);
    }
    resolve(emoji) {
      if (emoji instanceof ReactionEmoji)
        return this.cache.get(emoji.id) ?? null;
      if (emoji instanceof ApplicationEmoji)
        return this.cache.get(emoji.id) ?? null;
      return super.resolve(emoji);
    }
    resolveId(emoji) {
      if (emoji instanceof ReactionEmoji)
        return emoji.id;
      if (emoji instanceof ApplicationEmoji)
        return emoji.id;
      return super.resolveId(emoji);
    }
    resolveIdentifier(emoji) {
      const emojiResolvable = this.resolve(emoji);
      if (emojiResolvable)
        return emojiResolvable.identifier;
      if (emoji instanceof ReactionEmoji)
        return emoji.identifier;
      if (emoji instanceof ApplicationEmoji)
        return emoji.identifier;
      if (typeof emoji === "string") {
        const res = parseEmoji(emoji);
        if (res?.name.length) {
          emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
        }
        if (!emoji.includes("%"))
          return encodeURIComponent(emoji);
        return emoji;
      }
      return null;
    }
  }
  module.exports = BaseGuildEmojiManager;
});

// ../../node_modules/discord.js/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { BaseChannel } = require_BaseChannel();
  var { createChannel } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var Events = require_Events();
  var cacheWarningEmitted = false;

  class ChannelManager extends CachedManager {
    constructor(client, iterable) {
      super(client, BaseChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    _add(data, guild, { cache = true, allowUnknownGuild = false } = {}) {
      const existing = this.cache.get(data.id);
      if (existing) {
        if (cache)
          existing._patch(data);
        guild?.channels?._add(existing);
        if (ThreadChannelTypes.includes(existing.type)) {
          existing.parent?.threads?._add(existing);
        }
        return existing;
      }
      const channel = createChannel(this.client, data, guild, { allowUnknownGuild });
      if (!channel) {
        this.client.emit(Events.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
        return null;
      }
      if (cache && !allowUnknownGuild)
        this.cache.set(channel.id, channel);
      return channel;
    }
    _remove(id) {
      const channel = this.cache.get(id);
      channel?.guild?.channels.cache.delete(id);
      for (const [code, invite] of channel?.guild?.invites.cache ?? []) {
        if (invite.channelId === id)
          channel.guild.invites.cache.delete(code);
      }
      channel?.parent?.threads?.cache.delete(id);
      this.cache.delete(id);
      if (channel?.threads) {
        for (const threadId of channel.threads.cache.keys()) {
          this.cache.delete(threadId);
          channel.guild?.channels.cache.delete(threadId);
        }
      }
    }
    async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channel(id));
      return this._add(data, null, { cache, allowUnknownGuild });
    }
  }
  module.exports = ChannelManager;
});

// ../../node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { calculateShardId } = require_dist();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var Events = require_Events();
  var { makeError, makePlainError } = require_Util();

  class ShardClientUtil {
    constructor(client, mode) {
      this.client = client;
      this.mode = mode;
      this.parentPort = null;
      switch (mode) {
        case "process":
          process2.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            process2.send({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            process2.send({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            process2.send({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            process2.send({ _resume: true });
          });
          break;
        case "worker":
          this.parentPort = __require("worker_threads").parentPort;
          this.parentPort.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            this.parentPort.postMessage({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            this.parentPort.postMessage({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            this.parentPort.postMessage({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            this.parentPort.postMessage({ _resume: true });
          });
          break;
      }
    }
    get ids() {
      return this.client.options.shards;
    }
    get count() {
      return this.client.options.shardCount;
    }
    send(message) {
      return new Promise((resolve, reject) => {
        switch (this.mode) {
          case "process":
            process2.send(message, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
            break;
          case "worker":
            this.parentPort.postMessage(message);
            resolve();
            break;
        }
      });
    }
    fetchClientValues(prop, shard) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        const listener = (message) => {
          if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    broadcastEval(script2, options = {}) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        if (typeof script2 !== "function") {
          reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));
          return;
        }
        script2 = `(${script2})(this, ${JSON.stringify(options.context)})`;
        const listener = (message) => {
          if (message?._sEval !== script2 || message._sEvalShard !== options.shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sEval: script2, _sEvalShard: options.shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });
    }
    async _handleMessage(message) {
      if (!message)
        return;
      if (message._fetchProp) {
        try {
          const props = message._fetchProp.split(".");
          let value = this.client;
          for (const prop of props)
            value = value[prop];
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _result: value });
        } catch (err) {
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _error: makePlainError(err) });
        }
      } else if (message._eval) {
        try {
          this._respond("eval", { _eval: message._eval, _result: await this.client._eval(message._eval) });
        } catch (err) {
          this._respond("eval", { _eval: message._eval, _error: makePlainError(err) });
        }
      }
    }
    _respond(type, message) {
      this.send(message).catch((err) => {
        const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);
        error.stack = err.stack;
        this.client.emit(Events.Error, error);
      });
    }
    static singleton(client, mode) {
      if (!this._singleton) {
        this._singleton = new this(client, mode);
      } else {
        client.emit(Events.Warn, "Multiple clients created in child process/worker; only the first will handle sharding helpers.");
      }
      return this._singleton;
    }
    static shardIdForGuildId(guildId, shardCount) {
      const shard = calculateShardId(guildId, shardCount);
      if (shard < 0)
        throw new DiscordjsError(ErrorCodes.ShardingShardMiscalculation, shard, guildId, shardCount);
      return shard;
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = ShardClientUtil;
});

// ../../node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var ApplicationCommand = require_ApplicationCommand();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var { flatten } = require_Util();

  class GuildAuditLogs {
    constructor(guild, data) {
      if (data.users)
        for (const user of data.users)
          guild.client.users._add(user);
      if (data.threads)
        for (const thread of data.threads)
          guild.client.channels._add(thread, guild);
      this.webhooks = new Collection;
      if (data.webhooks) {
        for (const hook of data.webhooks) {
          this.webhooks.set(hook.id, new Webhook(guild.client, hook));
        }
      }
      this.integrations = new Collection;
      if (data.integrations) {
        for (const integration of data.integrations) {
          this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
        }
      }
      this.guildScheduledEvents = data.guild_scheduled_events.reduce((guildScheduledEvents, guildScheduledEvent) => guildScheduledEvents.set(guildScheduledEvent.id, guild.scheduledEvents._add(guildScheduledEvent)), new Collection);
      this.applicationCommands = new Collection;
      if (data.application_commands) {
        for (const command of data.application_commands) {
          this.applicationCommands.set(command.id, new ApplicationCommand(guild.client, command, guild));
        }
      }
      this.autoModerationRules = data.auto_moderation_rules.reduce((autoModerationRules, autoModerationRule) => autoModerationRules.set(autoModerationRule.id, guild.autoModerationRules._add(autoModerationRule)), new Collection);
      this.entries = new Collection;
      for (const item of data.audit_log_entries) {
        const entry = new GuildAuditLogsEntry(guild, item, this);
        this.entries.set(entry.id, entry);
      }
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = GuildAuditLogs;
});

// ../../node_modules/discord.js/src/structures/GuildOnboarding.js
var require_GuildOnboarding = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var Base = require_Base();
  var { GuildOnboardingPrompt } = require_GuildOnboardingPrompt();

  class GuildOnboarding extends Base {
    constructor(client, data) {
      super(client);
      this.guildId = data.guild_id;
      const guild = this.guild;
      this.prompts = data.prompts.reduce((prompts, prompt) => prompts.set(prompt.id, new GuildOnboardingPrompt(client, prompt, this.guildId)), new Collection);
      this.defaultChannels = data.default_channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.enabled = data.enabled;
      this.mode = data.mode;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboarding = GuildOnboarding;
});

// ../../node_modules/discord.js/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS((exports, module) => {
  var BaseGuildEmoji = require_BaseGuildEmoji();

  class GuildPreviewEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.roles = data.roles;
    }
  }
  module.exports = GuildPreviewEmoji;
});

// ../../node_modules/discord.js/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var { Routes } = require_v106();
  var Base = require_Base();
  var GuildPreviewEmoji = require_GuildPreviewEmoji();
  var { Sticker } = require_Sticker();

  class GuildPreview extends Base {
    constructor(client, data) {
      super(client);
      if (!data)
        return;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      }
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("features" in data) {
        this.features = data.features;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if (!this.emojis) {
        this.emojis = new Collection;
      } else {
        this.emojis.clear();
      }
      for (const emoji of data.emojis) {
        this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
      }
      this.stickers = data.stickers.reduce((stickers, sticker) => stickers.set(sticker.id, new Sticker(this.client, sticker)), new Collection);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      this._patch(data);
      return this;
    }
    toString() {
      return this.name;
    }
    toJSON() {
      const json = super.toJSON();
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      return json;
    }
  }
  module.exports = GuildPreview;
});

// ../../node_modules/discord.js/src/managers/AutoModerationRuleManager.js
var require_AutoModerationRuleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var AutoModerationRule = require_AutoModerationRule();

  class AutoModerationRuleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, AutoModerationRule, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({
      name,
      eventType,
      triggerType,
      triggerMetadata,
      actions,
      enabled,
      exemptRoles,
      exemptChannels,
      reason
    }) {
      const data = await this.client.rest.post(Routes.guildAutoModerationRules(this.guild.id), {
        body: {
          name,
          event_type: eventType,
          trigger_type: triggerType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    async edit(autoModerationRule, { name, eventType, triggerMetadata, actions, enabled, exemptRoles, exemptChannels, reason }) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      const data = await this.client.rest.patch(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {
        body: {
          name,
          event_type: eventType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions?.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { autoModerationRule, cache, force } = options;
      const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);
      if (resolvedAutoModerationRule) {
        return this._fetchSingle({ autoModerationRule: resolvedAutoModerationRule, cache, force });
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ autoModerationRule, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(autoModerationRule);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildAutoModerationRule(this.guild.id, autoModerationRule));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildAutoModerationRules(this.guild.id));
      return data.reduce((col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)), new Collection);
    }
    async delete(autoModerationRule, reason) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      await this.client.rest.delete(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), { reason });
    }
  }
  module.exports = AutoModerationRuleManager;
});

// ../../node_modules/discord.js/src/managers/GuildApplicationCommandManager.js
var require_GuildApplicationCommandManager = __commonJS((exports, module) => {
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();

  class GuildApplicationCommandManager extends ApplicationCommandManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
  }
  module.exports = GuildApplicationCommandManager;
});

// ../../node_modules/discord.js/src/managers/GuildBanManager.js
var require_GuildBanManager = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors();
  var GuildBan = require_GuildBan();
  var { GuildMember } = require_GuildMember();
  var deprecationEmittedForDeleteMessageDays = false;

  class GuildBanManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildBan, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(ban) {
      return super.resolve(ban) ?? super.resolve(this.client.users.resolveId(ban));
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user, cache, force, limit, before, after } = options;
      const resolvedUser = this.client.users.resolveId(user ?? options);
      if (resolvedUser)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      if (!before && !after && !limit && cache === undefined) {
        throw new DiscordjsError(ErrorCodes.FetchBanResolveId);
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildBan(this.guild.id, user));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildBans(this.guild.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((col, ban) => col.set(ban.user.id, this._add(ban, options.cache)), new Collection);
    }
    async create(user, options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId, true);
      if (options.deleteMessageDays !== undefined && !deprecationEmittedForDeleteMessageDays) {
        process2.emitWarning("The deleteMessageDays option for GuildBanManager#create() is deprecated. Use the deleteMessageSeconds option instead.", "DeprecationWarning");
        deprecationEmittedForDeleteMessageDays = true;
      }
      await this.client.rest.put(Routes.guildBan(this.guild.id, id), {
        body: {
          delete_message_seconds: options.deleteMessageSeconds ?? (options.deleteMessageDays ? options.deleteMessageDays * 24 * 60 * 60 : undefined)
        },
        reason: options.reason
      });
      if (user instanceof GuildMember)
        return user;
      const _user = this.client.users.cache.get(id);
      if (_user) {
        return this.guild.members.resolve(_user) ?? _user;
      }
      return id;
    }
    async remove(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId);
      await this.client.rest.delete(Routes.guildBan(this.guild.id, id), { reason });
      return this.client.users.resolve(user);
    }
    async bulkCreate(users, options = {}) {
      if (!users || !(Array.isArray(users) || users instanceof Collection)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "users", "Array or Collection of UserResolvable", true);
      }
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const userIds = users.map((user) => this.client.users.resolveId(user));
      if (userIds.length === 0)
        throw new DiscordjsError(ErrorCodes.BulkBanUsersOptionEmpty);
      const result = await this.client.rest.post(Routes.guildBulkBan(this.guild.id), {
        body: { delete_message_seconds: options.deleteMessageSeconds, user_ids: userIds },
        reason: options.reason
      });
      return { bannedUsers: result.banned_users, failedUsers: result.failed_users };
    }
  }
  module.exports = GuildBanManager;
});

// ../../node_modules/discord.js/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { Collection } = require_dist6();
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var GuildChannel = require_GuildChannel();
  var PermissionOverwrites = require_PermissionOverwrites();
  var ThreadChannel = require_ThreadChannel();
  var Webhook = require_Webhook();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { transformGuildForumTag, transformGuildDefaultReaction } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var { resolveImage } = require_DataResolver();
  var { setPosition } = require_Util();
  var cacheWarningEmitted = false;

  class GuildChannelManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    get channelCountWithoutThreads() {
      return this.cache.reduce((acc, channel) => {
        if (ThreadChannelTypes.includes(channel.type))
          return acc;
        return ++acc;
      }, 0);
    }
    _add(channel) {
      const existing = this.cache.get(channel.id);
      if (existing)
        return existing;
      this.cache.set(channel.id, channel);
      return channel;
    }
    resolve(channel) {
      if (channel instanceof ThreadChannel)
        return this.cache.get(channel.id) ?? null;
      return super.resolve(channel);
    }
    resolveId(channel) {
      if (channel instanceof ThreadChannel)
        return super.resolveId(channel.id);
      return super.resolveId(channel);
    }
    async addFollower(channel, targetChannel, reason) {
      const channelId = this.resolveId(channel);
      if (!channelId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "NewsChannelResolvable");
      }
      const targetChannelId = this.resolveId(targetChannel);
      if (!targetChannelId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "targetChannel", "TextChannelResolvable");
      }
      const { webhook_id } = await this.client.rest.post(Routes.channelFollowers(channelId), {
        body: { webhook_channel_id: targetChannelId },
        reason
      });
      return webhook_id;
    }
    async create({
      name,
      type,
      topic,
      nsfw,
      bitrate,
      userLimit,
      parent,
      permissionOverwrites,
      position,
      rateLimitPerUser,
      rtcRegion,
      videoQualityMode,
      defaultThreadRateLimitPerUser,
      availableTags,
      defaultReactionEmoji,
      defaultAutoArchiveDuration,
      defaultSortOrder,
      defaultForumLayout,
      reason
    }) {
      parent &&= this.client.channels.resolveId(parent);
      permissionOverwrites &&= permissionOverwrites.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
      const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {
        body: {
          name,
          topic,
          type,
          nsfw,
          bitrate,
          user_limit: userLimit,
          parent_id: parent,
          position,
          permission_overwrites: permissionOverwrites,
          rate_limit_per_user: rateLimitPerUser,
          rtc_region: rtcRegion,
          video_quality_mode: videoQualityMode,
          default_thread_rate_limit_per_user: defaultThreadRateLimitPerUser,
          available_tags: availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),
          default_auto_archive_duration: defaultAutoArchiveDuration,
          default_sort_order: defaultSortOrder,
          default_forum_layout: defaultForumLayout
        },
        reason
      });
      return this.client.actions.ChannelCreate.handle(data).channel;
    }
    async createWebhook({ channel, name, avatar, reason }) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const resolvedImage = await resolveImage(avatar);
      const data = await this.client.rest.post(Routes.channelWebhooks(id), {
        body: {
          name,
          avatar: resolvedImage
        },
        reason
      });
      return new Webhook(this.client, data);
    }
    async edit(channel, options) {
      const resolvedChannel = this.resolve(channel);
      if (!resolvedChannel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const parentId = options.parent && this.client.channels.resolveId(options.parent);
      if (options.position !== undefined) {
        await this.setPosition(resolvedChannel, options.position, { position: options.position, reason: options.reason });
      }
      let permission_overwrites = options.permissionOverwrites?.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
      if (options.lockPermissions) {
        if (parentId) {
          const newParent = this.cache.get(parentId);
          if (newParent?.type === ChannelType.GuildCategory) {
            permission_overwrites = newParent.permissionOverwrites.cache.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
          }
        } else if (resolvedChannel.parent) {
          permission_overwrites = resolvedChannel.parent.permissionOverwrites.cache.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
        }
      }
      const newData = await this.client.rest.patch(Routes.channel(resolvedChannel.id), {
        body: {
          name: options.name,
          type: options.type,
          topic: options.topic,
          nsfw: options.nsfw,
          bitrate: options.bitrate,
          user_limit: options.userLimit,
          rtc_region: options.rtcRegion,
          video_quality_mode: options.videoQualityMode,
          parent_id: parentId,
          lock_permissions: options.lockPermissions,
          rate_limit_per_user: options.rateLimitPerUser,
          default_auto_archive_duration: options.defaultAutoArchiveDuration,
          permission_overwrites,
          available_tags: options.availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),
          default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,
          default_sort_order: options.defaultSortOrder,
          default_forum_layout: options.defaultForumLayout
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    async setPosition(channel, position, { relative, reason } = {}) {
      channel = this.resolve(channel);
      if (!channel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const updatedChannels = await setPosition(channel, position, relative, this.guild._sortedChannels(channel), this.client, Routes.guildChannels(this.guild.id), reason);
      this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: updatedChannels
      });
      return channel;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id && !force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      if (id) {
        const data2 = await this.client.rest.get(Routes.channel(id));
        if (this.guild.id !== data2.guild_id)
          throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);
        return this.client.channels._add(data2, this.guild, { cache });
      }
      const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));
      const channels = new Collection;
      for (const channel of data)
        channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));
      return channels;
    }
    async fetchWebhooks(channel) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const data = await this.client.rest.get(Routes.channelWebhooks(id));
      return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection);
    }
    async setPositions(channelPositions) {
      channelPositions = channelPositions.map((channelPosition) => ({
        id: this.client.channels.resolveId(channelPosition.channel),
        position: channelPosition.position,
        lock_permissions: channelPosition.lockPermissions,
        parent_id: channelPosition.parent !== undefined ? this.resolveId(channelPosition.parent) : undefined
      }));
      await this.client.rest.patch(Routes.guildChannels(this.guild.id), { body: channelPositions });
      return this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: channelPositions
      }).guild;
    }
    async fetchActiveThreads(cache = true) {
      const data = await this.rawFetchGuildActiveThreads();
      return GuildTextThreadManager._mapThreads(data, this.client, { guild: this.guild, cache });
    }
    rawFetchGuildActiveThreads() {
      return this.client.rest.get(Routes.guildActiveThreads(this.guild.id));
    }
    async delete(channel, reason) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      await this.client.rest.delete(Routes.channel(id), { reason });
      this.client.actions.ChannelDelete.handle({ id });
    }
  }
  module.exports = GuildChannelManager;
});

// ../../node_modules/discord.js/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes, PermissionFlagsBits } = require_v106();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var { resolveImage } = require_DataResolver();

  class GuildEmojiManager extends BaseGuildEmojiManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ attachment, name, roles, reason }) {
      attachment = await resolveImage(attachment);
      if (!attachment)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      const body = { image: attachment, name };
      if (roles) {
        if (!Array.isArray(roles) && !(roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        body.roles = [];
        for (const role of roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          body.roles.push(resolvedRole);
        }
      }
      const emoji = await this.client.rest.post(Routes.guildEmojis(this.guild.id), { body, reason });
      return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const emoji = await this.client.rest.get(Routes.guildEmoji(this.guild.id, id));
        return this._add(emoji, cache);
      }
      const data = await this.client.rest.get(Routes.guildEmojis(this.guild.id));
      const emojis = new Collection;
      for (const emoji of data)
        emojis.set(emoji.id, this._add(emoji, cache));
      return emojis;
    }
    async delete(emoji, reason) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      await this.client.rest.delete(Routes.guildEmoji(this.guild.id, id), { reason });
    }
    async edit(emoji, options) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const roles = options.roles?.map((role) => this.guild.roles.resolveId(role));
      const newData = await this.client.rest.patch(Routes.guildEmoji(this.guild.id, id), {
        body: {
          name: options.name,
          roles
        },
        reason: options.reason
      });
      const existing = this.cache.get(id);
      if (existing) {
        const clone = existing._clone();
        clone._patch(newData);
        return clone;
      }
      return this._add(newData);
    }
    async fetchAuthor(emoji) {
      emoji = this.resolve(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      if (emoji.managed) {
        throw new DiscordjsError(ErrorCodes.EmojiManaged);
      }
      const { me } = this.guild.members;
      if (!me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      if (!me.permissions.has(PermissionFlagsBits.ManageGuildExpressions)) {
        throw new DiscordjsError(ErrorCodes.MissingManageGuildExpressionsPermission, this.guild);
      }
      const data = await this.client.rest.get(Routes.guildEmoji(this.guild.id, emoji.id));
      emoji._patch(data);
      return emoji.author;
    }
  }
  module.exports = GuildEmojiManager;
});

// ../../node_modules/discord.js/src/managers/GuildInviteManager.js
var require_GuildInviteManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var Invite = require_Invite();
  var { resolveInviteCode } = require_DataResolver();

  class GuildInviteManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Invite, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.code, extras: [this.guild] });
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany();
      if (typeof options === "string") {
        const code = resolveInviteCode(options);
        if (!code)
          throw new DiscordjsError(ErrorCodes.InviteResolveCode);
        return this._fetchSingle({ code, cache: true });
      }
      if (!options.code) {
        if (options.channelId) {
          const id = this.guild.channels.resolveId(options.channelId);
          if (!id)
            throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
          return this._fetchChannelMany(id, options.cache);
        }
        if ("cache" in options)
          return this._fetchMany(options.cache);
        throw new DiscordjsError(ErrorCodes.InviteResolveCode);
      }
      return this._fetchSingle({
        ...options,
        code: resolveInviteCode(options.code)
      });
    }
    async _fetchSingle({ code, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(code);
        if (existing)
          return existing;
      }
      const invites = await this._fetchMany(cache);
      const invite = invites.get(code);
      if (!invite)
        throw new DiscordjsError(ErrorCodes.InviteNotFound);
      return invite;
    }
    async _fetchMany(cache) {
      const data = await this.client.rest.get(Routes.guildInvites(this.guild.id));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async _fetchChannelMany(channelId, cache) {
      const data = await this.client.rest.get(Routes.channelInvites(channelId));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async create(channel, { temporary, maxAge, maxUses, unique, targetUser, targetApplication, targetType, reason } = {}) {
      const id = this.guild.channels.resolveId(channel);
      if (!id)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const invite = await this.client.rest.post(Routes.channelInvites(id), {
        body: {
          temporary,
          max_age: maxAge,
          max_uses: maxUses,
          unique,
          target_user_id: this.client.users.resolveId(targetUser),
          target_application_id: targetApplication?.id ?? targetApplication?.applicationId ?? targetApplication,
          target_type: targetType
        },
        reason
      });
      return new Invite(this.client, invite);
    }
    async delete(invite, reason) {
      const code = resolveInviteCode(invite);
      await this.client.rest.delete(Routes.invite(code), { reason });
    }
  }
  module.exports = GuildInviteManager;
});

// ../../node_modules/discord.js/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("timers");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var { Routes, GatewayOpcodes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  var { GuildMember } = require_GuildMember();
  var { Role } = require_Role();
  var Events = require_Events();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var Partials = require_Partials();

  class GuildMemberManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildMember, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userId = this.client.users.resolveId(member);
      if (userId)
        return this.cache.get(userId) ?? null;
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userId = this.client.users.resolveId(member);
      return this.cache.has(userId) ? userId : null;
    }
    async add(user, options) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (!options.force) {
        const cachedUser = this.cache.get(userId);
        if (cachedUser)
          return cachedUser;
      }
      const resolvedOptions = {
        access_token: options.accessToken,
        nick: options.nick,
        mute: options.mute,
        deaf: options.deaf
      };
      if (options.roles) {
        if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        const resolvedRoles = [];
        for (const role of options.roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        resolvedOptions.roles = resolvedRoles;
      }
      const data = await this.client.rest.put(Routes.guildMember(this.guild.id, userId), { body: resolvedOptions });
      return data instanceof ArrayBuffer ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);
    }
    get me() {
      return this.cache.get(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({ user: { id: this.client.user.id } }, true) : null);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user: users, limit, withPresences, cache, force } = options;
      const resolvedUser = this.client.users.resolveId(users ?? options);
      if (resolvedUser && !limit && !withPresences)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      const resolvedUsers = users?.map?.((user) => this.client.users.resolveId(user)) ?? resolvedUser ?? undefined;
      return this._fetchMany({ ...options, users: resolvedUsers });
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildMember(this.guild.id, user));
      return this._add(data, cache);
    }
    async _fetchMany({
      limit = 0,
      withPresences: presences,
      users,
      query,
      time = 120000,
      nonce = DiscordSnowflake.generate().toString()
    } = {}) {
      if (nonce.length > 32)
        throw new DiscordjsRangeError(ErrorCodes.MemberFetchNonceLength);
      return new Promise((resolve, reject) => {
        if (!query && !users)
          query = "";
        this.guild.shard.send({
          op: GatewayOpcodes.RequestGuildMembers,
          d: {
            guild_id: this.guild.id,
            presences,
            user_ids: users,
            query,
            nonce,
            limit
          }
        });
        const fetchedMembers = new Collection;
        let i = 0;
        const handler = (members, _, chunk) => {
          if (chunk.nonce !== nonce)
            return;
          timeout.refresh();
          i++;
          for (const member of members.values()) {
            fetchedMembers.set(member.id, member);
          }
          if (members.size < 1000 || limit && fetchedMembers.size >= limit || i === chunk.count) {
            clearTimeout2(timeout);
            this.client.removeListener(Events.GuildMembersChunk, handler);
            this.client.decrementMaxListeners();
            resolve(users && !Array.isArray(users) && fetchedMembers.size ? fetchedMembers.first() : fetchedMembers);
          }
        };
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildMembersChunk, handler);
          this.client.decrementMaxListeners();
          reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));
        }, time).unref();
        this.client.incrementMaxListeners();
        this.client.on(Events.GuildMembersChunk, handler);
      });
    }
    fetchMe(options) {
      return this.fetch({ ...options, user: this.client.user.id });
    }
    async search({ query, limit, cache = true } = {}) {
      const data = await this.client.rest.get(Routes.guildMembersSearch(this.guild.id), {
        query: makeURLSearchParams({ query, limit })
      });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async list({ after, limit, cache = true } = {}) {
      const query = makeURLSearchParams({ limit, after });
      const data = await this.client.rest.get(Routes.guildMembers(this.guild.id), { query });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async edit(user, { reason, ...options }) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (options.channel) {
        options.channel = this.guild.channels.resolve(options.channel);
        if (!(options.channel instanceof BaseGuildVoiceChannel)) {
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        }
        options.channel_id = options.channel.id;
        options.channel = undefined;
      } else if (options.channel === null) {
        options.channel_id = null;
        options.channel = undefined;
      }
      options.roles &&= options.roles.map((role) => role instanceof Role ? role.id : role);
      if (options.communicationDisabledUntil !== undefined) {
        options.communication_disabled_until = options.communicationDisabledUntil != null ? new Date(options.communicationDisabledUntil).toISOString() : options.communicationDisabledUntil;
      }
      if (options.flags !== undefined) {
        options.flags = GuildMemberFlagsBitField.resolve(options.flags);
      }
      let endpoint;
      if (id === this.client.user.id) {
        const keys = Object.keys(options);
        if (keys.length === 1 && keys[0] === "nick")
          endpoint = Routes.guildMember(this.guild.id);
        else
          endpoint = Routes.guildMember(this.guild.id, id);
      } else {
        endpoint = Routes.guildMember(this.guild.id, id);
      }
      const d = await this.client.rest.patch(endpoint, { body: options, reason });
      const clone = this.cache.get(id)?._clone();
      clone?._patch(d);
      return clone ?? this._add(d, false);
    }
    async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {
      if (typeof days !== "number")
        throw new DiscordjsTypeError(ErrorCodes.PruneDaysType);
      const query = { days };
      const resolvedRoles = [];
      for (const role of roles) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "options.roles", role);
        }
        resolvedRoles.push(resolvedRole);
      }
      if (resolvedRoles.length) {
        query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
      }
      const endpoint = Routes.guildPrune(this.guild.id);
      const { pruned } = await (dry ? this.client.rest.get(endpoint, { query: makeURLSearchParams(query), reason }) : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));
      return pruned;
    }
    async kick(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      await this.client.rest.delete(Routes.guildMember(this.guild.id, id), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? id;
    }
    ban(user, options) {
      return this.guild.bans.create(user, options);
    }
    unban(user, reason) {
      return this.guild.bans.remove(user, reason);
    }
    bulkBan(users, options = {}) {
      return this.guild.bans.bulkCreate(users, options);
    }
    async addRole(options) {
      const { user, role, reason } = options;
      const userId = this.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.put(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
    async removeRole(options) {
      const { user, role, reason } = options;
      const userId = this.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
  }
  module.exports = GuildMemberManager;
});

// ../../node_modules/discord.js/src/managers/GuildScheduledEventManager.js
var require_GuildScheduledEventManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { GuildScheduledEventEntityType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var { resolveImage } = require_DataResolver();
  var { _transformGuildScheduledEventRecurrenceRule } = require_Transformers();

  class GuildScheduledEventManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildScheduledEvent, iterable);
      this.guild = guild;
    }
    async create(options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image,
        recurrenceRule
      } = options;
      let entity_metadata, channel_id;
      if (entityType === GuildScheduledEventEntityType.External) {
        channel_id = channel === undefined ? channel : null;
        entity_metadata = { location: entityMetadata?.location };
      } else {
        channel_id = this.guild.channels.resolveId(channel);
        if (!channel_id)
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        entity_metadata = entityMetadata === undefined ? entityMetadata : null;
      }
      const data = await this.client.rest.post(Routes.guildScheduledEvents(this.guild.id), {
        body: {
          channel_id,
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: new Date(scheduledStartTime).toISOString(),
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          entity_metadata,
          image: image && await resolveImage(image),
          recurrence_rule: recurrenceRule && _transformGuildScheduledEventRecurrenceRule(recurrenceRule)
        },
        reason
      });
      return this._add(data);
    }
    async fetch(options = {}) {
      const id = this.resolveId(options.guildScheduledEvent ?? options);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guildScheduledEvent(this.guild.id, id), {
          query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
        });
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.guildScheduledEvents(this.guild.id), {
        query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
      });
      return data.reduce((coll, rawGuildScheduledEventData) => coll.set(rawGuildScheduledEventData.id, this._add(rawGuildScheduledEventData, options.cache)), new Collection);
    }
    async edit(guildScheduledEvent, options) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        status,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image,
        recurrenceRule
      } = options;
      let entity_metadata;
      if (entityMetadata) {
        entity_metadata = {
          location: entityMetadata.location
        };
      }
      const data = await this.client.rest.patch(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId), {
        body: {
          channel_id: channel === undefined ? channel : this.guild.channels.resolveId(channel),
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : undefined,
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          status,
          image: image && await resolveImage(image),
          entity_metadata,
          recurrence_rule: recurrenceRule && _transformGuildScheduledEventRecurrenceRule(recurrenceRule)
        },
        reason
      });
      return this._add(data);
    }
    async delete(guildScheduledEvent) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      await this.client.rest.delete(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId));
    }
    async fetchSubscribers(guildScheduledEvent, options = {}) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      const query = makeURLSearchParams({
        limit: options.limit,
        with_member: options.withMember,
        before: options.before,
        after: options.after
      });
      const data = await this.client.rest.get(Routes.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {
        query
      });
      return data.reduce((coll, rawData) => coll.set(rawData.user.id, {
        guildScheduledEventId: rawData.guild_scheduled_event_id,
        user: this.client.users._add(rawData.user),
        member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null
      }), new Collection);
    }
  }
  module.exports = GuildScheduledEventManager;
});

// ../../node_modules/discord.js/src/structures/SoundboardSound.js
var require_SoundboardSound = __commonJS((exports) => {
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var { Emoji } = require_Emoji();
  var { DiscordjsError, ErrorCodes } = require_errors();

  class SoundboardSound extends Base {
    constructor(client, data) {
      super(client);
      this.soundId = data.sound_id;
      this._patch(data);
    }
    _patch(data) {
      if ("available" in data) {
        this.available = data.available;
      } else {
        this.available ??= null;
      }
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("volume" in data) {
        this.volume = data.volume;
      } else {
        this.volume ??= null;
      }
      if ("emoji_id" in data) {
        this._emoji = {
          id: data.emoji_id,
          name: data.emoji_name
        };
      } else {
        this._emoji ??= null;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("user" in data) {
        this.user = this.client.users._add(data.user);
      } else {
        this.user ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.soundId);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get emoji() {
      if (!this._emoji)
        return null;
      return this.guild?.emojis.cache.get(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return this.client.rest.cdn.soundboardSound(this.soundId);
    }
    async edit(options) {
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSoundboardSound, "edited");
      return this.guild.soundboardSounds.edit(this, options);
    }
    async delete(reason) {
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSoundboardSound, "deleted");
      await this.guild.soundboardSounds.delete(this, reason);
      return this;
    }
    equals(other) {
      if (other instanceof SoundboardSound) {
        return this.soundId === other.soundId && this.available === other.available && this.name === other.name && this.volume === other.volume && this._emoji?.id === other._emoji?.id && this._emoji?.name === other._emoji?.name && this.guildId === other.guildId && this.user?.id === other.user?.id;
      }
      return this.soundId === other.sound_id && this.available === other.available && this.name === other.name && this.volume === other.volume && (this._emoji?.id ?? null) === other.emoji_id && (this._emoji?.name ?? null) === other.emoji_name && this.guildId === other.guild_id && this.user?.id === other.user?.id;
    }
  }
  exports.SoundboardSound = SoundboardSound;
});

// ../../node_modules/discord.js/src/managers/GuildSoundboardSoundManager.js
var require_GuildSoundboardSoundManager = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { lazy } = require_dist();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { SoundboardSound } = require_SoundboardSound();
  var { resolveBase64, resolveFile } = require_DataResolver();
  var fileTypeMime = lazy(() => require_dist4().filetypemime);

  class GuildSoundboardSoundManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, SoundboardSound, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild], id: data.sound_id });
    }
    resolveId(soundboardSound) {
      if (soundboardSound instanceof this.holds)
        return soundboardSound.soundId;
      if (typeof soundboardSound === "string")
        return soundboardSound;
      return null;
    }
    async create({ contentType, emojiId, emojiName, file, name, reason, volume }) {
      const resolvedFile = await resolveFile(file);
      const resolvedContentType = contentType ?? resolvedFile.contentType ?? fileTypeMime()(resolvedFile.data)[0];
      const sound = resolveBase64(resolvedFile.data, resolvedContentType);
      const body = { emoji_id: emojiId, emoji_name: emojiName, name, sound, volume };
      const soundboardSound = await this.client.rest.post(Routes.guildSoundboardSounds(this.guild.id), {
        body,
        reason
      });
      return this._add(soundboardSound);
    }
    async edit(soundboardSound, options = {}) {
      const soundId = this.resolveId(soundboardSound);
      if (!soundId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "soundboardSound", "SoundboardSoundResolvable");
      const { emojiId, emojiName, name, reason, volume } = options;
      const body = { emoji_id: emojiId, emoji_name: emojiName, name, volume };
      const data = await this.client.rest.patch(Routes.guildSoundboardSound(this.guild.id, soundId), {
        body,
        reason
      });
      const existing = this.cache.get(soundId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(data);
        return clone;
      }
      return this._add(data);
    }
    async delete(soundboardSound, reason) {
      const soundId = this.resolveId(soundboardSound);
      if (!soundId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "soundboardSound", "SoundboardSoundResolvable");
      await this.client.rest.delete(Routes.guildSoundboardSound(this.guild.id, soundId), { reason });
    }
    async fetch(options) {
      if (!options)
        return this._fetchMany();
      const { cache, force, soundboardSound } = options;
      const resolvedSoundboardSound = this.resolveId(soundboardSound ?? options);
      if (resolvedSoundboardSound)
        return this._fetchSingle({ cache, force, soundboardSound: resolvedSoundboardSound });
      return this._fetchMany({ cache });
    }
    async _fetchSingle({ cache, force, soundboardSound } = {}) {
      if (!force) {
        const existing = this.cache.get(soundboardSound);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildSoundboardSound(this.guild.id, soundboardSound));
      return this._add(data, cache);
    }
    async _fetchMany({ cache } = {}) {
      const data = await this.client.rest.get(Routes.guildSoundboardSounds(this.guild.id));
      return data.items.reduce((coll, sound) => coll.set(sound.sound_id, this._add(sound, cache)), new Collection);
    }
  }
  exports.GuildSoundboardSoundManager = GuildSoundboardSoundManager;
});

// ../../node_modules/discord.js/src/managers/GuildStickerManager.js
var require_GuildStickerManager = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var MessagePayload = require_MessagePayload();
  var { Sticker } = require_Sticker();

  class GuildStickerManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Sticker, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ file, name, tags, description, reason } = {}) {
      const resolvedFile = await MessagePayload.resolveFile(file);
      if (!resolvedFile)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      file = { ...resolvedFile, key: "file" };
      const body = { name, tags, description: description ?? "" };
      const sticker = await this.client.rest.post(Routes.guildStickers(this.guild.id), {
        appendToFormData: true,
        body,
        files: [file],
        reason
      });
      return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;
    }
    async edit(sticker, options = {}) {
      const stickerId = this.resolveId(sticker);
      if (!stickerId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const d = await this.client.rest.patch(Routes.guildSticker(this.guild.id, stickerId), {
        body: options,
        reason: options.reason
      });
      const existing = this.cache.get(stickerId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async delete(sticker, reason) {
      sticker = this.resolveId(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      await this.client.rest.delete(Routes.guildSticker(this.guild.id, sticker), { reason });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const sticker = await this.client.rest.get(Routes.guildSticker(this.guild.id, id));
        return this._add(sticker, cache);
      }
      const data = await this.client.rest.get(Routes.guildStickers(this.guild.id));
      return new Collection(data.map((sticker) => [sticker.id, this._add(sticker, cache)]));
    }
    async fetchUser(sticker) {
      sticker = this.resolve(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const data = await this.client.rest.get(Routes.guildSticker(this.guild.id, sticker.id));
      sticker._patch(data);
      return sticker.user;
    }
  }
  module.exports = GuildStickerManager;
});

// ../../node_modules/discord.js/src/util/ActivityFlagsBitField.js
var require_ActivityFlagsBitField = __commonJS((exports, module) => {
  var { ActivityFlags } = require_v106();
  var BitField = require_BitField();

  class ActivityFlagsBitField extends BitField {
    static Flags = ActivityFlags;
  }
  module.exports = ActivityFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS((exports) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();
  var ActivityFlagsBitField = require_ActivityFlagsBitField();
  var { flatten } = require_Util();

  class Presence extends Base {
    constructor(client, data = {}) {
      super(client);
      this.userId = data.user.id;
      this.guild = data.guild ?? null;
      this._patch(data);
    }
    get user() {
      return this.client.users.resolve(this.userId);
    }
    get member() {
      return this.guild.members.resolve(this.userId);
    }
    _patch(data) {
      if ("status" in data) {
        this.status = data.status;
      } else {
        this.status ??= "offline";
      }
      if ("activities" in data) {
        this.activities = data.activities.map((activity) => new Activity(this, activity));
      } else {
        this.activities ??= [];
      }
      if ("client_status" in data) {
        this.clientStatus = data.client_status;
      } else {
        this.clientStatus ??= null;
      }
      return this;
    }
    _clone() {
      const clone = Object.assign(Object.create(this), this);
      clone.activities = this.activities.map((activity) => activity._clone());
      return clone;
    }
    equals(presence) {
      return this === presence || presence && this.status === presence.status && this.clientStatus?.web === presence.clientStatus?.web && this.clientStatus?.mobile === presence.clientStatus?.mobile && this.clientStatus?.desktop === presence.clientStatus?.desktop && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index]));
    }
    toJSON() {
      return flatten(this);
    }
  }

  class Activity {
    constructor(presence, data) {
      Object.defineProperty(this, "presence", { value: presence });
      this.name = data.name;
      this.type = data.type;
      this.url = data.url ?? null;
      this.details = data.details ?? null;
      this.state = data.state ?? null;
      this.applicationId = data.application_id ?? null;
      this.timestamps = data.timestamps ? {
        start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
        end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
      } : null;
      this.party = data.party ?? null;
      this.syncId = data.sync_id ?? null;
      this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
      this.flags = new ActivityFlagsBitField(data.flags).freeze();
      this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;
      this.buttons = data.buttons ?? [];
      this.createdTimestamp = data.created_at;
    }
    equals(activity) {
      return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url && this.state === activity.state && this.details === activity.details && this.emoji?.id === activity.emoji?.id && this.emoji?.name === activity.emoji?.name;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toString() {
      return this.name;
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
  }

  class RichPresenceAssets {
    constructor(activity, assets) {
      Object.defineProperty(this, "activity", { value: activity });
      this.largeText = assets.large_text ?? null;
      this.smallText = assets.small_text ?? null;
      this.largeImage = assets.large_image ?? null;
      this.smallImage = assets.small_image ?? null;
    }
    smallImageURL(options = {}) {
      if (!this.smallImage)
        return null;
      if (this.smallImage.includes(":")) {
        const [platform, id] = this.smallImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.smallImage, options);
    }
    largeImageURL(options = {}) {
      if (!this.largeImage)
        return null;
      if (this.largeImage.includes(":")) {
        const [platform, id] = this.largeImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          case "spotify":
            return `https://i.scdn.co/image/${id}`;
          case "youtube":
            return `https://i.ytimg.com/vi/${id}/hqdefault_live.jpg`;
          case "twitch":
            return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${id}.png`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.largeImage, options);
    }
  }
  exports.Presence = Presence;
  exports.Activity = Activity;
  exports.RichPresenceAssets = RichPresenceAssets;
});

// ../../node_modules/discord.js/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var { Presence } = require_Presence();

  class PresenceManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Presence, iterable);
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id });
    }
    resolve(presence) {
      const presenceResolvable = super.resolve(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const userId = this.client.users.resolveId(presence);
      return super.cache.get(userId) ?? null;
    }
    resolveId(presence) {
      const presenceResolvable = super.resolveId(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const userId = this.client.users.resolveId(presence);
      return this.cache.has(userId) ? userId : null;
    }
  }
  module.exports = PresenceManager;
});

// ../../node_modules/discord.js/src/managers/RoleManager.js
var require_RoleManager = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { Collection } = require_dist6();
  var { DiscordAPIError } = require_dist5();
  var { RESTJSONErrorCodes, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();
  var { Role } = require_Role();
  var { resolveImage } = require_DataResolver();
  var PermissionsBitField = require_PermissionsBitField();
  var { setPosition, resolveColor } = require_Util();
  var cacheWarningEmitted = false;
  var deprecationEmittedForCreate = false;
  var deprecationEmittedForEdit = false;

  class RoleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Role, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (!id) {
        const data = await this.client.rest.get(Routes.guildRoles(this.guild.id));
        const roles = new Collection;
        for (const role of data)
          roles.set(role.id, this._add(role, cache));
        return roles;
      }
      if (!force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      try {
        const data = await this.client.rest.get(Routes.guildRole(this.guild.id, id));
        return this._add(data, cache);
      } catch (error) {
        if (error instanceof DiscordAPIError && error.code === RESTJSONErrorCodes.UnknownRole) {
          return null;
        }
        throw error;
      }
    }
    async create(options = {}) {
      let { permissions, icon } = options;
      const { name, color, hoist, position, mentionable, reason, unicodeEmoji } = options;
      if (permissions !== undefined)
        permissions = new PermissionsBitField(permissions);
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.imageURL();
        icon = guildEmojiURL ? await resolveImage(guildEmojiURL) : await resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      let colors = options.colors && {
        primary_color: resolveColor(options.colors.primaryColor),
        secondary_color: options.colors.secondaryColor && resolveColor(options.colors.secondaryColor),
        tertiary_color: options.colors.tertiaryColor && resolveColor(options.colors.tertiaryColor)
      };
      if (color !== undefined) {
        if (!deprecationEmittedForCreate) {
          process2.emitWarning(`Passing "color" to RoleManager#create() is deprecated. Use "colors" instead.`);
        }
        deprecationEmittedForCreate = true;
        colors = {
          primary_color: resolveColor(color),
          secondary_color: null,
          tertiary_color: null
        };
      }
      const data = await this.client.rest.post(Routes.guildRoles(this.guild.id), {
        body: {
          name,
          colors,
          hoist,
          permissions,
          mentionable,
          icon,
          unicode_emoji: unicodeEmoji
        },
        reason
      });
      const { role } = this.client.actions.GuildRoleCreate.handle({
        guild_id: this.guild.id,
        role: data
      });
      if (position)
        return this.setPosition(role, position, { reason });
      return role;
    }
    async edit(role, options) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      if (typeof options.position === "number") {
        await this.setPosition(role, options.position, { reason: options.reason });
      }
      let icon = options.icon;
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.imageURL();
        icon = guildEmojiURL ? await resolveImage(guildEmojiURL) : await resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      let colors = options.colors && {
        primary_color: resolveColor(options.colors.primaryColor),
        secondary_color: options.colors.secondaryColor && resolveColor(options.colors.secondaryColor),
        tertiary_color: options.colors.tertiaryColor && resolveColor(options.colors.tertiaryColor)
      };
      if (options.color !== undefined) {
        if (!deprecationEmittedForEdit) {
          process2.emitWarning(`Passing "color" to RoleManager#edit() is deprecated. Use "colors" instead.`);
        }
        deprecationEmittedForEdit = true;
        colors = {
          primary_color: resolveColor(options.color),
          secondary_color: null,
          tertiary_color: null
        };
      }
      const body = {
        name: options.name,
        colors,
        hoist: options.hoist,
        permissions: options.permissions === undefined ? undefined : new PermissionsBitField(options.permissions),
        mentionable: options.mentionable,
        icon,
        unicode_emoji: options.unicodeEmoji
      };
      const d = await this.client.rest.patch(Routes.guildRole(this.guild.id, role.id), { body, reason: options.reason });
      const clone = role._clone();
      clone._patch(d);
      return clone;
    }
    async delete(role, reason) {
      const id = this.resolveId(role);
      await this.client.rest.delete(Routes.guildRole(this.guild.id, id), { reason });
      this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });
    }
    async setPosition(role, position, { relative, reason } = {}) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      const updatedRoles = await setPosition(role, position, relative, this.guild._sortedRoles(), this.client, Routes.guildRoles(this.guild.id), reason);
      this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: updatedRoles
      });
      return role;
    }
    async setPositions(rolePositions) {
      rolePositions = rolePositions.map((rolePosition) => ({
        id: this.resolveId(rolePosition.role),
        position: rolePosition.position
      }));
      await this.client.rest.patch(Routes.guildRoles(this.guild.id), { body: rolePositions });
      return this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: rolePositions
      }).guild;
    }
    comparePositions(role1, role2) {
      const resolvedRole1 = this.resolve(role1);
      const resolvedRole2 = this.resolve(role2);
      if (!resolvedRole1 || !resolvedRole2) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "Role nor a Snowflake");
      }
      const role1Position = resolvedRole1.position;
      const role2Position = resolvedRole2.position;
      if (role1Position === role2Position) {
        return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));
      }
      return role1Position - role2Position;
    }
    botRoleFor(user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        return null;
      return this.cache.find((role) => role.tags?.botId === userId) ?? null;
    }
    get everyone() {
      return this.cache.get(this.guild.id);
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
  }
  module.exports = RoleManager;
});

// ../../node_modules/discord.js/src/managers/StageInstanceManager.js
var require_StageInstanceManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors();
  var { StageInstance } = require_StageInstance();

  class StageInstanceManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, StageInstance, iterable);
      this.guild = guild;
    }
    async create(channel, options) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const { guildScheduledEvent, topic, privacyLevel, sendStartNotification } = options;
      const guildScheduledEventId = guildScheduledEvent && this.resolveId(guildScheduledEvent);
      const data = await this.client.rest.post(Routes.stageInstances(), {
        body: {
          channel_id: channelId,
          topic,
          privacy_level: privacyLevel,
          send_start_notification: sendStartNotification,
          guild_scheduled_event_id: guildScheduledEventId
        }
      });
      return this._add(data);
    }
    async fetch(channel, { cache = true, force = false } = {}) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (!force) {
        const existing = this.cache.find((stageInstance) => stageInstance.channelId === channelId);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.stageInstance(channelId));
      return this._add(data, cache);
    }
    async edit(channel, options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      let { topic, privacyLevel } = options;
      const data = await this.client.rest.patch(Routes.stageInstance(channelId), {
        body: {
          topic,
          privacy_level: privacyLevel
        }
      });
      if (this.cache.has(data.id)) {
        const clone = this.cache.get(data.id)._clone();
        clone._patch(data);
        return clone;
      }
      return this._add(data);
    }
    async delete(channel) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      await this.client.rest.delete(Routes.stageInstance(channelId));
    }
  }
  module.exports = StageInstanceManager;
});

// ../../node_modules/discord.js/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var VoiceState = require_VoiceState();

  class VoiceStateManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, VoiceState, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (existing)
        return existing._patch(data);
      const entry = new this.holds(this.guild, data);
      if (cache)
        this.cache.set(data.user_id, entry);
      return entry;
    }
    async fetch(member, { cache = true, force = false } = {}) {
      const id = member === "@me" ? member : this.guild.members.resolveId(member);
      if (!force) {
        const existing = this.cache.get(id === "@me" ? this.client.user.id : id);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildVoiceState(this.guild.id, id));
      return this._add(data, cache);
    }
  }
  module.exports = VoiceStateManager;
});

// ../../node_modules/discord.js/src/util/SystemChannelFlagsBitField.js
var require_SystemChannelFlagsBitField = __commonJS((exports, module) => {
  var { GuildSystemChannelFlags } = require_v106();
  var BitField = require_BitField();

  class SystemChannelFlagsBitField extends BitField {
    static Flags = GuildSystemChannelFlags;
  }
  module.exports = SystemChannelFlagsBitField;
});

// ../../node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS((exports) => {
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { DiscordSnowflake } = require_cjs();
  var { ChannelType, GuildPremiumTier, Routes, GuildFeature } = require_v106();
  var AnonymousGuild = require_AnonymousGuild();
  var GuildAuditLogs = require_GuildAuditLogs();
  var { GuildOnboarding } = require_GuildOnboarding();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var WelcomeScreen = require_WelcomeScreen();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors();
  var AutoModerationRuleManager = require_AutoModerationRuleManager();
  var GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  var GuildBanManager = require_GuildBanManager();
  var GuildChannelManager = require_GuildChannelManager();
  var GuildEmojiManager = require_GuildEmojiManager();
  var GuildInviteManager = require_GuildInviteManager();
  var GuildMemberManager = require_GuildMemberManager();
  var GuildScheduledEventManager = require_GuildScheduledEventManager();
  var { GuildSoundboardSoundManager } = require_GuildSoundboardSoundManager();
  var GuildStickerManager = require_GuildStickerManager();
  var PresenceManager = require_PresenceManager();
  var RoleManager = require_RoleManager();
  var StageInstanceManager = require_StageInstanceManager();
  var VoiceStateManager = require_VoiceStateManager();
  var { resolveImage } = require_DataResolver();
  var Status = require_Status();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { _transformAPIIncidentsData } = require_Transformers();
  var { discordSort, getSortableGroupTypes, resolvePartialEmoji } = require_Util();

  class Guild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data, false);
      this.commands = new GuildApplicationCommandManager(this);
      this.members = new GuildMemberManager(this);
      this.channels = new GuildChannelManager(this);
      this.bans = new GuildBanManager(this);
      this.roles = new RoleManager(this);
      this.presences = new PresenceManager(this.client);
      this.voiceStates = new VoiceStateManager(this);
      this.stageInstances = new StageInstanceManager(this);
      this.invites = new GuildInviteManager(this);
      this.scheduledEvents = new GuildScheduledEventManager(this);
      this.autoModerationRules = new AutoModerationRuleManager(this);
      this.soundboardSounds = new GuildSoundboardSoundManager(this);
      if (!data)
        return;
      if (data.unavailable) {
        this.available = false;
      } else {
        this._patch(data);
        if (!data.channels)
          this.available = false;
      }
      this.shardId = data.shardId;
    }
    get shard() {
      return this.client.ws.shards.get(this.shardId);
    }
    _patch(data) {
      super._patch(data);
      this.id = data.id;
      if ("name" in data)
        this.name = data.name;
      if ("icon" in data)
        this.icon = data.icon;
      if ("unavailable" in data) {
        this.available = !data.unavailable;
      } else {
        this.available ??= true;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      }
      if ("large" in data) {
        this.large = Boolean(data.large);
      }
      if ("premium_progress_bar_enabled" in data) {
        this.premiumProgressBarEnabled = data.premium_progress_bar_enabled;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      }
      if ("afk_timeout" in data) {
        this.afkTimeout = data.afk_timeout;
      }
      if ("afk_channel_id" in data) {
        this.afkChannelId = data.afk_channel_id;
      }
      if ("system_channel_id" in data) {
        this.systemChannelId = data.system_channel_id;
      }
      if ("premium_tier" in data) {
        this.premiumTier = data.premium_tier;
      }
      if ("widget_enabled" in data) {
        this.widgetEnabled = data.widget_enabled;
      } else {
        this.widgetEnabled ??= null;
      }
      if ("widget_channel_id" in data) {
        this.widgetChannelId = data.widget_channel_id;
      } else {
        this.widgetChannelId ??= null;
      }
      if ("explicit_content_filter" in data) {
        this.explicitContentFilter = data.explicit_content_filter;
      }
      if ("mfa_level" in data) {
        this.mfaLevel = data.mfa_level;
      }
      if ("joined_at" in data) {
        this.joinedTimestamp = Date.parse(data.joined_at);
      }
      if ("default_message_notifications" in data) {
        this.defaultMessageNotifications = data.default_message_notifications;
      }
      if ("system_channel_flags" in data) {
        this.systemChannelFlags = new SystemChannelFlagsBitField(data.system_channel_flags).freeze();
      }
      if ("max_members" in data) {
        this.maximumMembers = data.max_members;
      } else {
        this.maximumMembers ??= null;
      }
      if ("max_presences" in data) {
        this.maximumPresences = data.max_presences;
      } else {
        this.maximumPresences ??= null;
      }
      if ("max_video_channel_users" in data) {
        this.maxVideoChannelUsers = data.max_video_channel_users;
      } else {
        this.maxVideoChannelUsers ??= null;
      }
      if ("max_stage_video_channel_users" in data) {
        this.maxStageVideoChannelUsers = data.max_stage_video_channel_users;
      } else {
        this.maxStageVideoChannelUsers ??= null;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      } else {
        this.approximateMemberCount ??= null;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      } else {
        this.approximatePresenceCount ??= null;
      }
      this.vanityURLUses ??= null;
      if ("rules_channel_id" in data) {
        this.rulesChannelId = data.rules_channel_id;
      }
      if ("public_updates_channel_id" in data) {
        this.publicUpdatesChannelId = data.public_updates_channel_id;
      }
      if ("preferred_locale" in data) {
        this.preferredLocale = data.preferred_locale;
      }
      if ("safety_alerts_channel_id" in data) {
        this.safetyAlertsChannelId = data.safety_alerts_channel_id;
      } else {
        this.safetyAlertsChannelId ??= null;
      }
      if (data.channels) {
        this.channels.cache.clear();
        for (const rawChannel of data.channels) {
          this.client.channels._add(rawChannel, this);
        }
      }
      if (data.threads) {
        for (const rawThread of data.threads) {
          this.client.channels._add(rawThread, this);
        }
      }
      if (data.roles) {
        this.roles.cache.clear();
        for (const role of data.roles)
          this.roles._add(role);
      }
      if (data.members) {
        this.members.cache.clear();
        for (const guildUser of data.members)
          this.members._add(guildUser);
      }
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      }
      if (data.presences) {
        for (const presence of data.presences) {
          this.presences._add(Object.assign(presence, { guild: this }));
        }
      }
      if (data.stage_instances) {
        this.stageInstances.cache.clear();
        for (const stageInstance of data.stage_instances) {
          this.stageInstances._add(stageInstance);
        }
      }
      if (data.guild_scheduled_events) {
        this.scheduledEvents.cache.clear();
        for (const scheduledEvent of data.guild_scheduled_events) {
          this.scheduledEvents._add(scheduledEvent);
        }
      }
      if (data.voice_states) {
        this.voiceStates.cache.clear();
        for (const voiceState of data.voice_states) {
          this.voiceStates._add(voiceState);
        }
      }
      if (!this.emojis) {
        this.emojis = new GuildEmojiManager(this);
        if (data.emojis)
          for (const emoji of data.emojis)
            this.emojis._add(emoji);
      } else if (data.emojis) {
        this.client.actions.GuildEmojisUpdate.handle({
          guild_id: this.id,
          emojis: data.emojis
        });
      }
      if (!this.stickers) {
        this.stickers = new GuildStickerManager(this);
        if (data.stickers)
          for (const sticker of data.stickers)
            this.stickers._add(sticker);
      } else if (data.stickers) {
        this.client.actions.GuildStickersUpdate.handle({
          guild_id: this.id,
          stickers: data.stickers
        });
      }
      if ("incidents_data" in data) {
        this.incidentsData = data.incidents_data && _transformAPIIncidentsData(data.incidents_data);
      } else {
        this.incidentsData ??= null;
      }
      if (data.soundboard_sounds) {
        this.soundboardSounds.cache.clear();
        for (const soundboardSound of data.soundboard_sounds) {
          this.soundboardSounds._add(soundboardSound);
        }
      }
    }
    get joinedAt() {
      return new Date(this.joinedTimestamp);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    async fetchOwner(options) {
      if (!this.ownerId) {
        throw new DiscordjsError(ErrorCodes.FetchOwnerId, "guild");
      }
      const member = await this.members.fetch({ ...options, user: this.ownerId });
      return member;
    }
    get afkChannel() {
      return this.client.channels.resolve(this.afkChannelId);
    }
    get systemChannel() {
      return this.client.channels.resolve(this.systemChannelId);
    }
    get widgetChannel() {
      return this.client.channels.resolve(this.widgetChannelId);
    }
    get rulesChannel() {
      return this.client.channels.resolve(this.rulesChannelId);
    }
    get publicUpdatesChannel() {
      return this.client.channels.resolve(this.publicUpdatesChannelId);
    }
    get safetyAlertsChannel() {
      return this.client.channels.resolve(this.safetyAlertsChannelId);
    }
    get maximumBitrate() {
      if (this.features.includes(GuildFeature.VIPRegions)) {
        return 384000;
      }
      switch (this.premiumTier) {
        case GuildPremiumTier.Tier1:
          return 128000;
        case GuildPremiumTier.Tier2:
          return 256000;
        case GuildPremiumTier.Tier3:
          return 384000;
        default:
          return 96000;
      }
    }
    async fetchIntegrations() {
      const data = await this.client.rest.get(Routes.guildIntegrations(this.id));
      return data.reduce((collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)), new Collection);
    }
    async fetchTemplates() {
      const templates = await this.client.rest.get(Routes.guildTemplates(this.id));
      return templates.reduce((col, data) => col.set(data.code, new GuildTemplate(this.client, data)), new Collection);
    }
    async fetchWelcomeScreen() {
      const data = await this.client.rest.get(Routes.guildWelcomeScreen(this.id));
      return new WelcomeScreen(this, data);
    }
    async createTemplate(name, description) {
      const data = await this.client.rest.post(Routes.guildTemplates(this.id), { body: { name, description } });
      return new GuildTemplate(this.client, data);
    }
    async fetchPreview() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      return new GuildPreview(this.client, data);
    }
    async fetchVanityData() {
      const data = await this.client.rest.get(Routes.guildVanityUrl(this.id));
      this.vanityURLCode = data.code;
      this.vanityURLUses = data.uses;
      return data;
    }
    async fetchWebhooks() {
      const apiHooks = await this.client.rest.get(Routes.guildWebhooks(this.id));
      const hooks = new Collection;
      for (const hook of apiHooks)
        hooks.set(hook.id, new Webhook(this.client, hook));
      return hooks;
    }
    fetchWidget() {
      return this.client.fetchGuildWidget(this.id);
    }
    async fetchWidgetSettings() {
      const data = await this.client.rest.get(Routes.guildWidgetSettings(this.id));
      this.widgetEnabled = data.enabled;
      this.widgetChannelId = data.channel_id;
      return {
        enabled: data.enabled,
        channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
      };
    }
    widgetImageURL(style) {
      return this.client.guilds.widgetImageURL(this.id, style);
    }
    async fetchAuditLogs({ before, after, limit, user, type } = {}) {
      const query = makeURLSearchParams({
        before: before?.id ?? before,
        after: after?.id ?? after,
        limit,
        action_type: type
      });
      if (user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
        query.set("user_id", userId);
      }
      const data = await this.client.rest.get(Routes.guildAuditLog(this.id), { query });
      return new GuildAuditLogs(this, data);
    }
    async fetchOnboarding() {
      const data = await this.client.rest.get(Routes.guildOnboarding(this.id));
      return new GuildOnboarding(this.client, data);
    }
    async edit({
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      afkChannel,
      afkTimeout,
      icon,
      owner,
      splash,
      discoverySplash,
      banner,
      systemChannel,
      systemChannelFlags,
      rulesChannel,
      publicUpdatesChannel,
      preferredLocale,
      premiumProgressBarEnabled,
      safetyAlertsChannel,
      ...options
    }) {
      const data = await this.client.rest.patch(Routes.guild(this.id), {
        body: {
          ...options,
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          afk_channel_id: afkChannel && this.client.channels.resolveId(afkChannel),
          afk_timeout: afkTimeout,
          icon: icon && await resolveImage(icon),
          owner_id: owner && this.client.users.resolveId(owner),
          splash: splash && await resolveImage(splash),
          discovery_splash: discoverySplash && await resolveImage(discoverySplash),
          banner: banner && await resolveImage(banner),
          system_channel_id: systemChannel && this.client.channels.resolveId(systemChannel),
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags),
          rules_channel_id: rulesChannel && this.client.channels.resolveId(rulesChannel),
          public_updates_channel_id: publicUpdatesChannel && this.client.channels.resolveId(publicUpdatesChannel),
          preferred_locale: preferredLocale,
          premium_progress_bar_enabled: premiumProgressBarEnabled,
          safety_alerts_channel_id: safetyAlertsChannel && this.client.channels.resolveId(safetyAlertsChannel)
        },
        reason: options.reason
      });
      return this.client.actions.GuildUpdate.handle(data).updated;
    }
    async editOnboarding(options) {
      const newData = await this.client.rest.put(Routes.guildOnboarding(this.id), {
        body: {
          prompts: options.prompts?.map((prompt) => ({
            id: prompt.id ?? DiscordSnowflake.generate().toString(),
            title: prompt.title,
            single_select: prompt.singleSelect,
            required: prompt.required,
            in_onboarding: prompt.inOnboarding,
            type: prompt.type,
            options: prompt.options.map((option) => {
              const emoji = resolvePartialEmoji(option.emoji);
              return {
                id: option.id,
                channel_ids: option.channels?.map((channel) => this.channels.resolveId(channel)),
                role_ids: option.roles?.map((role) => this.roles.resolveId(role)),
                title: option.title,
                description: option.description,
                emoji_animated: emoji?.animated,
                emoji_id: emoji?.id,
                emoji_name: emoji?.name
              };
            })
          })),
          default_channel_ids: options.defaultChannels?.map((channel) => this.channels.resolveId(channel)),
          enabled: options.enabled,
          mode: options.mode
        },
        reason: options.reason
      });
      return new GuildOnboarding(this.client, newData);
    }
    async editWelcomeScreen(options) {
      const { enabled, description, welcomeChannels } = options;
      const welcome_channels = welcomeChannels?.map((welcomeChannelData) => {
        const emoji = this.emojis.resolve(welcomeChannelData.emoji);
        return {
          emoji_id: emoji?.id,
          emoji_name: emoji?.name ?? welcomeChannelData.emoji,
          channel_id: this.channels.resolveId(welcomeChannelData.channel),
          description: welcomeChannelData.description
        };
      });
      const patchData = await this.client.rest.patch(Routes.guildWelcomeScreen(this.id), {
        body: {
          welcome_channels,
          description,
          enabled
        }
      });
      return new WelcomeScreen(this, patchData);
    }
    setExplicitContentFilter(explicitContentFilter, reason) {
      return this.edit({ explicitContentFilter, reason });
    }
    setDefaultMessageNotifications(defaultMessageNotifications, reason) {
      return this.edit({ defaultMessageNotifications, reason });
    }
    setSystemChannelFlags(systemChannelFlags, reason) {
      return this.edit({ systemChannelFlags, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setVerificationLevel(verificationLevel, reason) {
      return this.edit({ verificationLevel, reason });
    }
    setAFKChannel(afkChannel, reason) {
      return this.edit({ afkChannel, reason });
    }
    setSystemChannel(systemChannel, reason) {
      return this.edit({ systemChannel, reason });
    }
    setAFKTimeout(afkTimeout, reason) {
      return this.edit({ afkTimeout, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setOwner(owner, reason) {
      return this.edit({ owner, reason });
    }
    setSplash(splash, reason) {
      return this.edit({ splash, reason });
    }
    setDiscoverySplash(discoverySplash, reason) {
      return this.edit({ discoverySplash, reason });
    }
    setBanner(banner, reason) {
      return this.edit({ banner, reason });
    }
    setRulesChannel(rulesChannel, reason) {
      return this.edit({ rulesChannel, reason });
    }
    setPublicUpdatesChannel(publicUpdatesChannel, reason) {
      return this.edit({ publicUpdatesChannel, reason });
    }
    setPreferredLocale(preferredLocale, reason) {
      return this.edit({ preferredLocale, reason });
    }
    setPremiumProgressBarEnabled(enabled = true, reason) {
      return this.edit({ premiumProgressBarEnabled: enabled, reason });
    }
    setSafetyAlertsChannel(safetyAlertsChannel, reason) {
      return this.edit({ safetyAlertsChannel, reason });
    }
    async setWidgetSettings(settings, reason) {
      await this.client.rest.patch(Routes.guildWidgetSettings(this.id), {
        body: {
          enabled: settings.enabled,
          channel_id: this.channels.resolveId(settings.channel)
        },
        reason
      });
      return this;
    }
    async setMFALevel(level, reason) {
      await this.client.rest.post(Routes.guildMFA(this.id), {
        body: {
          level
        },
        reason
      });
      return this;
    }
    async leave() {
      if (this.ownerId === this.client.user.id)
        throw new DiscordjsError(ErrorCodes.GuildOwned);
      await this.client.rest.delete(Routes.userGuild(this.id));
      return this;
    }
    async delete() {
      await this.client.rest.delete(Routes.guild(this.id));
      return this;
    }
    async disableInvites(disabled = true) {
      const features = this.features.filter((feature) => feature !== GuildFeature.InvitesDisabled);
      if (disabled)
        features.push(GuildFeature.InvitesDisabled);
      return this.edit({ features });
    }
    async setIncidentActions(incidentActions) {
      return this.client.guilds.setIncidentActions(this.id, incidentActions);
    }
    equals(guild) {
      return guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerId === guild.ownerId && this.verificationLevel === guild.verificationLevel && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
    }
    toJSON() {
      const json = super.toJSON({
        available: false,
        createdTimestamp: true,
        nameAcronym: true,
        presences: false,
        voiceStates: false
      });
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      json.discoverySplashURL = this.discoverySplashURL();
      json.bannerURL = this.bannerURL();
      return json;
    }
    get voiceAdapterCreator() {
      return (methods) => {
        this.client.voice.adapters.set(this.id, methods);
        return {
          sendPayload: (data) => {
            if (this.shard.status !== Status.Ready)
              return false;
            this.shard.send(data);
            return true;
          },
          destroy: () => {
            this.client.voice.adapters.delete(this.id);
          }
        };
      };
    }
    _sortedRoles() {
      return discordSort(this.roles.cache);
    }
    _sortedChannels(channel) {
      const channelIsCategory = channel.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(channel.type);
      return discordSort(this.channels.cache.filter(({ parentId, type }) => types.includes(type) && (channelIsCategory || parentId === channel.parentId)));
    }
  }
  exports.Guild = Guild;
});

// ../../node_modules/discord.js/src/structures/OAuth2Guild.js
var require_OAuth2Guild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();
  var PermissionsBitField = require_PermissionsBitField();

  class OAuth2Guild extends BaseGuild {
    constructor(client, data) {
      super(client, data);
      this.owner = data.owner;
      this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
    }
  }
  module.exports = OAuth2Guild;
});

// ../../node_modules/discord.js/src/managers/GuildManager.js
var require_GuildManager = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("timers");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { GatewayOpcodes, Routes, RouteBases } = require_v106();
  var CachedManager = require_CachedManager();
  var { ErrorCodes, DiscordjsError } = require_errors();
  var ShardClientUtil = require_ShardClientUtil();
  var { Guild } = require_Guild();
  var GuildChannel = require_GuildChannel();
  var GuildEmoji = require_GuildEmoji();
  var { GuildMember } = require_GuildMember();
  var Invite = require_Invite();
  var OAuth2Guild = require_OAuth2Guild();
  var { Role } = require_Role();
  var { resolveImage } = require_DataResolver();
  var Events = require_Events();
  var PermissionsBitField = require_PermissionsBitField();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { _transformAPIIncidentsData } = require_Transformers();
  var { resolveColor } = require_Util();
  var cacheWarningEmitted = false;

  class GuildManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Guild, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    resolve(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolve(guild.guild);
      }
      return super.resolve(guild);
    }
    resolveId(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolveId(guild.guild.id);
      }
      return super.resolveId(guild);
    }
    async create({
      name,
      icon = null,
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      roles = [],
      channels = [],
      afkChannelId,
      afkTimeout,
      systemChannelId,
      systemChannelFlags
    }) {
      const data = await this.client.rest.post(Routes.guilds(), {
        body: {
          name,
          icon: icon && await resolveImage(icon),
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          roles: roles.map(({ color, permissions, ...options }) => ({
            ...options,
            color: color && resolveColor(color),
            permissions: permissions === undefined ? undefined : PermissionsBitField.resolve(permissions).toString()
          })),
          channels: channels.map(({
            parentId,
            userLimit,
            rtcRegion,
            videoQualityMode,
            permissionOverwrites,
            rateLimitPerUser,
            ...options
          }) => ({
            ...options,
            parent_id: parentId,
            user_limit: userLimit,
            rtc_region: rtcRegion,
            video_quality_mode: videoQualityMode,
            permission_overwrites: permissionOverwrites?.map(({ allow, deny, ...permissionOverwriteOptions }) => ({
              ...permissionOverwriteOptions,
              allow: allow === undefined ? undefined : PermissionsBitField.resolve(allow).toString(),
              deny: deny === undefined ? undefined : PermissionsBitField.resolve(deny).toString()
            })),
            rate_limit_per_user: rateLimitPerUser
          })),
          afk_channel_id: afkChannelId,
          afk_timeout: afkTimeout,
          system_channel_id: systemChannelId,
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags)
        }
      });
      return this.client.guilds.cache.get(data.id) ?? new Promise((resolve) => {
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            this.client.decrementMaxListeners();
            resolve(guild);
          }
        };
        this.client.incrementMaxListeners();
        this.client.once(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildCreate, handleGuild);
          this.client.decrementMaxListeners();
          resolve(this.client.guilds._add(data));
        }, 1e4).unref();
      });
    }
    async fetch(options = {}) {
      const id = this.resolveId(options) ?? this.resolveId(options.guild);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guild(id), {
          query: makeURLSearchParams({ with_counts: options.withCounts ?? true })
        });
        data2.shardId = ShardClientUtil.shardIdForGuildId(id, this.client.options.shardCount);
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.userGuilds(), { query: makeURLSearchParams(options) });
      return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection);
    }
    async fetchSoundboardSounds({ guildIds, time = 1e4 }) {
      const shardCount = this.client.options.shardCount;
      const shardIds = new Map;
      for (const guildId of guildIds) {
        const shardId = ShardClientUtil.shardIdForGuildId(guildId, shardCount);
        const group = shardIds.get(shardId);
        if (group)
          group.push(guildId);
        else
          shardIds.set(shardId, [guildId]);
      }
      for (const [shardId, shardGuildIds] of shardIds) {
        this.client.ws.shards.get(shardId).send({
          op: GatewayOpcodes.RequestSoundboardSounds,
          d: {
            guild_ids: shardGuildIds
          }
        });
      }
      return new Promise((resolve, reject) => {
        const remainingGuildIds = new Set(guildIds);
        const fetchedSoundboardSounds = new Collection;
        const handler = (soundboardSounds, guild) => {
          timeout.refresh();
          if (!remainingGuildIds.has(guild.id))
            return;
          fetchedSoundboardSounds.set(guild.id, soundboardSounds);
          remainingGuildIds.delete(guild.id);
          if (remainingGuildIds.size === 0) {
            clearTimeout2(timeout);
            this.client.removeListener(Events.SoundboardSounds, handler);
            this.client.decrementMaxListeners();
            resolve(fetchedSoundboardSounds);
          }
        };
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.SoundboardSounds, handler);
          this.client.decrementMaxListeners();
          reject(new DiscordjsError(ErrorCodes.GuildSoundboardSoundsTimeout));
        }, time).unref();
        this.client.incrementMaxListeners();
        this.client.on(Events.SoundboardSounds, handler);
      });
    }
    async setIncidentActions(guild, { invitesDisabledUntil, dmsDisabledUntil }) {
      const guildId = this.resolveId(guild);
      const data = await this.client.rest.put(Routes.guildIncidentActions(guildId), {
        body: {
          invites_disabled_until: invitesDisabledUntil && new Date(invitesDisabledUntil).toISOString(),
          dms_disabled_until: dmsDisabledUntil && new Date(dmsDisabledUntil).toISOString()
        }
      });
      const parsedData = _transformAPIIncidentsData(data);
      const resolvedGuild = this.resolve(guild);
      if (resolvedGuild) {
        resolvedGuild.incidentsData = parsedData;
      }
      return parsedData;
    }
    widgetImageURL(guild, style) {
      const urlSearchParams = String(makeURLSearchParams({ style }));
      return `${RouteBases.api}${Routes.guildWidgetImage(this.resolveId(guild))}${urlSearchParams ? `?${urlSearchParams}` : ""}`;
    }
  }
  module.exports = GuildManager;
});

// ../../node_modules/discord.js/src/managers/UserManager.js
var require_UserManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors();
  var { GuildMember } = require_GuildMember();
  var { Message } = require_Message();
  var ThreadMember = require_ThreadMember();
  var User = require_User();
  var { emitDeprecationWarningForUserFetchFlags } = require_Util();

  class UserManager extends CachedManager {
    constructor(client, iterable) {
      super(client, User, iterable);
    }
    dmChannel(userId) {
      return this.client.channels.cache.find((channel) => channel.type === ChannelType.DM && channel.recipientId === userId) ?? null;
    }
    async createDM(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const dmChannel = this.dmChannel(id);
        if (dmChannel && !dmChannel.partial)
          return dmChannel;
      }
      const data = await this.client.rest.post(Routes.userChannels(), { body: { recipient_id: id } });
      return this.client.channels._add(data, null, { cache });
    }
    async deleteDM(user) {
      const id = this.resolveId(user);
      const dmChannel = this.dmChannel(id);
      if (!dmChannel)
        throw new DiscordjsError(ErrorCodes.UserNoDMChannel);
      await this.client.rest.delete(Routes.channel(dmChannel.id));
      this.client.channels._remove(dmChannel.id);
      return dmChannel;
    }
    async fetch(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.user(id));
      return this._add(data, cache);
    }
    async fetchFlags(user, options) {
      emitDeprecationWarningForUserFetchFlags(this.constructor.name);
      return (await this.fetch(user, options)).flags;
    }
    async send(user, options) {
      return (await this.createDM(user)).send(options);
    }
    resolve(user) {
      if (user instanceof GuildMember || user instanceof ThreadMember)
        return user.user;
      if (user instanceof Message)
        return user.author;
      return super.resolve(user);
    }
    resolveId(user) {
      if (user instanceof ThreadMember)
        return user.id;
      if (user instanceof GuildMember)
        return user.user.id;
      if (user instanceof Message)
        return user.author.id;
      return super.resolveId(user);
    }
  }
  module.exports = UserManager;
});

// ../../node_modules/discord.js/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS((exports, module) => {
  var { GatewayOpcodes, ActivityType } = require_v106();
  var { Presence } = require_Presence();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class ClientPresence extends Presence {
    constructor(client, data = {}) {
      super(client, Object.assign(data, { status: data.status ?? "online", user: { id: null } }));
    }
    set(presence) {
      const packet = this._parse(presence);
      this._patch(packet);
      if (presence.shardId === undefined) {
        this.client.ws.broadcast({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      } else if (Array.isArray(presence.shardId)) {
        for (const shardId of presence.shardId) {
          this.client.ws.shards.get(shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        }
      } else {
        this.client.ws.shards.get(presence.shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      }
      return this;
    }
    _parse({ status, since, afk, activities }) {
      const data = {
        activities: [],
        afk: typeof afk === "boolean" ? afk : false,
        since: typeof since === "number" && !Number.isNaN(since) ? since : null,
        status: status ?? this.status
      };
      if (activities?.length) {
        for (const [i, activity] of activities.entries()) {
          if (typeof activity.name !== "string") {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, `activities[${i}].name`, "string");
          }
          activity.type ??= ActivityType.Playing;
          if (activity.type === ActivityType.Custom && !activity.state) {
            activity.state = activity.name;
            activity.name = "Custom Status";
          }
          data.activities.push({
            type: activity.type,
            name: activity.name,
            state: activity.state,
            url: activity.url
          });
        }
      } else if (!activities && (status || afk || since) && this.activities.length) {
        data.activities.push(...this.activities.map((activity) => ({
          name: activity.name,
          state: activity.state ?? undefined,
          type: activity.type,
          url: activity.url ?? undefined
        })));
      }
      return data;
    }
  }
  module.exports = ClientPresence;
});

// ../../node_modules/discord.js/src/structures/StickerPack.js
var require_StickerPack = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { DiscordSnowflake } = require_cjs();
  var Base = require_Base();
  var { Sticker } = require_Sticker();

  class StickerPack extends Base {
    constructor(client, pack) {
      super(client);
      this.id = pack.id;
      this.stickers = new Collection(pack.stickers.map((sticker) => [sticker.id, new Sticker(client, sticker)]));
      this.name = pack.name;
      this.skuId = pack.sku_id;
      this.coverStickerId = pack.cover_sticker_id ?? null;
      this.description = pack.description;
      this.bannerId = pack.banner_asset_id ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get coverSticker() {
      return this.coverStickerId && this.stickers.get(this.coverStickerId);
    }
    bannerURL(options = {}) {
      return this.bannerId && this.client.rest.cdn.stickerPackBanner(this.bannerId, options);
    }
  }
  module.exports = StickerPack;
});

// ../../node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class VoiceRegion {
    constructor(data) {
      this.id = data.id;
      this.name = data.name;
      this.deprecated = data.deprecated;
      this.optimal = data.optimal;
      this.custom = data.custom;
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = VoiceRegion;
});

// ../../node_modules/discord.js/src/structures/WidgetMember.js
var require_WidgetMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class WidgetMember extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.username = data.username;
      this.discriminator = data.discriminator;
      this.avatar = data.avatar;
      this.status = data.status;
      this.deaf = data.deaf ?? null;
      this.mute = data.mute ?? null;
      this.selfDeaf = data.self_deaf ?? null;
      this.selfMute = data.self_mute ?? null;
      this.suppress = data.suppress ?? null;
      this.channelId = data.channel_id ?? null;
      this.avatarURL = data.avatar_url;
      this.activity = data.activity ?? null;
    }
  }
  module.exports = WidgetMember;
});

// ../../node_modules/discord.js/src/structures/Widget.js
var require_Widget = __commonJS((exports, module) => {
  var { Collection } = require_dist6();
  var { Routes } = require_v106();
  var Base = require_Base();
  var WidgetMember = require_WidgetMember();

  class Widget extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("instant_invite" in data) {
        this.instantInvite = data.instant_invite;
      }
      this.channels = new Collection;
      for (const channel of data.channels) {
        this.channels.set(channel.id, channel);
      }
      this.members = new Collection;
      for (const member of data.members) {
        this.members.set(member.id, new WidgetMember(this.client, member));
      }
      if ("presence_count" in data) {
        this.presenceCount = data.presence_count;
      }
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildWidgetJSON(this.id));
      this._patch(data);
      return this;
    }
    imageURL(style) {
      return this.client.guilds.widgetImageURL(this.id, style);
    }
  }
  module.exports = Widget;
});

// ../../node_modules/discord.js/src/util/IntentsBitField.js
var require_IntentsBitField = __commonJS((exports, module) => {
  var { GatewayIntentBits } = require_v106();
  var BitField = require_BitField();

  class IntentsBitField extends BitField {
    static Flags = GatewayIntentBits;
  }
  module.exports = IntentsBitField;
});

// ../../node_modules/discord.js/src/util/Sweepers.js
var require_Sweepers = __commonJS((exports, module) => {
  var { setInterval: setInterval2, clearInterval: clearInterval2 } = __require("timers");
  var { ThreadChannelTypes, SweeperKeys } = require_Constants();
  var Events = require_Events();
  var { DiscordjsTypeError, ErrorCodes } = require_errors();

  class Sweepers {
    constructor(client, options) {
      Object.defineProperty(this, "client", { value: client });
      this.options = options;
      this.intervals = Object.fromEntries(SweeperKeys.map((key) => [key, null]));
      for (const key of SweeperKeys) {
        if (!(key in options))
          continue;
        this._validateProperties(key);
        const clonedOptions = { ...this.options[key] };
        if (!("filter" in clonedOptions)) {
          switch (key) {
            case "invites":
              clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);
              break;
            case "messages":
              clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);
              break;
            case "threads":
              clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);
          }
        }
        this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);
      }
    }
    sweepApplicationCommands(filter) {
      const { guilds, items: guildCommands } = this._sweepGuildDirectProp("commands", filter, { emit: false });
      const globalCommands = this.client.application?.commands.cache.sweep(filter) ?? 0;
      this.client.emit(Events.CacheSweep, `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`);
      return guildCommands + globalCommands;
    }
    sweepAutoModerationRules(filter) {
      return this._sweepGuildDirectProp("autoModerationRules", filter).items;
    }
    sweepBans(filter) {
      return this._sweepGuildDirectProp("bans", filter).items;
    }
    sweepEmojis(filter) {
      return this._sweepGuildDirectProp("emojis", filter).items;
    }
    sweepEntitlements(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      const entitlements = this.client.application.entitlements.cache.sweep(filter);
      this.client.emit(Events.CacheSweep, `Swept ${entitlements} entitlements.`);
      return entitlements;
    }
    sweepInvites(filter) {
      return this._sweepGuildDirectProp("invites", filter).items;
    }
    sweepGuildMembers(filter) {
      return this._sweepGuildDirectProp("members", filter, { outputName: "guild members" }).items;
    }
    sweepMessages(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        messages += channel.messages.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);
      return messages;
    }
    sweepPresences(filter) {
      return this._sweepGuildDirectProp("presences", filter).items;
    }
    sweepReactions(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      let reactions = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        for (const message of channel.messages.cache.values()) {
          messages++;
          reactions += message.reactions.cache.sweep(filter);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`);
      return reactions;
    }
    sweepStageInstances(filter) {
      return this._sweepGuildDirectProp("stageInstances", filter, { outputName: "stage instances" }).items;
    }
    sweepStickers(filter) {
      return this._sweepGuildDirectProp("stickers", filter).items;
    }
    sweepThreadMembers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      let members = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!ThreadChannelTypes.includes(channel.type))
          continue;
        threads++;
        members += channel.members.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);
      return members;
    }
    sweepThreads(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      for (const [key, val] of this.client.channels.cache.entries()) {
        if (!ThreadChannelTypes.includes(val.type))
          continue;
        if (filter(val, key, this.client.channels.cache)) {
          threads++;
          this.client.channels._remove(key);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${threads} threads.`);
      return threads;
    }
    sweepUsers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      const users = this.client.users.cache.sweep(filter);
      this.client.emit(Events.CacheSweep, `Swept ${users} users.`);
      return users;
    }
    sweepVoiceStates(filter) {
      return this._sweepGuildDirectProp("voiceStates", filter, { outputName: "voice states" }).items;
    }
    destroy() {
      for (const key of SweeperKeys) {
        if (this.intervals[key])
          clearInterval2(this.intervals[key]);
      }
    }
    static filterByLifetime({
      lifetime = 14400,
      getComparisonTimestamp = (e) => e?.createdTimestamp,
      excludeFromSweep = () => false
    } = {}) {
      if (typeof lifetime !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "lifetime", "number");
      }
      if (typeof getComparisonTimestamp !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "getComparisonTimestamp", "function");
      }
      if (typeof excludeFromSweep !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "excludeFromSweep", "function");
      }
      return () => {
        if (lifetime <= 0)
          return null;
        const lifetimeMs = lifetime * 1000;
        const now = Date.now();
        return (entry, key, coll) => {
          if (excludeFromSweep(entry, key, coll)) {
            return false;
          }
          const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);
          if (!comparisonTimestamp || typeof comparisonTimestamp !== "number")
            return false;
          return now - comparisonTimestamp > lifetimeMs;
        };
      };
    }
    static archivedThreadSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (e) => e.archiveTimestamp,
        excludeFromSweep: (e) => !e.archived
      });
    }
    static expiredInviteSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (i) => i.expiresTimestamp
      });
    }
    static outdatedMessageSweepFilter(lifetime = 3600) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (m) => m.editedTimestamp ?? m.createdTimestamp
      });
    }
    _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let guilds = 0;
      let items = 0;
      for (const guild of this.client.guilds.cache.values()) {
        if (!guild.available)
          continue;
        const { cache } = guild[key];
        guilds++;
        items += cache.sweep(filter);
      }
      if (emit) {
        this.client.emit(Events.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);
      }
      return { guilds, items };
    }
    _validateProperties(key) {
      const props = this.options[key];
      if (typeof props !== "object") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}`, "object", true);
      }
      if (typeof props.interval !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.interval`, "number");
      }
      if (["invites", "messages", "threads"].includes(key) && !("filter" in props)) {
        if (typeof props.lifetime !== "number") {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.lifetime`, "number");
        }
        return;
      }
      if (typeof props.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.filter`, "function");
      }
    }
    _initInterval(intervalKey, sweepKey, opts) {
      if (opts.interval <= 0 || opts.interval === Infinity)
        return;
      this.intervals[intervalKey] = setInterval2(() => {
        const sweepFn = opts.filter();
        if (sweepFn === null)
          return;
        if (typeof sweepFn !== "function")
          throw new DiscordjsTypeError(ErrorCodes.SweepFilterReturn);
        this[sweepKey](sweepFn);
      }, opts.interval * 1000).unref();
    }
  }
  module.exports = Sweepers;
});

// ../../node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS((exports, module) => {
  var process2 = __require("process");
  var { Collection } = require_dist6();
  var { makeURLSearchParams } = require_dist5();
  var { OAuth2Scopes, Routes } = require_v106();
  var BaseClient = require_BaseClient();
  var ActionsManager = require_ActionsManager();
  var ClientVoiceManager = require_ClientVoiceManager();
  var WebSocketManager = require_WebSocketManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var ChannelManager = require_ChannelManager();
  var GuildManager = require_GuildManager();
  var UserManager = require_UserManager();
  var ShardClientUtil = require_ShardClientUtil();
  var ClientPresence = require_ClientPresence();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Invite = require_Invite();
  var { SoundboardSound } = require_SoundboardSound();
  var { Sticker } = require_Sticker();
  var StickerPack = require_StickerPack();
  var VoiceRegion = require_VoiceRegion();
  var Webhook = require_Webhook();
  var Widget = require_Widget();
  var { resolveInviteCode, resolveGuildTemplateCode } = require_DataResolver();
  var Events = require_Events();
  var IntentsBitField = require_IntentsBitField();
  var Options = require_Options();
  var PermissionsBitField = require_PermissionsBitField();
  var Status = require_Status();
  var Sweepers = require_Sweepers();
  var deprecationEmittedForPremiumStickerPacks = false;

  class Client extends BaseClient {
    constructor(options) {
      super(options);
      const data = __require("worker_threads").workerData ?? process2.env;
      const defaults = Options.createDefault();
      if (this.options.shards === defaults.shards) {
        if ("SHARDS" in data) {
          this.options.shards = JSON.parse(data.SHARDS);
        }
      }
      if (this.options.shardCount === defaults.shardCount) {
        if ("SHARD_COUNT" in data) {
          this.options.shardCount = Number(data.SHARD_COUNT);
        } else if (Array.isArray(this.options.shards)) {
          this.options.shardCount = this.options.shards.length;
        }
      }
      const typeofShards = typeof this.options.shards;
      if (typeofShards === "undefined" && typeof this.options.shardCount === "number") {
        this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);
      }
      if (typeofShards === "number")
        this.options.shards = [this.options.shards];
      if (Array.isArray(this.options.shards)) {
        this.options.shards = [
          ...new Set(this.options.shards.filter((item) => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)))
        ];
      }
      this._validateOptions();
      this.ws = new WebSocketManager(this);
      this.actions = new ActionsManager(this);
      this.voice = new ClientVoiceManager(this);
      this.shard = process2.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process2.env.SHARDING_MANAGER_MODE) : null;
      this.users = new UserManager(this);
      this.guilds = new GuildManager(this);
      this.channels = new ChannelManager(this);
      this.sweepers = new Sweepers(this, this.options.sweepers);
      this.presence = new ClientPresence(this, this.options.presence);
      Object.defineProperty(this, "token", { writable: true });
      if (!this.token && "DISCORD_TOKEN" in process2.env) {
        this.token = process2.env.DISCORD_TOKEN;
      } else {
        this.token = null;
      }
      this.user = null;
      this.application = null;
      this.readyTimestamp = null;
    }
    get emojis() {
      const emojis = new BaseGuildEmojiManager(this);
      for (const guild of this.guilds.cache.values()) {
        if (guild.available)
          for (const emoji of guild.emojis.cache.values())
            emojis.cache.set(emoji.id, emoji);
      }
      return emojis;
    }
    get readyAt() {
      return this.readyTimestamp && new Date(this.readyTimestamp);
    }
    get uptime() {
      return this.readyTimestamp && Date.now() - this.readyTimestamp;
    }
    async login(token = this.token) {
      if (!token || typeof token !== "string")
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
      this.rest.setToken(token);
      this.emit(Events.Debug, `Provided token: ${this._censoredToken}`);
      if (this.options.presence) {
        this.options.ws.presence = this.presence._parse(this.options.presence);
      }
      this.emit(Events.Debug, "Preparing to connect to the gateway...");
      try {
        await this.ws.connect();
        return this.token;
      } catch (error) {
        await this.destroy();
        throw error;
      }
    }
    isReady() {
      return !this.ws.destroyed && this.ws.status === Status.Ready;
    }
    async destroy() {
      super.destroy();
      this.sweepers.destroy();
      await this.ws.destroy();
      this.token = null;
      this.rest.setToken(null);
    }
    async fetchInvite(invite, options) {
      const code = resolveInviteCode(invite);
      const query = makeURLSearchParams({
        with_counts: true,
        guild_scheduled_event_id: options?.guildScheduledEventId
      });
      const data = await this.rest.get(Routes.invite(code), { query });
      return new Invite(this, data);
    }
    async fetchGuildTemplate(template) {
      const code = resolveGuildTemplateCode(template);
      const data = await this.rest.get(Routes.template(code));
      return new GuildTemplate(this, data);
    }
    async fetchWebhook(id, token) {
      const data = await this.rest.get(Routes.webhook(id, token), { auth: token === undefined });
      return new Webhook(this, { token, ...data });
    }
    async fetchVoiceRegions() {
      const apiRegions = await this.rest.get(Routes.voiceRegions());
      const regions = new Collection;
      for (const region of apiRegions)
        regions.set(region.id, new VoiceRegion(region));
      return regions;
    }
    async fetchSticker(id) {
      const data = await this.rest.get(Routes.sticker(id));
      return new Sticker(this, data);
    }
    async fetchStickerPacks({ packId } = {}) {
      if (packId) {
        const data2 = await this.rest.get(Routes.stickerPack(packId));
        return new StickerPack(this, data2);
      }
      const data = await this.rest.get(Routes.stickerPacks());
      return new Collection(data.sticker_packs.map((stickerPack) => [stickerPack.id, new StickerPack(this, stickerPack)]));
    }
    fetchPremiumStickerPacks() {
      if (!deprecationEmittedForPremiumStickerPacks) {
        process2.emitWarning("The Client#fetchPremiumStickerPacks() method is deprecated. Use Client#fetchStickerPacks() instead.", "DeprecationWarning");
        deprecationEmittedForPremiumStickerPacks = true;
      }
      return this.fetchStickerPacks();
    }
    async fetchDefaultSoundboardSounds() {
      const data = await this.rest.get(Routes.soundboardDefaultSounds());
      return new Collection(data.map((sound) => [sound.sound_id, new SoundboardSound(this, sound)]));
    }
    async fetchGuildPreview(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildPreview(id));
      return new GuildPreview(this, data);
    }
    async fetchGuildWidget(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildWidgetJSON(id));
      return new Widget(this, data);
    }
    generateInvite(options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      if (!this.application)
        throw new DiscordjsError(ErrorCodes.ClientNotReady, "generate an invite link");
      const { scopes } = options;
      if (scopes === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!Array.isArray(scopes)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "scopes", "Array of Invite Scopes", true);
      }
      if (!scopes.some((scope) => [OAuth2Scopes.Bot, OAuth2Scopes.ApplicationsCommands].includes(scope))) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!scopes.includes(OAuth2Scopes.Bot) && options.permissions) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidScopesWithPermissions);
      }
      const validScopes = Object.values(OAuth2Scopes);
      const invalidScope = scopes.find((scope) => !validScopes.includes(scope));
      if (invalidScope) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "scopes", invalidScope);
      }
      const query = makeURLSearchParams({
        client_id: this.application.id,
        scope: scopes.join(" "),
        disable_guild_select: options.disableGuildSelect
      });
      if (options.permissions) {
        const permissions = PermissionsBitField.resolve(options.permissions);
        if (permissions)
          query.set("permissions", permissions.toString());
      }
      if (options.guild) {
        const guildId = this.guilds.resolveId(options.guild);
        if (!guildId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.guild", "GuildResolvable");
        query.set("guild_id", guildId);
      }
      return `${this.options.rest.api}${Routes.oauth2Authorization()}?${query}`;
    }
    toJSON() {
      return super.toJSON({
        actions: false,
        presence: false
      });
    }
    get _censoredToken() {
      if (!this.token)
        return null;
      return this.token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".");
    }
    _eval(script) {
      return eval(script);
    }
    _validateOptions(options = this.options) {
      if (options.intents === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.ClientMissingIntents);
      } else {
        options.intents = new IntentsBitField(options.intents).freeze();
      }
      if (typeof options.shardCount !== "number" || isNaN(options.shardCount) || options.shardCount < 1) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardCount", "a number greater than or equal to 1");
      }
      if (options.shards && !(options.shards === "auto" || Array.isArray(options.shards))) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shards", "'auto', a number or array of numbers");
      }
      if (options.shards && !options.shards.length)
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidProvidedShards);
      if (typeof options.makeCache !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "makeCache", "a function");
      }
      if (typeof options.sweepers !== "object" || options.sweepers === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "sweepers", "an object");
      }
      if (!Array.isArray(options.partials)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "partials", "an Array");
      }
      if (typeof options.waitGuildTimeout !== "number" || isNaN(options.waitGuildTimeout)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "waitGuildTimeout", "a number");
      }
      if (typeof options.failIfNotExists !== "boolean") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "failIfNotExists", "a boolean");
      }
      if (typeof options.enforceNonce !== "boolean") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "enforceNonce", "a boolean");
      }
      if (typeof options.allowedMentions !== "object" && options.allowedMentions !== undefined || options.allowedMentions === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "allowedMentions", "an object");
      }
      if (typeof options.presence !== "object" || options.presence === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "presence", "an object");
      }
      if (typeof options.ws !== "object" || options.ws === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "ws", "an object");
      }
      if (typeof options.rest !== "object" || options.rest === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "rest", "an object");
      }
      if (typeof options.jsonTransformer !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "jsonTransformer", "a function");
      }
    }
  }
  module.exports = Client;
});

// ../../node_modules/discord.js/src/util/ShardEvents.js
var require_ShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Death: "death",
    Disconnect: "disconnect",
    Error: "error",
    Message: "message",
    Ready: "ready",
    Reconnecting: "reconnecting",
    Resume: "resume",
    Spawn: "spawn"
  };
});

// ../../node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var path = __require("path");
  var process2 = __require("process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("timers");
  var { setTimeout: sleep } = __require("timers/promises");
  var { SHARE_ENV } = __require("worker_threads");
  var { DiscordjsError, ErrorCodes } = require_errors();
  var ShardEvents = require_ShardEvents();
  var { makeError, makePlainError } = require_Util();
  var childProcess = null;
  var Worker = null;

  class Shard extends EventEmitter {
    constructor(manager, id) {
      super();
      switch (manager.mode) {
        case "process":
          childProcess = __require("child_process");
          break;
        case "worker":
          Worker = __require("worker_threads").Worker;
          break;
      }
      this.manager = manager;
      this.id = id;
      this.silent = manager.silent;
      this.args = manager.shardArgs ?? [];
      this.execArgv = manager.execArgv;
      this.env = Object.assign({}, process2.env, {
        SHARDING_MANAGER: true,
        SHARDS: this.id,
        SHARD_COUNT: this.manager.totalShards,
        DISCORD_TOKEN: this.manager.token
      });
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals = new Map;
      this._fetches = new Map;
      this._exitListener = null;
    }
    async spawn(timeout = 30000) {
      if (this.process)
        throw new DiscordjsError(ErrorCodes.ShardingProcessExists, this.id);
      if (this.worker)
        throw new DiscordjsError(ErrorCodes.ShardingWorkerExists, this.id);
      this._exitListener = this._handleExit.bind(this, undefined, timeout);
      switch (this.manager.mode) {
        case "process":
          this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
            env: this.env,
            execArgv: this.execArgv,
            silent: this.silent
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
        case "worker":
          this.worker = new Worker(path.resolve(this.manager.file), {
            workerData: this.env,
            env: SHARE_ENV,
            execArgv: this.execArgv,
            argv: this.args
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
      }
      this._evals.clear();
      this._fetches.clear();
      const child = this.process ?? this.worker;
      this.emit(ShardEvents.Spawn, child);
      if (timeout === -1 || timeout === Infinity)
        return child;
      return new Promise((resolve, reject) => {
        const cleanup = () => {
          clearTimeout2(spawnTimeoutTimer);
          this.off("ready", onReady);
          this.off("disconnect", onDisconnect);
          this.off("death", onDeath);
        };
        const onReady = () => {
          cleanup();
          resolve(child);
        };
        const onDisconnect = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDisconnected, this.id));
        };
        const onDeath = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDied, this.id));
        };
        const onTimeout = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyTimeout, this.id));
        };
        const spawnTimeoutTimer = setTimeout2(onTimeout, timeout);
        this.once("ready", onReady);
        this.once("disconnect", onDisconnect);
        this.once("death", onDeath);
      });
    }
    kill() {
      if (this.process) {
        this.process.removeListener("exit", this._exitListener);
        this.process.kill();
      } else {
        this.worker.removeListener("exit", this._exitListener);
        this.worker.terminate();
      }
      this._handleExit(false);
    }
    async respawn({ delay = 500, timeout = 30000 } = {}) {
      this.kill();
      if (delay > 0)
        await sleep(delay);
      return this.spawn(timeout);
    }
    send(message) {
      return new Promise((resolve, reject) => {
        if (this.process) {
          this.process.send(message, (err) => {
            if (err)
              reject(err);
            else
              resolve(this);
          });
        } else {
          this.worker.postMessage(message);
          resolve(this);
        }
      });
    }
    async fetchClientValue(prop) {
      if (!this.process && !this.worker) {
        throw new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id);
      }
      if (this._fetches.has(prop))
        return this._fetches.get(prop);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._fetchProp !== prop)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _fetchProp: prop }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          reject(err);
        });
      });
      this._fetches.set(prop, promise);
      return promise;
    }
    async eval(script2, context) {
      const _eval = typeof script2 === "function" ? `(${script2})(this, ${JSON.stringify(context)})` : script2;
      if (!this.process && !this.worker) {
        throw new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id);
      }
      if (this._evals.has(_eval))
        return this._evals.get(_eval);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._eval !== _eval)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _eval }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          reject(err);
        });
      });
      this._evals.set(_eval, promise);
      return promise;
    }
    _handleMessage(message) {
      if (message) {
        if (message._ready) {
          this.ready = true;
          this.emit(ShardEvents.Ready);
          return;
        }
        if (message._disconnect) {
          this.ready = false;
          this.emit(ShardEvents.Disconnect);
          return;
        }
        if (message._reconnecting) {
          this.ready = false;
          this.emit(ShardEvents.Reconnecting);
          return;
        }
        if (message._resume) {
          this.ready = true;
          this.emit(ShardEvents.Resume);
          return;
        }
        if (message._sFetchProp) {
          const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };
          this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sEval) {
          const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };
          this.manager._performOnShards("eval", [message._sEval], message._sEvalShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sRespawnAll) {
          const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;
          this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {});
          return;
        }
      }
      this.emit(ShardEvents.Message, message);
    }
    _handleExit(respawn = this.manager.respawn, timeout) {
      this.emit(ShardEvents.Death, this.process ?? this.worker);
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals.clear();
      this._fetches.clear();
      if (respawn)
        this.spawn(timeout).catch((err) => this.emit(ShardEvents.Error, err));
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = Shard;
});

// ../../node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var fs = __require("fs");
  var path = __require("path");
  var process2 = __require("process");
  var { setTimeout: sleep } = __require("timers/promises");
  var { Collection } = require_dist6();
  var Shard = require_Shard();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors();
  var { fetchRecommendedShardCount } = require_Util();

  class ShardingManager extends EventEmitter {
    constructor(file, options) {
      super();
      const _options = {
        totalShards: "auto",
        mode: "process",
        respawn: true,
        silent: false,
        shardArgs: [],
        execArgv: [],
        token: process2.env.DISCORD_TOKEN,
        ...options
      };
      this.file = file;
      if (!file)
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "specified.");
      if (!path.isAbsolute(file))
        this.file = path.resolve(process2.cwd(), file);
      const stats = fs.statSync(this.file);
      if (!stats.isFile())
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "a file");
      this.shardList = _options.shardList ?? "auto";
      if (this.shardList !== "auto") {
        if (!Array.isArray(this.shardList)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array.");
        }
        this.shardList = [...new Set(this.shardList)];
        if (this.shardList.length < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "shardList", "at least 1 id.");
        }
        if (this.shardList.some((shardId) => typeof shardId !== "number" || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array of positive integers.");
        }
      }
      this.totalShards = _options.totalShards || "auto";
      if (this.totalShards !== "auto") {
        if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (this.totalShards < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        }
        if (!Number.isInteger(this.totalShards)) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      this.mode = _options.mode;
      if (this.mode !== "process" && this.mode !== "worker") {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Sharding mode", '"process" or "worker"');
      }
      this.respawn = _options.respawn;
      this.silent = _options.silent;
      this.shardArgs = _options.shardArgs;
      this.execArgv = _options.execArgv;
      this.token = _options.token?.replace(/^Bot\s*/i, "") ?? null;
      this.shards = new Collection;
      process2.env.SHARDING_MANAGER = true;
      process2.env.SHARDING_MANAGER_MODE = this.mode;
      process2.env.DISCORD_TOKEN = this.token;
    }
    createShard(id = this.shards.size) {
      const shard = new Shard(this, id);
      this.shards.set(id, shard);
      this.emit("shardCreate", shard);
      return shard;
    }
    async spawn({ amount = this.totalShards, delay = 5500, timeout = 30000 } = {}) {
      if (amount === "auto") {
        amount = await fetchRecommendedShardCount(this.token);
      } else {
        if (typeof amount !== "number" || isNaN(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (amount < 1)
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        if (!Number.isInteger(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      if (this.shards.size >= amount)
        throw new DiscordjsError(ErrorCodes.ShardingAlreadySpawned, this.shards.size);
      if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
        this.shardList = [...Array(amount).keys()];
      }
      if (this.totalShards === "auto" || this.totalShards !== amount) {
        this.totalShards = amount;
      }
      if (this.shardList.some((shardId) => shardId >= amount)) {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "bigger than the highest shardId in the shardList option.");
      }
      for (const shardId of this.shardList) {
        const promises = [];
        const shard = this.createShard(shardId);
        promises.push(shard.spawn(timeout));
        if (delay > 0 && this.shards.size !== this.shardList.length)
          promises.push(sleep(delay));
        await Promise.all(promises);
      }
      return this.shards;
    }
    broadcast(message) {
      const promises = [];
      for (const shard of this.shards.values())
        promises.push(shard.send(message));
      return Promise.all(promises);
    }
    async broadcastEval(script2, options = {}) {
      if (typeof script2 !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast);
      }
      return this._performOnShards("eval", [`(${script2})(this, ${JSON.stringify(options.context)})`], options.shard);
    }
    fetchClientValues(prop, shard) {
      return this._performOnShards("fetchClientValue", [prop], shard);
    }
    async _performOnShards(method, args, shard) {
      if (this.shards.size === 0)
        throw new DiscordjsError(ErrorCodes.ShardingNoShards);
      if (typeof shard === "number") {
        if (this.shards.has(shard))
          return this.shards.get(shard)[method](...args);
        throw new DiscordjsError(ErrorCodes.ShardingShardNotFound, shard);
      }
      if (this.shards.size !== this.shardList.length) {
        throw new DiscordjsError(ErrorCodes.ShardingInProcess);
      }
      const promises = [];
      for (const sh of this.shards.values())
        promises.push(sh[method](...args));
      return Promise.all(promises);
    }
    async respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      let s = 0;
      for (const shard of this.shards.values()) {
        const promises = [shard.respawn({ delay: respawnDelay, timeout })];
        if (++s < this.shards.size && shardDelay > 0)
          promises.push(sleep(shardDelay));
        await Promise.all(promises);
      }
      return this.shards;
    }
  }
  module.exports = ShardingManager;
});

// ../../node_modules/discord.js/src/util/Formatters.js
var require_Formatters = __commonJS((exports, module) => {
  var { deprecate } = __require("util");
  var {
    blockQuote,
    bold,
    channelMention,
    codeBlock,
    formatEmoji,
    hideLinkEmbed,
    hyperlink,
    inlineCode,
    italic,
    quote,
    roleMention,
    spoiler,
    strikethrough,
    time,
    TimestampStyles,
    underscore,
    userMention
  } = require_dist7();

  class Formatters extends null {
    static blockQuote = deprecate(blockQuote, "Formatters.blockQuote() is deprecated. Import this method directly from discord.js instead.");
    static bold = deprecate(bold, "Formatters.bold() is deprecated. Import this method directly from discord.js instead.");
    static channelMention = deprecate(channelMention, "Formatters.channelMention() is deprecated. Import this method directly from discord.js instead.");
    static codeBlock = deprecate(codeBlock, "Formatters.codeBlock() is deprecated. Import this method directly from discord.js instead.");
    static formatEmoji = deprecate(formatEmoji, "Formatters.formatEmoji() is deprecated. Import this method directly from discord.js instead.");
    static hideLinkEmbed = deprecate(hideLinkEmbed, "Formatters.hideLinkEmbed() is deprecated. Import this method directly from discord.js instead.");
    static hyperlink = deprecate(hyperlink, "Formatters.hyperlink() is deprecated. Import this method directly from discord.js instead.");
    static inlineCode = deprecate(inlineCode, "Formatters.inlineCode() is deprecated. Import this method directly from discord.js instead.");
    static italic = deprecate(italic, "Formatters.italic() is deprecated. Import this method directly from discord.js instead.");
    static quote = deprecate(quote, "Formatters.quote() is deprecated. Import this method directly from discord.js instead.");
    static roleMention = deprecate(roleMention, "Formatters.roleMention() is deprecated. Import this method directly from discord.js instead.");
    static spoiler = deprecate(spoiler, "Formatters.spoiler() is deprecated. Import this method directly from discord.js instead.");
    static strikethrough = deprecate(strikethrough, "Formatters.strikethrough() is deprecated. Import this method directly from discord.js instead.");
    static time = deprecate(time, "Formatters.time() is deprecated. Import this method directly from discord.js instead.");
    static TimestampStyles = TimestampStyles;
    static underscore = deprecate(underscore, "Formatters.underscore() is deprecated. Import this method directly from discord.js instead.");
    static userMention = deprecate(userMention, "Formatters.userMention() is deprecated. Import this method directly from discord.js instead.");
  }
  module.exports = Formatters;
});

// ../../node_modules/discord.js/src/structures/EmbedBuilder.js
var require_EmbedBuilder = __commonJS((exports, module) => {
  var { EmbedBuilder: BuildersEmbed, embedLength } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolveColor } = require_Util();

  class EmbedBuilder extends BuildersEmbed {
    constructor(data) {
      super(toSnakeCase(data));
    }
    setColor(color) {
      return super.setColor(color && resolveColor(color));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
    get length() {
      return embedLength(this.data);
    }
  }
  module.exports = EmbedBuilder;
});

// ../../node_modules/discord.js/src/structures/AttachmentBuilder.js
var require_AttachmentBuilder = __commonJS((exports, module) => {
  var { basename, flatten } = require_Util();

  class AttachmentBuilder {
    constructor(attachment, data = {}) {
      this.attachment = attachment;
      this.name = data.name;
      this.description = data.description;
    }
    setDescription(description) {
      this.description = description;
      return this;
    }
    setFile(attachment) {
      this.attachment = attachment;
      return this;
    }
    setName(name) {
      this.name = name;
      return this;
    }
    setSpoiler(spoiler = true) {
      if (spoiler === this.spoiler)
        return this;
      if (!spoiler) {
        while (this.spoiler) {
          this.name = this.name.slice("SPOILER_".length);
        }
        return this;
      }
      this.name = `SPOILER_${this.name}`;
      return this;
    }
    get spoiler() {
      return basename(this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
    static from(other) {
      return new AttachmentBuilder(other.attachment, {
        name: other.name,
        description: other.description
      });
    }
  }
  module.exports = AttachmentBuilder;
});

// ../../node_modules/discord.js/src/structures/ModalBuilder.js
var require_ModalBuilder = __commonJS((exports, module) => {
  var { ModalBuilder: BuildersModal, ComponentBuilder } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ModalBuilder extends BuildersModal {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((component) => component instanceof ComponentBuilder ? component : toSnakeCase(component))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ModalBuilder;
});

// ../../node_modules/discord.js/src/structures/SelectMenuBuilder.js
var require_SelectMenuBuilder = __commonJS((exports, module) => {
  var process2 = __require("process");
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var deprecationEmitted = false;

  class SelectMenuBuilder2 extends StringSelectMenuBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuBuilder class is deprecated. Use StringSelectMenuBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuBuilder2;
});

// ../../node_modules/discord.js/src/structures/SelectMenuComponent.js
var require_SelectMenuComponent = __commonJS((exports, module) => {
  var process2 = __require("process");
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var deprecationEmitted = false;

  class SelectMenuComponent extends StringSelectMenuComponent {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuComponent class is deprecated. Use StringSelectMenuComponent instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuComponent;
});

// ../../node_modules/discord.js/src/structures/SelectMenuInteraction.js
var require_SelectMenuInteraction = __commonJS((exports, module) => {
  var process2 = __require("process");
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var deprecationEmitted = false;

  class SelectMenuInteraction extends StringSelectMenuInteraction {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuInteraction class is deprecated. Use StringSelectMenuInteraction instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuInteraction;
});

// ../../node_modules/discord.js/src/structures/StringSelectMenuOptionBuilder.js
var require_StringSelectMenuOptionBuilder = __commonJS((exports, module) => {
  var { SelectMenuOptionBuilder: BuildersSelectMenuOption } = require_dist8();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuOptionBuilder extends BuildersSelectMenuOption {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = StringSelectMenuOptionBuilder;
});

// ../../node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js
var require_SelectMenuOptionBuilder = __commonJS((exports, module) => {
  var process2 = __require("process");
  var StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  var deprecationEmitted = false;

  class SelectMenuOptionBuilder2 extends StringSelectMenuOptionBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuOptionBuilder class is deprecated. Use StringSelectMenuOptionBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuOptionBuilder2;
});

// ../../node_modules/discord.js/src/index.js
var require_src = __commonJS((exports) => {
  var { polyfillDispose } = require_dist();
  var { __exportStar } = require_tslib();
  polyfillDispose();
  exports.BaseClient = require_BaseClient();
  exports.Client = require_Client();
  exports.Shard = require_Shard();
  exports.ShardClientUtil = require_ShardClientUtil();
  exports.ShardingManager = require_ShardingManager();
  exports.WebhookClient = require_WebhookClient();
  exports.DiscordjsError = require_DJSError().DiscordjsError;
  exports.DiscordjsTypeError = require_DJSError().DiscordjsTypeError;
  exports.DiscordjsRangeError = require_DJSError().DiscordjsRangeError;
  exports.DiscordjsErrorCodes = require_ErrorCodes();
  exports.ActivityFlagsBitField = require_ActivityFlagsBitField();
  exports.ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  exports.AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  exports.BaseManager = require_BaseManager();
  exports.BitField = require_BitField();
  exports.ChannelFlagsBitField = require_ChannelFlagsBitField();
  exports.Collection = require_dist6().Collection;
  exports.Constants = require_Constants();
  exports.Colors = require_Colors();
  exports.Events = require_Events();
  exports.Formatters = require_Formatters();
  exports.GuildMemberFlagsBitField = require_GuildMemberFlagsBitField().GuildMemberFlagsBitField;
  exports.IntentsBitField = require_IntentsBitField();
  exports.LimitedCollection = require_LimitedCollection();
  exports.MessageFlagsBitField = require_MessageFlagsBitField();
  exports.Options = require_Options();
  exports.Partials = require_Partials();
  exports.PermissionsBitField = require_PermissionsBitField();
  exports.RoleFlagsBitField = require_RoleFlagsBitField();
  exports.ShardEvents = require_ShardEvents();
  exports.SKUFlagsBitField = require_SKUFlagsBitField().SKUFlagsBitField;
  exports.Status = require_Status();
  exports.SnowflakeUtil = require_cjs().DiscordSnowflake;
  exports.Sweepers = require_Sweepers();
  exports.SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  exports.ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
  exports.UserFlagsBitField = require_UserFlagsBitField();
  __exportStar(require_Util(), exports);
  exports.WebSocketShardEvents = require_WebSocketShardEvents();
  exports.version = require_package().version;
  exports.ApplicationCommandManager = require_ApplicationCommandManager();
  exports.ApplicationEmojiManager = require_ApplicationEmojiManager();
  exports.ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  exports.AutoModerationRuleManager = require_AutoModerationRuleManager();
  exports.BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  exports.CachedManager = require_CachedManager();
  exports.ChannelManager = require_ChannelManager();
  exports.ClientVoiceManager = require_ClientVoiceManager();
  exports.DataManager = require_DataManager();
  exports.DMMessageManager = require_DMMessageManager();
  exports.EntitlementManager = require_EntitlementManager().EntitlementManager;
  exports.GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  exports.GuildBanManager = require_GuildBanManager();
  exports.GuildChannelManager = require_GuildChannelManager();
  exports.GuildEmojiManager = require_GuildEmojiManager();
  exports.GuildEmojiRoleManager = require_GuildEmojiRoleManager();
  exports.GuildForumThreadManager = require_GuildForumThreadManager();
  exports.GuildInviteManager = require_GuildInviteManager();
  exports.GuildManager = require_GuildManager();
  exports.GuildMemberManager = require_GuildMemberManager();
  exports.GuildMemberRoleManager = require_GuildMemberRoleManager();
  exports.GuildMessageManager = require_GuildMessageManager();
  exports.GuildScheduledEventManager = require_GuildScheduledEventManager();
  exports.GuildSoundboardSoundManager = require_GuildSoundboardSoundManager().GuildSoundboardSoundManager;
  exports.GuildStickerManager = require_GuildStickerManager();
  exports.GuildTextThreadManager = require_GuildTextThreadManager();
  exports.MessageManager = require_MessageManager();
  exports.PermissionOverwriteManager = require_PermissionOverwriteManager();
  exports.PresenceManager = require_PresenceManager();
  exports.ReactionManager = require_ReactionManager();
  exports.ReactionUserManager = require_ReactionUserManager();
  exports.RoleManager = require_RoleManager();
  exports.StageInstanceManager = require_StageInstanceManager();
  exports.SubscriptionManager = require_SubscriptionManager().SubscriptionManager;
  exports.ThreadManager = require_ThreadManager();
  exports.ThreadMemberManager = require_ThreadMemberManager();
  exports.UserManager = require_UserManager();
  exports.VoiceStateManager = require_VoiceStateManager();
  exports.WebSocketManager = require_WebSocketManager();
  exports.WebSocketShard = require_WebSocketShard();
  exports.ActionRow = require_ActionRow();
  exports.ActionRowBuilder = require_ActionRowBuilder();
  exports.Activity = require_Presence().Activity;
  exports.AnonymousGuild = require_AnonymousGuild();
  exports.Application = require_Application();
  exports.ApplicationCommand = require_ApplicationCommand();
  exports.ApplicationEmoji = require_ApplicationEmoji();
  exports.ApplicationRoleConnectionMetadata = require_ApplicationRoleConnectionMetadata().ApplicationRoleConnectionMetadata;
  exports.AutocompleteInteraction = require_AutocompleteInteraction();
  exports.AutoModerationActionExecution = require_AutoModerationActionExecution();
  exports.AutoModerationRule = require_AutoModerationRule();
  exports.Base = require_Base();
  exports.BaseGuild = require_BaseGuild();
  exports.BaseGuildEmoji = require_BaseGuildEmoji();
  exports.BaseGuildTextChannel = require_BaseGuildTextChannel();
  exports.BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  exports.ButtonBuilder = require_ButtonBuilder();
  exports.ButtonComponent = require_ButtonComponent();
  exports.ButtonInteraction = require_ButtonInteraction();
  exports.CategoryChannel = require_CategoryChannel();
  exports.BaseChannel = require_BaseChannel().BaseChannel;
  exports.ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  exports.ClientApplication = require_ClientApplication();
  exports.ClientPresence = require_ClientPresence();
  exports.ClientUser = require_ClientUser();
  exports.CommandInteraction = require_CommandInteraction();
  exports.Collector = require_Collector();
  exports.CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  exports.Component = require_Component();
  exports.ContainerComponent = require_ContainerComponent();
  exports.ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
  exports.DirectoryChannel = require_DirectoryChannel();
  exports.DMChannel = require_DMChannel();
  exports.Embed = require_Embed();
  exports.EmbedBuilder = require_EmbedBuilder();
  exports.Emoji = require_Emoji().Emoji;
  exports.Entitlement = require_Entitlement().Entitlement;
  exports.FileComponent = require_FileComponent();
  exports.ForumChannel = require_ForumChannel();
  exports.Guild = require_Guild().Guild;
  exports.GuildAuditLogs = require_GuildAuditLogs();
  exports.GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  exports.GuildBan = require_GuildBan();
  exports.GuildChannel = require_GuildChannel();
  exports.GuildEmoji = require_GuildEmoji();
  exports.GuildMember = require_GuildMember().GuildMember;
  exports.GuildOnboarding = require_GuildOnboarding().GuildOnboarding;
  exports.GuildOnboardingPrompt = require_GuildOnboardingPrompt().GuildOnboardingPrompt;
  exports.GuildOnboardingPromptOption = require_GuildOnboardingPromptOption().GuildOnboardingPromptOption;
  exports.GuildPreview = require_GuildPreview();
  exports.GuildPreviewEmoji = require_GuildPreviewEmoji();
  exports.GuildScheduledEvent = require_GuildScheduledEvent().GuildScheduledEvent;
  exports.GuildTemplate = require_GuildTemplate();
  exports.Integration = require_Integration();
  exports.IntegrationApplication = require_IntegrationApplication();
  exports.InteractionCallback = require_InteractionCallback();
  exports.InteractionCallbackResource = require_InteractionCallbackResource();
  exports.InteractionCallbackResponse = require_InteractionCallbackResponse();
  exports.BaseInteraction = require_BaseInteraction();
  exports.InteractionCollector = require_InteractionCollector();
  exports.InteractionResponse = require_InteractionResponse();
  exports.InteractionWebhook = require_InteractionWebhook();
  exports.Invite = require_Invite();
  exports.InviteStageInstance = require_InviteStageInstance();
  exports.InviteGuild = require_InviteGuild();
  exports.Message = require_Message().Message;
  exports.Attachment = require_Attachment();
  exports.AttachmentBuilder = require_AttachmentBuilder();
  exports.ModalBuilder = require_ModalBuilder();
  exports.MediaChannel = require_MediaChannel();
  exports.MediaGalleryComponent = require_MediaGalleryComponent();
  exports.MediaGalleryItem = require_MediaGalleryItem();
  exports.MessageCollector = require_MessageCollector();
  exports.MessageComponentInteraction = require_MessageComponentInteraction();
  exports.MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  exports.MessageMentions = require_MessageMentions();
  exports.MessagePayload = require_MessagePayload();
  exports.MessageReaction = require_MessageReaction();
  exports.ModalSubmitInteraction = require_ModalSubmitInteraction();
  exports.ModalSubmitFields = require_ModalSubmitFields();
  exports.NewsChannel = require_NewsChannel();
  exports.OAuth2Guild = require_OAuth2Guild();
  exports.PartialGroupDMChannel = require_PartialGroupDMChannel();
  exports.PermissionOverwrites = require_PermissionOverwrites();
  exports.Poll = require_Poll().Poll;
  exports.PollAnswer = require_PollAnswer().PollAnswer;
  exports.PrimaryEntryPointCommandInteraction = require_PrimaryEntryPointCommandInteraction();
  exports.Presence = require_Presence().Presence;
  exports.ReactionCollector = require_ReactionCollector();
  exports.ReactionEmoji = require_ReactionEmoji();
  exports.RichPresenceAssets = require_Presence().RichPresenceAssets;
  exports.Role = require_Role().Role;
  exports.SectionComponent = require_SectionComponent();
  exports.SelectMenuBuilder = require_SelectMenuBuilder();
  exports.ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  exports.MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  exports.RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  exports.StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  exports.UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  exports.BaseSelectMenuComponent = require_BaseSelectMenuComponent();
  exports.SelectMenuComponent = require_SelectMenuComponent();
  exports.ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  exports.MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  exports.RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  exports.StringSelectMenuComponent = require_StringSelectMenuComponent();
  exports.UserSelectMenuComponent = require_UserSelectMenuComponent();
  exports.SelectMenuInteraction = require_SelectMenuInteraction();
  exports.ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  exports.StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  exports.UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  exports.SelectMenuOptionBuilder = require_SelectMenuOptionBuilder();
  exports.SeparatorComponent = require_SeparatorComponent();
  exports.SKU = require_SKU().SKU;
  exports.SoundboardSound = require_SoundboardSound().SoundboardSound;
  exports.StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  exports.StageChannel = require_StageChannel();
  exports.StageInstance = require_StageInstance().StageInstance;
  exports.Subscription = require_Subscription().Subscription;
  exports.Sticker = require_Sticker().Sticker;
  exports.StickerPack = require_StickerPack();
  exports.Team = require_Team();
  exports.TeamMember = require_TeamMember();
  exports.TextChannel = require_TextChannel();
  exports.TextDisplayComponent = require_TextDisplayComponent();
  exports.TextInputBuilder = require_TextInputBuilder();
  exports.TextInputComponent = require_TextInputComponent();
  exports.ThreadChannel = require_ThreadChannel();
  exports.ThreadMember = require_ThreadMember();
  exports.ThreadOnlyChannel = require_ThreadOnlyChannel();
  exports.ThumbnailComponent = require_ThumbnailComponent();
  exports.Typing = require_Typing();
  exports.UnfurledMediaItem = require_UnfurledMediaItem();
  exports.User = require_User();
  exports.UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  exports.VoiceChannelEffect = require_VoiceChannelEffect();
  exports.VoiceChannel = require_VoiceChannel();
  exports.VoiceRegion = require_VoiceRegion();
  exports.VoiceState = require_VoiceState();
  exports.Webhook = require_Webhook();
  exports.Widget = require_Widget();
  exports.WidgetMember = require_WidgetMember();
  exports.WelcomeChannel = require_WelcomeChannel();
  exports.WelcomeScreen = require_WelcomeScreen();
  __exportStar(require_v106(), exports);
  __exportStar(require_dist8(), exports);
  __exportStar(require_dist7(), exports);
  __exportStar(require_dist5(), exports);
  __exportStar(require_dist(), exports);
  __exportStar(require_dist10(), exports);
});

// ../../node_modules/@vercel/oidc/dist/get-context.js
var require_get_context = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name14 in all)
      __defProp2(target, name14, { get: all[name14], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var get_context_exports = {};
  __export2(get_context_exports, {
    SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
    getContext: () => getContext2
  });
  module.exports = __toCommonJS(get_context_exports);
  var SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
  function getContext2() {
    const fromSymbol = globalThis;
    return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
  }
});

// ../../node_modules/@vercel/oidc/dist/token-error.js
var require_token_error = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name14 in all)
      __defProp2(target, name14, { get: all[name14], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var token_error_exports = {};
  __export2(token_error_exports, {
    VercelOidcTokenError: () => VercelOidcTokenError
  });
  module.exports = __toCommonJS(token_error_exports);

  class VercelOidcTokenError extends Error {
    constructor(message, cause) {
      super(message);
      this.name = "VercelOidcTokenError";
      this.cause = cause;
    }
    toString() {
      if (this.cause) {
        return `${this.name}: ${this.message}: ${this.cause}`;
      }
      return `${this.name}: ${this.message}`;
    }
  }
});

// ../../node_modules/@vercel/oidc/dist/token-io.js
var require_token_io = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name14 in all)
      __defProp2(target, name14, { get: all[name14], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var token_io_exports = {};
  __export2(token_io_exports, {
    findRootDir: () => findRootDir,
    getUserDataDir: () => getUserDataDir
  });
  module.exports = __toCommonJS(token_io_exports);
  var import_path = __toESM2(__require("path"));
  var import_fs = __toESM2(__require("fs"));
  var import_os = __toESM2(__require("os"));
  var import_token_error = require_token_error();
  function findRootDir() {
    try {
      let dir = process.cwd();
      while (dir !== import_path.default.dirname(dir)) {
        const pkgPath = import_path.default.join(dir, ".vercel");
        if (import_fs.default.existsSync(pkgPath)) {
          return dir;
        }
        dir = import_path.default.dirname(dir);
      }
    } catch (e) {
      throw new import_token_error.VercelOidcTokenError("Token refresh only supported in node server environments");
    }
    throw new import_token_error.VercelOidcTokenError("Unable to find root directory");
  }
  function getUserDataDir() {
    if (process.env.XDG_DATA_HOME) {
      return process.env.XDG_DATA_HOME;
    }
    switch (import_os.default.platform()) {
      case "darwin":
        return import_path.default.join(import_os.default.homedir(), "Library/Application Support");
      case "linux":
        return import_path.default.join(import_os.default.homedir(), ".local/share");
      case "win32":
        if (process.env.LOCALAPPDATA) {
          return process.env.LOCALAPPDATA;
        }
        return null;
      default:
        return null;
    }
  }
});

// ../../node_modules/@vercel/oidc/dist/token-util.js
var require_token_util = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name14 in all)
      __defProp2(target, name14, { get: all[name14], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var token_util_exports = {};
  __export2(token_util_exports, {
    assertVercelOidcTokenResponse: () => assertVercelOidcTokenResponse,
    findProjectInfo: () => findProjectInfo,
    getTokenPayload: () => getTokenPayload,
    getVercelCliToken: () => getVercelCliToken,
    getVercelDataDir: () => getVercelDataDir,
    getVercelOidcToken: () => getVercelOidcToken2,
    isExpired: () => isExpired,
    loadToken: () => loadToken,
    saveToken: () => saveToken
  });
  module.exports = __toCommonJS(token_util_exports);
  var path = __toESM2(__require("path"));
  var fs = __toESM2(__require("fs"));
  var import_token_error = require_token_error();
  var import_token_io = require_token_io();
  function getVercelDataDir() {
    const vercelFolder = "com.vercel.cli";
    const dataDir = (0, import_token_io.getUserDataDir)();
    if (!dataDir) {
      return null;
    }
    return path.join(dataDir, vercelFolder);
  }
  function getVercelCliToken() {
    const dataDir = getVercelDataDir();
    if (!dataDir) {
      return null;
    }
    const tokenPath = path.join(dataDir, "auth.json");
    if (!fs.existsSync(tokenPath)) {
      return null;
    }
    const token = fs.readFileSync(tokenPath, "utf8");
    if (!token) {
      return null;
    }
    return JSON.parse(token).token;
  }
  async function getVercelOidcToken2(authToken, projectId, teamId) {
    try {
      const url2 = `https://api.vercel.com/v1/projects/${projectId}/token?source=vercel-oidc-refresh${teamId ? `&teamId=${teamId}` : ""}`;
      const res = await fetch(url2, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${authToken}`
        }
      });
      if (!res.ok) {
        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token: ${res.statusText}`);
      }
      const tokenRes = await res.json();
      assertVercelOidcTokenResponse(tokenRes);
      return tokenRes;
    } catch (e) {
      throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, e);
    }
  }
  function assertVercelOidcTokenResponse(res) {
    if (!res || typeof res !== "object") {
      throw new TypeError("Expected an object");
    }
    if (!("token" in res) || typeof res.token !== "string") {
      throw new TypeError("Expected a string-valued token property");
    }
  }
  function findProjectInfo() {
    const dir = (0, import_token_io.findRootDir)();
    if (!dir) {
      throw new import_token_error.VercelOidcTokenError("Unable to find root directory");
    }
    try {
      const prjPath = path.join(dir, ".vercel", "project.json");
      if (!fs.existsSync(prjPath)) {
        throw new import_token_error.VercelOidcTokenError("project.json not found");
      }
      const prj = JSON.parse(fs.readFileSync(prjPath, "utf8"));
      if (typeof prj.projectId !== "string" && typeof prj.orgId !== "string") {
        throw new TypeError("Expected a string-valued projectId property");
      }
      return { projectId: prj.projectId, teamId: prj.orgId };
    } catch (e) {
      throw new import_token_error.VercelOidcTokenError(`Unable to find project ID`, e);
    }
  }
  function saveToken(token, projectId) {
    try {
      const dir = (0, import_token_io.getUserDataDir)();
      if (!dir) {
        throw new import_token_error.VercelOidcTokenError("Unable to find user data directory");
      }
      const tokenPath = path.join(dir, "com.vercel.token", `${projectId}.json`);
      const tokenJson = JSON.stringify(token);
      fs.mkdirSync(path.dirname(tokenPath), { mode: 432, recursive: true });
      fs.writeFileSync(tokenPath, tokenJson);
      fs.chmodSync(tokenPath, 432);
      return;
    } catch (e) {
      throw new import_token_error.VercelOidcTokenError(`Failed to save token`, e);
    }
  }
  function loadToken(projectId) {
    try {
      const dir = (0, import_token_io.getUserDataDir)();
      if (!dir) {
        return null;
      }
      const tokenPath = path.join(dir, "com.vercel.token", `${projectId}.json`);
      if (!fs.existsSync(tokenPath)) {
        return null;
      }
      const token = JSON.parse(fs.readFileSync(tokenPath, "utf8"));
      assertVercelOidcTokenResponse(token);
      return token;
    } catch (e) {
      throw new import_token_error.VercelOidcTokenError(`Failed to load token`, e);
    }
  }
  function getTokenPayload(token) {
    const tokenParts = token.split(".");
    if (tokenParts.length !== 3) {
      throw new import_token_error.VercelOidcTokenError("Invalid token");
    }
    const base643 = tokenParts[1].replace(/-/g, "+").replace(/_/g, "/");
    const padded = base643.padEnd(base643.length + (4 - base643.length % 4) % 4, "=");
    return JSON.parse(Buffer.from(padded, "base64").toString("utf8"));
  }
  var TIME_15_MINUTES_IN_MS = 15 * 60 * 1000;
  function isExpired(token) {
    return token.exp * 1000 < Date.now() + TIME_15_MINUTES_IN_MS;
  }
});

// ../../node_modules/@vercel/oidc/dist/token.js
var require_token = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name14 in all)
      __defProp2(target, name14, { get: all[name14], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var token_exports = {};
  __export2(token_exports, {
    refreshToken: () => refreshToken
  });
  module.exports = __toCommonJS(token_exports);
  var import_token_error = require_token_error();
  var import_token_util = require_token_util();
  async function refreshToken() {
    const { projectId, teamId } = (0, import_token_util.findProjectInfo)();
    let maybeToken = (0, import_token_util.loadToken)(projectId);
    if (!maybeToken || (0, import_token_util.isExpired)((0, import_token_util.getTokenPayload)(maybeToken.token))) {
      const authToken = (0, import_token_util.getVercelCliToken)();
      if (!authToken) {
        throw new import_token_error.VercelOidcTokenError("Failed to refresh OIDC token: login to vercel cli");
      }
      if (!projectId) {
        throw new import_token_error.VercelOidcTokenError("Failed to refresh OIDC token: project id not found");
      }
      maybeToken = await (0, import_token_util.getVercelOidcToken)(authToken, projectId, teamId);
      if (!maybeToken) {
        throw new import_token_error.VercelOidcTokenError("Failed to refresh OIDC token");
      }
      (0, import_token_util.saveToken)(maybeToken, projectId);
    }
    process.env.VERCEL_OIDC_TOKEN = maybeToken.token;
    return;
  }
});

// ../../node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js
var require_get_vercel_oidc_token = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name14 in all)
      __defProp2(target, name14, { get: all[name14], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var get_vercel_oidc_token_exports = {};
  __export2(get_vercel_oidc_token_exports, {
    getVercelOidcToken: () => getVercelOidcToken2,
    getVercelOidcTokenSync: () => getVercelOidcTokenSync2
  });
  module.exports = __toCommonJS(get_vercel_oidc_token_exports);
  var import_get_context = require_get_context();
  var import_token_error = require_token_error();
  async function getVercelOidcToken2() {
    let token = "";
    let err;
    try {
      token = getVercelOidcTokenSync2();
    } catch (error46) {
      err = error46;
    }
    try {
      const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
        await Promise.resolve().then(() => __toESM(require_token_util())),
        await Promise.resolve().then(() => __toESM(require_token()))
      ]);
      if (!token || isExpired(getTokenPayload(token))) {
        await refreshToken();
        token = getVercelOidcTokenSync2();
      }
    } catch (error46) {
      if (err?.message && error46 instanceof Error) {
        error46.message = `${err.message}
${error46.message}`;
      }
      throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error46);
    }
    return token;
  }
  function getVercelOidcTokenSync2() {
    const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
    if (!token) {
      throw new Error(`The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`);
    }
    return token;
  }
});

// ../../node_modules/@vercel/oidc/dist/index.js
var require_dist11 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name14 in all)
      __defProp2(target, name14, { get: all[name14], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    getContext: () => import_get_context.getContext,
    getVercelOidcToken: () => import_get_vercel_oidc_token.getVercelOidcToken,
    getVercelOidcTokenSync: () => import_get_vercel_oidc_token.getVercelOidcTokenSync
  });
  module.exports = __toCommonJS(src_exports);
  var import_get_vercel_oidc_token = require_get_vercel_oidc_token();
  var import_get_context = require_get_context();
});

// ../../node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// ../../node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_globalThis(), exports);
});

// ../../node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_node(), exports);
});

// ../../node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.9.0";
});

// ../../node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  }
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// ../../node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  function registerGlobal(type, instance, diag, allowOverride = false) {
    var _a16;
    const api2 = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a16 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a16 !== undefined ? _a16 : {
      version: version_1.VERSION
    };
    if (!allowOverride && api2[type]) {
      const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api2.version !== version_1.VERSION) {
      const err = new Error(`@opentelemetry/api: Registration of version v${api2.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err.stack || err.message);
      return false;
    }
    api2[type] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
    return true;
  }
  exports.registerGlobal = registerGlobal;
  function getGlobal(type) {
    var _a16, _b8;
    const globalVersion = (_a16 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a16 === undefined ? undefined : _a16.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b8 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b8 === undefined ? undefined : _b8[type];
  }
  exports.getGlobal = getGlobal;
  function unregisterGlobal(type, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
    const api2 = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api2) {
      delete api2[type];
    }
  }
  exports.unregisterGlobal = unregisterGlobal;
});

// ../../node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args) {
      return logProxy("debug", this._namespace, args);
    }
    error(...args) {
      return logProxy("error", this._namespace, args);
    }
    info(...args) {
      return logProxy("info", this._namespace, args);
    }
    warn(...args) {
      return logProxy("warn", this._namespace, args);
    }
    verbose(...args) {
      return logProxy("verbose", this._namespace, args);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
  function logProxy(funcName, namespace, args) {
    const logger = (0, global_utils_1.getGlobal)("diag");
    if (!logger) {
      return;
    }
    args.unshift(namespace);
    return logger[funcName](...args);
  }
});

// ../../node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types();
  function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger);
      }
      return function() {};
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  }
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// ../../node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args) {
          const logger = (0, global_utils_1.getGlobal)("diag");
          if (!logger)
            return;
          return logger[funcName](...args);
        };
      }
      const self2 = this;
      const setLogger = (logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a16, _b8, _c;
        if (logger === self2) {
          const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a16 = err.stack) !== null && _a16 !== undefined ? _a16 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b8 = optionsOrLogLevel.logLevel) !== null && _b8 !== undefined ? _b8 : types_1.DiagLogLevel.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
      };
      self2.createComponentLogger = (options) => {
        return new ComponentLogger_1.DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  function createBaggage(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  }
  exports.createBaggage = createBaggage;
  function baggageEntryMetadataFromString(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  }
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// ../../node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  function createContextKey(description) {
    return Symbol.for(description);
  }
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : new Map;
      self2.getValue = (key) => self2._currentContext.get(key);
      self2.setValue = (key, value) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self2.deleteValue = (key) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// ../../node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (let i = 0;i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {}
    createGauge(_name, _options) {
      return exports.NOOP_GAUGE_METRIC;
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {}
    removeBatchObservableCallback(_callback) {}
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {}
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {}
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopGaugeMetric extends NoopMetric {
    record(_value, _attributes) {}
  }
  exports.NoopGaugeMetric = NoopGaugeMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {}
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {}
    removeCallback(_callback) {}
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  function createNoopMeter() {
    return exports.NOOP_METER;
  }
  exports.createNoopMeter = createNoopMeter;
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2["INT"] = 0] = "INT";
    ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value;
    }
  };
});

// ../../node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args) {
      return fn.call(thisArg, ...args);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// ../../node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {}
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context, fn, thisArg, ...args) {
      return this._getContextManager().with(context, fn, thisArg, ...args);
    }
    bind(context, target) {
      return this._getContextManager().bind(context, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    addLink(_link) {
      return this;
    }
    addLinks(_links) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {}
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {}
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
  }
  exports.getSpan = getSpan;
  function getActiveSpan() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  }
  exports.getActiveSpan = getActiveSpan;
  function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
  }
  exports.setSpan = setSpan;
  function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
  }
  exports.deleteSpan = deleteSpan;
  function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  }
  exports.setSpanContext = setSpanContext;
  function getSpanContext(context) {
    var _a16;
    return (_a16 = getSpan(context)) === null || _a16 === undefined ? undefined : _a16.spanContext();
  }
  exports.getSpanContext = getSpanContext;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  }
  exports.isValidTraceId = isValidTraceId;
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  }
  exports.isValidSpanId = isValidSpanId;
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  exports.isSpanContextValid = isSpanContextValid;
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  }
  exports.wrapSpanContext = wrapSpanContext;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name15, options, context = contextApi.active()) {
      const root = Boolean(options === null || options === undefined ? undefined : options.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name15, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span = this.startSpan(name15, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, undefined, span);
    }
  }
  exports.NoopTracer = NoopTracer;
  function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name15, version2, options) {
      this._provider = _provider;
      this.name = name15;
      this.version = version2;
      this.options = options;
    }
    startSpan(name15, options, context) {
      return this._getTracer().startSpan(name15, options, context);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name15, version2, options) {
      var _a16;
      return (_a16 = this.getDelegateTracer(name15, version2, options)) !== null && _a16 !== undefined ? _a16 : new ProxyTracer_1.ProxyTracer(this, name15, version2, options);
    }
    getDelegate() {
      var _a16;
      return (_a16 = this._delegate) !== null && _a16 !== undefined ? _a16 : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name15, version2, options) {
      var _a16;
      return (_a16 = this._delegate) === null || _a16 === undefined ? undefined : _a16.getTracer(name15, version2, options);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  exports.validateValue = validateValue;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value = listMember.slice(i + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
            agg.set(key, value);
          } else {}
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  function createTraceState(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  }
  exports.createTraceState = createTraceState;
});

// ../../node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// ../../node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {}
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name15, version2, options) {
      return this.getMeterProvider().getMeter(name15, version2, options);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {}
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
  }
  exports.getBaggage = getBaggage;
  function getActiveBaggage() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  }
  exports.getActiveBaggage = getActiveBaggage;
  function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  }
  exports.setBaggage = setBaggage;
  function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
  }
  exports.deleteBaggage = deleteBaggage;
});

// ../../node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context, carrier, setter);
    }
    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider) {
      const success2 = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success2) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success2;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name15, version2) {
      return this.getTracerProvider().getTracer(name15, version2);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// ../../node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// ../../node_modules/@opentelemetry/api/build/src/index.js
var require_src2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils2();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// ../../node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  exports.parse = function(source, transform2) {
    return new ArrayParser(source, transform2).parse();
  };

  class ArrayParser {
    constructor(source, transform2) {
      this.source = source;
      this.transform = transform2 || identity;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char = this.nextCharacter();
          if (char.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
  function identity(value) {
    return value;
  }
});

// ../../node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array2 = require_postgres_array();
  module.exports = {
    create: function(source, transform2) {
      return {
        parse: function() {
          return array2.parse(source, transform2);
        }
      };
    }
  };
});

// ../../node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date5;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date5 = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
      if (is0To99(year)) {
        date5.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date5.setTime(date5.getTime() - offset);
      }
    } else {
      date5 = new Date(year, month, day, hour, minute, second, ms);
      if (is0To99(year)) {
        date5.setFullYear(year);
      }
    }
    return date5;
  };
  function getDate(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var date5 = new Date(year, month, day);
    if (is0To99(year)) {
      date5.setFullYear(year);
    }
    return date5;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type = zone[1];
    if (type === "Z") {
      return 0;
    }
    var sign = type === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  }
  function bcYearToNegativeYear(year) {
    return -(year - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
});

// ../../node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  module.exports = extend2;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend2(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// ../../node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var extend2 = require_mutable();
  module.exports = PostgresInterval;
  function PostgresInterval(raw) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw);
    }
    extend2(this, parse5(raw));
  }
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  }
  function parse5(interval) {
    if (!interval)
      return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value)
        return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  }
});

// ../../node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return new Buffer(input.substr(2), "hex");
    }
    var output = "";
    var i = 0;
    while (i < input.length) {
      if (input[i] !== "\\") {
        output += input[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input.length && input[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output, "binary");
  };
});

// ../../node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var array2 = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  function allowNull(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  }
  function parseBool(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  }
  function parseBoolArray(value) {
    if (!value)
      return null;
    return array2.parse(value, parseBool);
  }
  function parseBaseTenInt(string4) {
    return parseInt(string4, 10);
  }
  function parseIntegerArray(value) {
    if (!value)
      return null;
    return array2.parse(value, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value) {
    if (!value)
      return null;
    return array2.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array2.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array2.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value.length - 1; i++) {
      if (!pointParsed) {
        point += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// ../../node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var BASE = 1e6;
  function readInt8(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t = 4294967296 * carry + low;
      digits = "" + t % BASE;
      return sign + digits + result;
    }
  }
  module.exports = readInt8;
});

// ../../node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse5 = function(dimension, elementType2) {
      var array2 = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array2[i2] = parse5(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array2[i2] = parseElement(elementType2);
        }
      }
      return array2;
    };
    return parse5(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// ../../node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// ../../node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  }
  function setTypeParser(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  }
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// ../../node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// ../../node_modules/pg/lib/utils.js
var require_utils3 = __commonJS((exports, module) => {
  var defaults = require_defaults();
  var util2 = __require("util");
  var { isDate } = util2.types || util2;
  function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    let result = "{";
    for (let i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        let item = val[i];
        if (!(item instanceof Buffer)) {
          const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  }
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (isDate(val)) {
        if (defaults.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date5) {
    let offset = -date5.getTimezoneOffset();
    let year = date5.getFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date5.getMonth() + 1).padStart(2, "0") + "-" + String(date5.getDate()).padStart(2, "0") + "T" + String(date5.getHours()).padStart(2, "0") + ":" + String(date5.getMinutes()).padStart(2, "0") + ":" + String(date5.getSeconds()).padStart(2, "0") + "." + String(date5.getMilliseconds()).padStart(3, "0");
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function dateToStringUTC(date5) {
    let year = date5.getUTCFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date5.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date5.getUTCDate()).padStart(2, "0") + "T" + String(date5.getUTCHours()).padStart(2, "0") + ":" + String(date5.getUTCMinutes()).padStart(2, "0") + ":" + String(date5.getUTCSeconds()).padStart(2, "0") + "." + String(date5.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config2, values, callback) {
    config2 = typeof config2 === "string" ? { text: config2 } : config2;
    if (values) {
      if (typeof values === "function") {
        config2.callback = values;
      } else {
        config2.values = values;
      }
    }
    if (callback) {
      config2.callback = callback;
    }
    return config2;
  }
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    if (str == null) {
      return "''";
    }
    if (typeof str !== "string") {
      return "''";
    }
    for (let i = 0;i < str.length; i++) {
      const c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// ../../node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  function md5(string4) {
    return nodeCrypto.createHash("md5").update(string4, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user, password, salt) {
    const inner = md5(password + user);
    const outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha256(text2) {
    return nodeCrypto.createHash("sha256").update(text2).digest();
  }
  function hashByName(hashName, text2) {
    hashName = hashName.replace(/(\D)-/, "$1");
    return nodeCrypto.createHash(hashName).update(text2).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
});

// ../../node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
  function randomBytes(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  }
  async function md5(string4) {
    try {
      return nodeCrypto.createHash("md5").update(string4, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string4 === "string" ? textEncoder.encode(string4) : string4;
      const hash2 = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash2)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    const inner = await md5(password + user);
    const outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha256(text2) {
    return await subtleCrypto.digest("SHA-256", text2);
  }
  async function hashByName(hashName, text2) {
    return await subtleCrypto.digest(hashName, text2);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
});

// ../../node_modules/pg/lib/crypto/utils.js
var require_utils4 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// ../../node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS((exports, module) => {
  function x509Error(msg, cert) {
    return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
  }
  function readASN1Length(data, index) {
    let length = data[index++];
    if (length < 128)
      return { length, index };
    const lengthBytes = length & 127;
    if (lengthBytes > 4)
      throw x509Error("bad length", data);
    length = 0;
    for (let i = 0;i < lengthBytes; i++) {
      length = length << 8 | data[index++];
    }
    return { length, index };
  }
  function readASN1OID(data, index) {
    if (data[index++] !== 6)
      throw x509Error("non-OID data", data);
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
    index = indexAfterOIDLength;
    const lastIndex = index + OIDLength;
    const byte1 = data[index++];
    let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
    while (index < lastIndex) {
      let value = 0;
      while (index < lastIndex) {
        const nextByte = data[index++];
        value = value << 7 | nextByte & 127;
        if (nextByte < 128)
          break;
      }
      oid += "." + value;
    }
    return { oid, index };
  }
  function expectASN1Seq(data, index) {
    if (data[index++] !== 48)
      throw x509Error("non-sequence data", data);
    return readASN1Length(data, index);
  }
  function signatureAlgorithmHashFromCertificate(data, index) {
    if (index === undefined)
      index = 0;
    index = expectASN1Seq(data, index).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
    index = indexAfterCertInfoLength + certInfoLength;
    index = expectASN1Seq(data, index).index;
    const { oid, index: indexAfterOID } = readASN1OID(data, index);
    switch (oid) {
      case "1.2.840.113549.1.1.4":
        return "MD5";
      case "1.2.840.113549.1.1.5":
        return "SHA-1";
      case "1.2.840.113549.1.1.11":
        return "SHA-256";
      case "1.2.840.113549.1.1.12":
        return "SHA-384";
      case "1.2.840.113549.1.1.13":
        return "SHA-512";
      case "1.2.840.113549.1.1.14":
        return "SHA-224";
      case "1.2.840.113549.1.1.15":
        return "SHA512-224";
      case "1.2.840.113549.1.1.16":
        return "SHA512-256";
      case "1.2.840.10045.4.1":
        return "SHA-1";
      case "1.2.840.10045.4.3.1":
        return "SHA-224";
      case "1.2.840.10045.4.3.2":
        return "SHA-256";
      case "1.2.840.10045.4.3.3":
        return "SHA-384";
      case "1.2.840.10045.4.3.4":
        return "SHA-512";
      case "1.2.840.113549.1.1.10": {
        index = indexAfterOID;
        index = expectASN1Seq(data, index).index;
        if (data[index++] !== 160)
          throw x509Error("non-tag data", data);
        index = readASN1Length(data, index).index;
        index = expectASN1Seq(data, index).index;
        const { oid: hashOID } = readASN1OID(data, index);
        switch (hashOID) {
          case "1.2.840.113549.2.5":
            return "MD5";
          case "1.3.14.3.2.26":
            return "SHA-1";
          case "2.16.840.1.101.3.4.2.1":
            return "SHA-256";
          case "2.16.840.1.101.3.4.2.2":
            return "SHA-384";
          case "2.16.840.1.101.3.4.2.3":
            return "SHA-512";
        }
        throw x509Error("unknown hash OID " + hashOID, data);
      }
      case "1.3.101.110":
      case "1.3.101.112":
        return "SHA-512";
      case "1.3.101.111":
      case "1.3.101.113":
        throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
    }
    throw x509Error("unknown OID " + oid, data);
  }
  module.exports = { signatureAlgorithmHashFromCertificate };
});

// ../../node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var crypto = require_utils4();
  var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
  function startSession(mechanisms, stream) {
    const candidates = ["SCRAM-SHA-256"];
    if (stream)
      candidates.unshift("SCRAM-SHA-256-PLUS");
    const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
    if (!mechanism) {
      throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
    }
    if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream.getPeerCertificate !== "function") {
      throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
    }
    const clientNonce = crypto.randomBytes(18).toString("base64");
    const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream ? "y" : "n";
    return {
      mechanism,
      clientNonce,
      response: gs2Header + ",,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session, password, serverData, stream) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    let channelBinding = stream ? "eSws" : "biws";
    if (session.mechanism === "SCRAM-SHA-256-PLUS") {
      const peerCert = stream.getPeerCertificate().raw;
      let hashName = signatureAlgorithmHashFromCertificate(peerCert);
      if (hashName === "MD5" || hashName === "SHA-1")
        hashName = "SHA-256";
      const certHash = await crypto.hashByName(hashName, peerCert);
      const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
      channelBinding = bindingData.toString("base64");
    }
    const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
    const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, "base64");
    const saltedPassword = await crypto.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto.hmacSha256(saltedPassword, "Client Key");
    const storedKey = await crypto.sha256(clientKey);
    const clientSignature = await crypto.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    const serverKey = await crypto.hmacSha256(saltedPassword, "Server Key");
    const serverSignatureBytes = await crypto.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text2.split("").map((_, i) => text2.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  }
  function isBase64(text2) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text2);
  }
  function parseAttributePairs(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text2.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name18 = attrValue[0];
      const value = attrValue.substring(2);
      return [name18, value];
    }));
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  }
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// ../../node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var types = require_pg_types();
  function TypeOverrides(userTypes) {
    this._types = userTypes || types;
    this.text = {};
    this.binary = {};
  }
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// ../../node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  function parse5(str, options = {}) {
    if (str.charAt(0) === "/") {
      const config3 = str.split(" ");
      return { host: config3[0], database: config3[1] };
    }
    const config2 = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
    }
    try {
      try {
        result = new URL(str, "postgres://base");
      } catch (e) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
    } catch (err) {
      err.input && (err.input = "*****REDACTED*****");
    }
    for (const entry of result.searchParams.entries()) {
      config2[entry[0]] = entry[1];
    }
    config2.user = config2.user || decodeURIComponent(result.username);
    config2.password = config2.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config2.host = decodeURI(result.pathname);
      config2.database = result.searchParams.get("db");
      config2.client_encoding = result.searchParams.get("encoding");
      return config2;
    }
    const hostname3 = dummyHost ? "" : result.hostname;
    if (!config2.host) {
      config2.host = decodeURIComponent(hostname3);
    } else if (hostname3 && /^%2f/i.test(hostname3)) {
      result.pathname = hostname3 + result.pathname;
    }
    if (!config2.port) {
      config2.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config2.database = pathname ? decodeURI(pathname) : null;
    if (config2.ssl === "true" || config2.ssl === "1") {
      config2.ssl = true;
    }
    if (config2.ssl === "0") {
      config2.ssl = false;
    }
    if (config2.sslcert || config2.sslkey || config2.sslrootcert || config2.sslmode) {
      config2.ssl = {};
    }
    const fs = config2.sslcert || config2.sslkey || config2.sslrootcert ? __require("fs") : null;
    if (config2.sslcert) {
      config2.ssl.cert = fs.readFileSync(config2.sslcert).toString();
    }
    if (config2.sslkey) {
      config2.ssl.key = fs.readFileSync(config2.sslkey).toString();
    }
    if (config2.sslrootcert) {
      config2.ssl.ca = fs.readFileSync(config2.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config2.uselibpqcompat) {
      throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
    }
    if (config2.uselibpqcompat === "true" || options.useLibpqCompat) {
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
        case "require": {
          if (config2.sslrootcert) {
            config2.ssl.checkServerIdentity = function() {};
          } else {
            config2.ssl.rejectUnauthorized = false;
          }
          break;
        }
        case "verify-ca": {
          if (!config2.ssl.ca) {
            throw new Error("SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.");
          }
          config2.ssl.checkServerIdentity = function() {};
          break;
        }
        case "verify-full": {
          break;
        }
      }
    } else {
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
      }
    }
    return config2;
  }
  function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value]) => {
      if (value !== undefined && value !== null) {
        c[key] = value;
      }
      return c;
    }, {});
    return connectionOptions;
  }
  function toClientConfig(config2) {
    const poolConfig = Object.entries(config2).reduce((c, [key, value]) => {
      if (key === "ssl") {
        const sslConfig = value;
        if (typeof sslConfig === "boolean") {
          c[key] = sslConfig;
        }
        if (typeof sslConfig === "object") {
          c[key] = toConnectionOptions(sslConfig);
        }
      } else if (value !== undefined && value !== null) {
        if (key === "port") {
          if (value !== "") {
            const v = parseInt(value, 10);
            if (isNaN(v)) {
              throw new Error(`Invalid ${key}: ${value}`);
            }
            c[key] = v;
          }
        } else {
          c[key] = value;
        }
      }
      return c;
    }, {});
    return poolConfig;
  }
  function parseIntoClientConfig(str) {
    return toClientConfig(parse5(str));
  }
  module.exports = parse5;
  parse5.parse = parse5;
  parse5.toClientConfig = toClientConfig;
  parse5.parseIntoClientConfig = parseIntoClientConfig;
});

// ../../node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = __require("dns");
  var defaults = require_defaults();
  var parse5 = require_pg_connection_string().parse;
  var val = function(key, config2, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {} else {
      envVar = process.env[envVar];
    }
    return config2[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params, config2, paramName) {
    const value = config2[paramName];
    if (value !== undefined && value !== null) {
      params.push(paramName + "=" + quoteParamValue(value));
    }
  };

  class ConnectionParameters {
    constructor(config2) {
      config2 = typeof config2 === "string" ? parse5(config2) : config2 || {};
      if (config2.connectionString) {
        config2 = Object.assign({}, config2, parse5(config2.connectionString));
      }
      this.user = val("user", config2);
      this.database = val("database", config2);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config2), 10);
      this.host = val("host", config2);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config2)
      });
      this.binary = val("binary", config2);
      this.options = val("options", config2);
      this.ssl = typeof config2.ssl === "undefined" ? readSSLConfigFromEnvironment() : config2.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config2);
      this.replication = val("replication", config2);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config2, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config2, false);
      this.statement_timeout = val("statement_timeout", config2, false);
      this.lock_timeout = val("lock_timeout", config2, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config2, false);
      this.query_timeout = val("query_timeout", config2, false);
      if (config2.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config2.connectionTimeoutMillis / 1000);
      }
      if (config2.keepAlive === false) {
        this.keepalives = 0;
      } else if (config2.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config2.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config2.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      const params = [];
      add(params, this, "user");
      add(params, this, "password");
      add(params, this, "port");
      add(params, this, "application_name");
      add(params, this, "fallback_application_name");
      add(params, this, "connect_timeout");
      add(params, this, "options");
      const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params, ssl, "sslmode");
      add(params, ssl, "sslca");
      add(params, ssl, "sslkey");
      add(params, ssl, "sslcert");
      add(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err, address) {
        if (err)
          return cb(err, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// ../../node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types2) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types2;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      let match;
      if (msg.text) {
        match = matchRegexp.exec(msg.text);
      } else {
        match = matchRegexp.exec(msg.command);
      }
      if (match) {
        this.command = match[1];
        if (match[3]) {
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      const row = new Array(rowData.length);
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      const row = { ...this._prebuiltEmptyResultObject };
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        const field = this.fields[i].name;
        if (rawValue !== null) {
          const v = this.fields[i].format === "binary" ? Buffer.from(rawValue) : rawValue;
          row[field] = this._parsers[i](v);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      const row = {};
      for (let i = 0;i < fieldDescriptions.length; i++) {
        const desc = fieldDescriptions[i];
        row[desc.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
        } else {
          this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// ../../node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var Result = require_result();
  var utils = require_utils3();

  class Query extends EventEmitter {
    constructor(config2, values, callback) {
      super();
      config2 = utils.normalizeQueryConfig(config2, values, callback);
      this.text = config2.text;
      this.values = config2.values;
      this.rows = config2.rows;
      this.types = config2.types;
      this.name = config2.name;
      this.queryMode = config2.queryMode;
      this.binary = config2.binary;
      this.portal = config2.portal || "";
      this.callback = config2.callback;
      this._rowMode = config2.rowMode;
      if (process.domain && config2.callback) {
        this.callback = process.domain.bind(config2.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection.sync();
      }
    }
    handleEmptyQuery(connection) {
      if (this.rows) {
        connection.sync();
      }
    }
    handleError(err, connection) {
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err);
      }
      this.emit("error", err);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        connection.stream.cork && connection.stream.cork();
        try {
          this.prepare(connection);
        } finally {
          connection.stream.uncork && connection.stream.uncork();
        }
      } else {
        connection.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection) {
      return this.name && connection.parsedStatements[this.name];
    }
    handlePortalSuspended(connection) {
      this._getRows(connection, this.rows);
    }
    _getRows(connection, rows) {
      connection.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection.sync();
      } else {
        connection.flush();
      }
    }
    prepare(connection) {
      if (!this.hasBeenParsed(connection)) {
        connection.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection);
        return;
      }
      connection.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection, this.rows);
    }
    handleCopyInResponse(connection) {
      connection.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection) {}
  }
  module.exports = Query;
});

// ../../node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name18) {
      super(message);
      this.length = length;
      this.name = name18;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name18, binary, columnCount) {
      this.length = length;
      this.name = name18;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name18, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name18;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text2) {
      this.length = length;
      this.text = text2;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// ../../node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      const remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        const oldBuffer = this.buffer;
        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string4) {
      if (!string4) {
        this.ensure(1);
      } else {
        const len = Buffer.byteLength(string4);
        this.ensure(len + 1);
        this.buffer.write(string4, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string4 = "") {
      const len = Buffer.byteLength(string4);
      this.ensure(len);
      this.buffer.write(string4, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      const result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// ../../node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    const bodyBuffer = writer.addCString("").flush();
    const length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query = (text2) => {
    return writer.addCString(text2).flush(81);
  };
  var emptyArray = [];
  var parse5 = (query2) => {
    const name18 = query2.name || "";
    if (name18.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name18, name18.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types = query2.types || emptyArray;
    const len = types.length;
    const buffer = writer.addCString(name18).addCString(query2.text).addInt16(len);
    for (let i = 0;i < len; i++) {
      buffer.addInt32(types[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values, valueMapper) {
    for (let i = 0;i < values.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config2 = {}) => {
    const portal = config2.portal || "";
    const statement = config2.statement || "";
    const binary = config2.binary || false;
    const values = config2.values || emptyArray;
    const len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config2.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(1);
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute = (config2) => {
    if (!config2 || !config2.portal && !config2.rows) {
      return emptyExecute;
    }
    const portal = config2.portal || "";
    const rows = config2.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string4) => {
    const stringLen = Buffer.byteLength(string4);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string4, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text2 = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text2);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query,
    parse: parse5,
    bind,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize;
});

// ../../node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    uint32() {
      const result = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {}
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// ../../node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text2 = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text2);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name18 = this.reader.cstring();
      const tableID = this.reader.uint32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.uint32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name18, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name18 = this.reader.cstring();
      const value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name18, value);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          {
            message.name = "authenticationSASL";
            message.mechanisms = [];
            let mechanism;
            do {
              mechanism = this.reader.cstring();
              if (mechanism) {
                message.mechanisms.push(mechanism);
              }
            } while (mechanism);
          }
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name18) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\x00") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name18 === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name18);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports.Parser = Parser;
});

// ../../node_modules/pg-protocol/dist/index.js
var require_dist12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  function parse5(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve2) => stream.on("end", () => resolve2()));
  }
  exports.parse = parse5;
});

// ../../node_modules/pg-cloudflare/dist/empty.js
var require_empty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {};
});

// ../../node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { getStream, getSecureStream } = getStreamFuncs();
  module.exports = {
    getStream,
    getSecureStream
  };
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net = __require("net");
      return new net.Socket;
    }
    function getSecureStream2(options) {
      const tls = __require("tls");
      return tls.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = require_empty();
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
});

// ../../node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var { parse: parse5, serialize } = require_dist12();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize.flush();
  var syncBuffer = serialize.sync();
  var endBuffer = serialize.end();

  class Connection extends EventEmitter {
    constructor(config2) {
      super();
      config2 = config2 || {};
      this.stream = config2.stream || getStream(config2.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config2);
      }
      this._keepAlive = config2.keepAlive;
      this._keepAliveInitialDelayMillis = config2.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config2.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      const self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      const self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error46) {
        if (self2._ending && (error46.code === "ECONNRESET" || error46.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error46);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        const responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        const net = __require("net");
        if (net.isIP && net.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err) {
          return self2.emit("error", err);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse5(stream, (msg) => {
        const eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize.requestSsl());
    }
    startup(config2) {
      this.stream.write(serialize.startup(config2));
    }
    cancel(processID, secretKey) {
      this._send(serialize.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text2) {
      this._send(serialize.query(text2));
    }
    parse(query) {
      this._send(serialize.parse(query));
    }
    bind(config2) {
      this._send(serialize.bind(config2));
    }
    execute(config2) {
      this._send(serialize.execute(config2));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize.close(msg));
    }
    describe(msg) {
      this._send(serialize.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// ../../node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var { Transform } = __require("stream");
  var { StringDecoder } = __require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  function transform2(chunk, enc, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list = buf.split(this.matcher);
      if (list.length === 1)
        return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i = 0;i < list.length; i++) {
      try {
        push(this, this.mapper(list[i]));
      } catch (error46) {
        return cb(error46);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error46) {
        return cb(error46);
      }
    }
    cb();
  }
  function push(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  }
  function noop3(incoming) {
    return incoming;
  }
  function split(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop3;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop3;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform2;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
      this._writableState.errorEmitted = false;
      cb(err);
    };
    return stream;
  }
  module.exports = split;
});

// ../../node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var path = __require("path");
  var Stream = __require("stream").Stream;
  var split = require_split2();
  var util2 = __require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
  }
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  function warn() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat(`
`);
      warnStream.write(util2.format.apply(util2, args));
    }
  }
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env = rawEnv || process.env;
    var file2 = env.PGPASSFILE || (isWin ? path.join(env.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env.HOME || "./", ".pgpass"));
    return file2;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
      if (idx == 1) {
        if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
          return prev && true;
        }
      }
      return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line) {
      var entry = parseLine(line);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
      var field = line.substring(i0, i1);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field = field.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field;
    };
    for (var i = 0;i < line.length - 1; i += 1) {
      curChar = line.charAt(i + 1);
      prevChar = line.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value = entry[fieldNames[idx]] || "";
      var res = rule(value);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// ../../node_modules/pgpass/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file2 = helper.getFileName();
    fs.stat(file2, function(err, stat) {
      if (err || !helper.usePgPass(stat, file2)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file2);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// ../../node_modules/pg/lib/client.js
var require_client = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var utils = require_utils3();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults = require_defaults();
  var Connection = require_connection();
  var crypto = require_utils4();

  class Client2 extends EventEmitter {
    constructor(config2) {
      super();
      this.connectionParameters = new ConnectionParameters(config2);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      const c = config2 || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.enableChannelBinding = Boolean(c.enableChannelBinding);
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.handleError(err, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      const self2 = this;
      const con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
        if (this.connectionTimeoutHandle.unref) {
          this.connectionTimeoutHandle.unref();
        }
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error46 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error46);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error46);
            } else {
              this._handleErrorEvent(error46);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error46);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve2, reject) => {
        this._connect((error46) => {
          if (error46) {
            reject(error46);
          } else {
            resolve2();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err) => {
          con.emit("error", err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }
      this.emit("error", err);
    }
    _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }
      this._queryable = false;
      this._errorAllQueries(err);
      this.emit("error", err);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      if (this.activeQuery == null) {
        const error46 = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error46);
        return;
      }
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      if (this.activeQuery == null) {
        const error46 = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error46);
        return;
      }
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      const params = this.connectionParameters;
      const data = {
        user: params.user,
        database: params.database
      };
      const appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client, query) {
      if (client.activeQuery === query) {
        const con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config2, values, callback) {
      let query;
      let result;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config2 === null || config2 === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config2.submit === "function") {
        readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
        result = query = config2;
        if (typeof values === "function") {
          query.callback = query.callback || values;
        }
      } else {
        readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
        query = new Query(config2, values, callback);
        if (!query.callback) {
          result = new this._Promise((resolve2, reject) => {
            query.callback = (err, res) => err ? reject(err) : resolve2(res);
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          const error46 = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error46, this.connection);
          });
          queryCallback(error46);
          query.callback = () => {};
          const index = this.queryQueue.indexOf(query);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (this.binary && !query.binary) {
        query.binary = true;
      }
      if (query._result && !query._result._types) {
        query._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve2) => {
          this.connection.once("end", resolve2);
        });
      }
    }
  }
  Client2.Query = Query;
  module.exports = Client2;
});

// ../../node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var NOOP = function() {};
  var removeWhere = (list, predicate) => {
    const i = list.findIndex(predicate);
    return i === -1 ? undefined : list.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client, idleListener, timeoutId) {
      this.client = client;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise2, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err, client) {
      err ? rej(err) : res(client);
    };
    const result = new Promise2(function(resolve2, reject) {
      res = resolve2;
      rej = reject;
    }).catch((err) => {
      Error.captureStackTrace(err);
      throw err;
    });
    return { callback: cb, result };
  }
  function makeIdleListener(pool, client) {
    return function idleListener(err) {
      err.client = client;
      client.removeListener("error", idleListener);
      client.on("error", () => {
        pool.log("additional client error after disconnection due to error", err);
      });
      pool._remove(client);
      pool.emit("error", err, client);
    };
  }

  class Pool extends EventEmitter {
    constructor(options, Client2) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.min = this.options.min || 0;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {};
      this.Client = this.options.Client || Client2 || require_lib2().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client = idleItem.client;
        client.ref && client.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client, callback) {
      const removed = removeWhere(this._idle, (item) => item.client === client);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client);
      const context = this;
      client.end(() => {
        context.emit("remove", client);
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    connect(cb) {
      if (this.ending) {
        const err = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err, res, done) => {
          clearTimeout(tid);
          response.callback(err, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        if (tid.unref) {
          tid.unref();
        }
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client = new this.Client(this.options);
      this._clients.push(client);
      const idleListener = makeIdleListener(this, client);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client.connect((err) => {
        if (tid) {
          clearTimeout(tid);
        }
        client.on("error", idleListener);
        if (err) {
          this.log("client failed to connect", err);
          this._clients = this._clients.filter((c) => c !== client);
          if (timeoutHit) {
            err = new Error("Connection terminated due to connection timeout", { cause: err });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
              if (idleIndex !== -1) {
                this._acquireClient(client, new PendingItem((err2, client2, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client);
      }
      this.emit("acquire", client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, (err) => {
            if (err) {
              client.release(err);
              return pendingItem.callback(err, undefined, NOOP);
            }
            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    }
    _releaseOnce(client, idleListener) {
      let released = false;
      return (err) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client, idleListener, err);
      };
    }
    _release(client, idleListener, err) {
      client.on("error", idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1;
      this.emit("release", err, client);
      if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        return this._remove(client, this._pulseQueue.bind(this));
      }
      const isExpired = this._expired.has(client);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client);
        return this._remove(client, this._pulseQueue.bind(this));
      }
      let tid;
      if (this.options.idleTimeoutMillis && this._isAboveMin()) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client, this._pulseQueue.bind(this));
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client.unref();
      }
      this._idle.push(new IdleItem(client, idleListener, tid));
      this._pulseQueue();
    }
    query(text2, values, cb) {
      if (typeof text2 === "function") {
        const response2 = promisify(this.Promise, text2);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values === "function") {
        cb = values;
        values = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err, client) => {
        if (err) {
          return cb(err);
        }
        let clientReleased = false;
        const onError = (err2) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client.release(err2);
          cb(err2);
        };
        client.once("error", onError);
        this.log("dispatching query");
        try {
          client.query(text2, values, (err2, res) => {
            this.log("query dispatched");
            client.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err2);
            if (err2) {
              return cb(err2);
            }
            return cb(undefined, res);
          });
        } catch (err2) {
          client.release(err2);
          return cb(err2);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err = new Error("Called end on pool more than once");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// ../../node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var util2 = __require("util");
  var utils = require_utils3();
  var NativeQuery = module.exports = function(config2, values, callback) {
    EventEmitter.call(this);
    config2 = utils.normalizeQueryConfig(config2, values, callback);
    this.text = config2.text;
    this.values = config2.values;
    this.name = config2.name;
    this.queryMode = config2.queryMode;
    this.callback = config2.callback;
    this.state = "new";
    this._arrayMode = config2.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util2.inherits(NativeQuery, EventEmitter);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err) {
    const fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (const key in fields) {
        const normalizedFieldName = errorFieldMap[key] || key;
        err[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err);
    } else {
      this.emit("error", err);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve2, reject) {
      this._once("end", resolve2);
      this._once("error", reject);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client) {
    this.state = "running";
    const self2 = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    let after = function(err, rows, results) {
      client.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err) {
        return self2.handleError(err);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const values = (this.values || []).map(utils.prepareValue);
      if (client.namedQueries[this.name]) {
        if (this.text && client.namedQueries[this.name] !== this.text) {
          const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err);
        }
        return client.native.execute(this.name, values, after);
      }
      return client.native.prepare(this.name, this.text, values.length, function(err) {
        if (err)
          return after(err);
        client.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err = new Error("Query values must be an array");
        return after(err);
      }
      const vals = this.values.map(utils.prepareValue);
      client.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client.native.query(this.text, [], after);
    } else {
      client.native.query(this.text, after);
    }
  };
});

// ../../node_modules/pg/lib/native/client.js
var require_client2 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = (()=>{throw new Error("Cannot require module "+"pg-native");})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter = __require("events").EventEmitter;
  var util2 = __require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client2 = module.exports = function(config2) {
    EventEmitter.call(this);
    config2 = config2 || {};
    this._Promise = config2.Promise || global.Promise;
    this._types = new TypeOverrides(config2.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    const cp = this.connectionParameters = new ConnectionParameters(config2);
    if (config2.nativeConnectionString)
      cp.nativeConnectionString = config2.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client2.Query = NativeQuery;
  util2.inherits(Client2, EventEmitter);
  Client2.prototype._errorAllQueries = function(err) {
    const enqueueError = (query) => {
      process.nextTick(() => {
        query.native = this.native;
        query.handleError(err);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client2.prototype._connect = function(cb) {
    const self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err)
        return cb(err);
      self2.native.connect(conString, function(err2) {
        if (err2) {
          self2.native.end();
          return cb(err2);
        }
        self2._connected = true;
        self2.native.on("error", function(err3) {
          self2._queryable = false;
          self2._errorAllQueries(err3);
          self2.emit("error", err3);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client2.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve2, reject) => {
      this._connect((error46) => {
        if (error46) {
          reject(error46);
        } else {
          resolve2();
        }
      });
    });
  };
  Client2.prototype.query = function(config2, values, callback) {
    let query;
    let result;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config2 === null || config2 === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config2.submit === "function") {
      readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
      result = query = config2;
      if (typeof values === "function") {
        config2.callback = values;
      }
    } else {
      readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
      query = new NativeQuery(config2, values, callback);
      if (!query.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve2, reject) => {
          resolveOut = resolve2;
          rejectOut = reject;
        }).catch((err) => {
          Error.captureStackTrace(err);
          throw err;
        });
        query.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query.callback;
      readTimeoutTimer = setTimeout(() => {
        const error46 = new Error("Query read timeout");
        process.nextTick(() => {
          query.handleError(error46, this.connection);
        });
        queryCallback(error46);
        query.callback = () => {};
        const index = this._queryQueue.indexOf(query);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query.callback = (err, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err, res);
      };
    }
    if (!this._queryable) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query);
    this._pulseQueryQueue();
    return result;
  };
  Client2.prototype.end = function(cb) {
    const self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    let result;
    if (!cb) {
      result = new this._Promise(function(resolve2, reject) {
        cb = (err) => err ? reject(err) : resolve2();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client2.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client2.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    const query = this._queryQueue.shift();
    if (!query) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query;
    query.submit(this);
    const self2 = this;
    query.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client2.prototype.cancel = function(query) {
    if (this._activeQuery === query) {
      this.native.cancel(function() {});
    } else if (this._queryQueue.indexOf(query) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
    }
  };
  Client2.prototype.ref = function() {};
  Client2.prototype.unref = function() {};
  Client2.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client2.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// ../../node_modules/pg/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var Client2 = require_client();
  var defaults = require_defaults();
  var Connection = require_connection();
  var Result = require_result();
  var utils = require_utils3();
  var Pool = require_pg_pool();
  var TypeOverrides = require_type_overrides();
  var { DatabaseError } = require_dist12();
  var { escapeIdentifier, escapeLiteral } = require_utils3();
  var poolFactory = (Client3) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client3);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.TypeOverrides = TypeOverrides;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
    this.Result = Result;
    this.utils = utils;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client2());
  } else {
    module.exports = new PG(Client2);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        let native = null;
        try {
          native = new PG(require_client2());
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND") {
            throw err;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// src/discord/bot.ts
var import_discord2 = __toESM(require_src(), 1);

// src/discord/embedBuilder/embedBuilder.ts
var import_discord = __toESM(require_src(), 1);

class EmbedResponse {
  static MAX_EMBED_DESCRIPTION = 4096;
  static MAX_EMBEDS_PER_MESSAGE = 10;
  static DEFAULT_COLOR = 5793266;
  static async sendLongResponse(message, content, options) {
    const chunks = this.chunkContent(content);
    const embeds = [];
    for (let i = 0;i < chunks.length && i < this.MAX_EMBEDS_PER_MESSAGE; i++) {
      const chunk = chunks[i] ?? "";
      const embed = new import_discord.EmbedBuilder().setDescription(chunk.trimEnd()).setColor(options?.color ?? this.DEFAULT_COLOR);
      if (i === 0 && options?.title) {
        embed.setTitle(options.title);
      }
      if (chunks.length > 1) {
        embed.setFooter({
          text: `Page ${i + 1} of ${Math.min(chunks.length, this.MAX_EMBEDS_PER_MESSAGE)}`
        });
      }
      if (i === 0 && options?.includeContext) {
        embed.setAuthor({
          name: "Aigis",
          iconURL: message.client.user?.displayAvatarURL() || undefined
        });
      }
      embeds.push(embed);
    }
    try {
      if ("send" in message.channel) {
        await message.channel.send({
          embeds,
          reply: { messageReference: message.id },
          allowedMentions: { repliedUser: false }
        });
      } else {
        await message.reply({
          embeds,
          allowedMentions: { repliedUser: false }
        });
      }
    } catch (error) {
      console.error("Failed to send embed response:", error);
      const truncated = content.length > 2000 ? content.substring(0, 1997) + "..." : content;
      try {
        if ("send" in message.channel) {
          await message.channel.send({
            content: truncated,
            reply: { messageReference: message.id },
            allowedMentions: { repliedUser: false }
          });
        } else {
          await message.reply({
            content: truncated,
            allowedMentions: { repliedUser: false }
          });
        }
      } catch {
        await message.reply(truncated);
      }
    }
  }
  static chunkContent(content) {
    if (content.length <= this.MAX_EMBED_DESCRIPTION) {
      return [content.trimEnd()];
    }
    const chunks = [];
    let remaining = content.trim();
    while (remaining.length > 0) {
      if (remaining.length <= this.MAX_EMBED_DESCRIPTION) {
        chunks.push(remaining.trimEnd());
        break;
      }
      let breakPoint = this.MAX_EMBED_DESCRIPTION;
      const window2 = remaining.substring(0, this.MAX_EMBED_DESCRIPTION);
      const lastNewline = window2.lastIndexOf(`
`);
      if (lastNewline > this.MAX_EMBED_DESCRIPTION * 0.7) {
        breakPoint = lastNewline;
      } else {
        const lastSentence = Math.max(window2.lastIndexOf(". "), window2.lastIndexOf("! "), window2.lastIndexOf("? "));
        if (lastSentence > this.MAX_EMBED_DESCRIPTION * 0.7) {
          breakPoint = lastSentence + 1;
        } else {
          const lastSpace = window2.lastIndexOf(" ");
          if (lastSpace > this.MAX_EMBED_DESCRIPTION * 0.7) {
            breakPoint = lastSpace;
          }
        }
      }
      chunks.push(remaining.substring(0, breakPoint).trim());
      remaining = remaining.substring(breakPoint).trim();
    }
    return chunks.map((c) => c.trimEnd());
  }
  static async sendError(message, error) {
    const embed = new import_discord.EmbedBuilder().setTitle("\u274C Error").setDescription(error).setColor(16711680);
    await message.reply({
      embeds: [embed],
      allowedMentions: { repliedUser: false }
    });
  }
  static async sendInfo(message, title, description) {
    const embed = new import_discord.EmbedBuilder().setTitle(title).setDescription(description).setColor(65280);
    await message.reply({
      embeds: [embed],
      allowedMentions: { repliedUser: false }
    });
  }
}

// ../../node_modules/@ai-sdk/provider/dist/index.mjs
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  constructor({
    name: name14,
    message,
    cause
  }) {
    super(message);
    this[_a] = true;
    this.name = name14;
    this.cause = cause;
  }
  static isInstance(error) {
    return _AISDKError2.hasMarker(error, marker);
  }
  static hasMarker(error, marker15) {
    const markerSymbol = Symbol.for(marker15);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a = symbol;
var AISDKError = _AISDKError;
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var APICallError = class extends AISDKError {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || statusCode === 409 || statusCode === 429 || statusCode >= 500),
    data
  }) {
    super({ name, message, cause });
    this[_a2] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker2);
  }
};
_a2 = symbol2;
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
var EmptyResponseBodyError = class extends AISDKError {
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name2, message });
    this[_a3] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker3);
  }
};
_a3 = symbol3;
function getErrorMessage(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4);
  }
};
_a4 = symbol4;
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var InvalidPromptError = class extends AISDKError {
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name4, message: `Invalid prompt: ${message}`, cause });
    this[_a5] = true;
    this.prompt = prompt;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker5);
  }
};
_a5 = symbol5;
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
_a6 = symbol6;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  constructor({ text, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = true;
    this.text = text;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7);
  }
};
_a7 = symbol7;
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
_a8 = symbol8;
var name8 = "AI_LoadSettingError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
_a9 = symbol9;
var name9 = "AI_NoContentGeneratedError";
var marker10 = `vercel.ai.error.${name9}`;
var symbol10 = Symbol.for(marker10);
var _a10;
_a10 = symbol10;
var name10 = "AI_NoSuchModelError";
var marker11 = `vercel.ai.error.${name10}`;
var symbol11 = Symbol.for(marker11);
var _a11;
var NoSuchModelError = class extends AISDKError {
  constructor({
    errorName = name10,
    modelId,
    modelType,
    message = `No such ${modelType}: ${modelId}`
  }) {
    super({ name: errorName, message });
    this[_a11] = true;
    this.modelId = modelId;
    this.modelType = modelType;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker11);
  }
};
_a11 = symbol11;
var name11 = "AI_TooManyEmbeddingValuesForCallError";
var marker12 = `vercel.ai.error.${name11}`;
var symbol12 = Symbol.for(marker12);
var _a12;
_a12 = symbol12;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13);
  }
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
_a14 = symbol14;

// ../../node_modules/eventsource-parser/dist/index.js
class ParseError extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
}
function noop(_arg) {}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\x00") ? undefined : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
          type: "invalid-retry",
          value,
          line
        }));
        break;
      default:
        onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, { type: "unknown-field", field, value, line }));
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || undefined,
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = undefined, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = undefined, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (;searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}

// ../../node_modules/eventsource-parser/dist/stream.js
class EventSourceParserStream extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
}

// ../../node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  util: () => exports_util,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol15,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeEncode: () => safeEncode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeDecode: () => safeDecode2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse3,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  encodeAsync: () => encodeAsync2,
  encode: () => encode2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  decodeAsync: () => decodeAsync2,
  decode: () => decode2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  codec: () => codec,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// ../../node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  safeEncodeAsync: () => safeEncodeAsync,
  safeEncode: () => safeEncode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeDecode: () => safeDecode,
  registry: () => registry,
  regexes: () => exports_regexes,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  formatError: () => formatError,
  flattenError: () => flattenError,
  encodeAsync: () => encodeAsync,
  encode: () => encode,
  decodeAsync: () => decodeAsync,
  decode: () => decode,
  config: () => config,
  clone: () => clone,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _superRefine: () => _superRefine,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeEncode: () => _safeEncode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeDecode: () => _safeDecode,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _encodeAsync: () => _encodeAsync,
  _encode: () => _encode,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _decodeAsync: () => _decodeAsync,
  _decode: () => _decode,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _check: () => _check,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCodec: () => $ZodCodec,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// ../../node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name14, initializer, params) {
  function init(inst, def) {
    var _a15;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a15 = inst._zod).traits ?? (_a15.traits = new Set);
    inst._zod.traits.add(name14);
    initializer(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name14 });
  function _(def) {
    var _a15;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a15 = inst._zod).deferred ?? (_a15.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name14);
    }
  });
  Object.defineProperty(_, "name", { value: name14 });
  return _;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}

class $ZodEncodeError extends Error {
  constructor(name14) {
    super(`Encountered unidirectional transform during encode: ${name14}`);
    this.name = "ZodEncodeError";
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// ../../node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  uint8ArrayToHex: () => uint8ArrayToHex,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  stringifyPrimitive: () => stringifyPrimitive,
  shallowClone: () => shallowClone,
  safeExtend: () => safeExtend,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  objectClone: () => objectClone,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  mergeDefs: () => mergeDefs,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  hexToUint8Array: () => hexToUint8Array,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  cloneDef: () => cloneDef,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  base64urlToUint8Array: () => base64urlToUint8Array,
  base64ToUint8Array: () => base64ToUint8Array,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error;
}
function assert(_) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
  let value = undefined;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a15;
    (_a15 = iss).path ?? (_a15.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base64.length % 4) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class {
  constructor(..._args) {}
}

// ../../node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error2, path = []) => {
    var _a15, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a15 = curr.properties)[el] ?? (_a15[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}

// ../../node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
// ../../node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  sha512_hex: () => sha512_hex,
  sha512_base64url: () => sha512_base64url,
  sha512_base64: () => sha512_base64,
  sha384_hex: () => sha384_hex,
  sha384_base64url: () => sha384_base64url,
  sha384_base64: () => sha384_base64,
  sha256_hex: () => sha256_hex,
  sha256_base64url: () => sha256_base64url,
  sha256_base64: () => sha256_base64,
  sha1_hex: () => sha1_hex,
  sha1_base64url: () => sha1_base64url,
  sha1_base64: () => sha1_base64,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  md5_hex: () => md5_hex,
  md5_base64url: () => md5_base64url,
  md5_base64: () => md5_base64,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  idnEmail: () => idnEmail,
  html5Email: () => html5Email,
  hostname: () => hostname,
  hex: () => hex,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// ../../node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a15;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a15 = inst._zod).onattach ?? (_a15.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a15;
    (_a15 = inst2._zod.bag).multipleOf ?? (_a15.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def);
  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def);
  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def);
  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def);
  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def);
  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def);
  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a15, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a15 = inst._zod).check ?? (_a15.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// ../../node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// ../../node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 1,
  patch: 12
};

// ../../node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a15;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a15 = inst._zod).deferred ?? (_a15.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError;
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error;
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = new Set;
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = new Map;
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError;
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// ../../node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  yo: () => yo_default,
  vi: () => vi_default,
  ur: () => ur_default,
  uk: () => uk_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  lt: () => lt_default,
  ko: () => ko_default,
  km: () => km_default,
  kh: () => kh_default,
  ka: () => ka_default,
  ja: () => ja_default,
  it: () => it_default,
  is: () => is_default,
  id: () => id_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  da: () => da_default,
  cs: () => cs_default,
  ca: () => ca_default,
  bg: () => bg_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// ../../node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}
// ../../node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}
// ../../node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}
// ../../node_modules/zod/v4/locales/bg.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u043C\u0430\u0441\u0438\u0432";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}
// ../../node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}
// ../../node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}
// ../../node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType2(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}
// ../../node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}
// ../../node_modules/zod/v4/locales/en.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}
// ../../node_modules/zod/v4/locales/eo.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}
// ../../node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType4(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${getTypeName(issue2.origin)}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${getTypeName(issue2.origin)}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}
// ../../node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType4(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}
// ../../node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}
// ../../node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType4(issue2.input)} re\xE7u`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}
// ../../node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
// ../../node_modules/zod/v4/locales/he.js
var error16 = () => {
  const Sizable = {
    string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}
// ../../node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}
// ../../node_modules/zod/v4/locales/id.js
var error18 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error18()
  };
}
// ../../node_modules/zod/v4/locales/is.js
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "n\xFAmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error19 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue2.input)} \xFEar sem \xE1 a\xF0 vera ${issue2.expected}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error19()
  };
}
// ../../node_modules/zod/v4/locales/it.js
var error20 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error20()
  };
}
// ../../node_modules/zod/v4/locales/ja.js
var error21 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType5(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error21()
  };
}
// ../../node_modules/zod/v4/locales/ka.js
var parsedType5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
  };
  return typeMap[t] ?? t;
};
var error22 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default() {
  return {
    localeError: error22()
  };
}
// ../../node_modules/zod/v4/locales/km.js
var error23 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default() {
  return {
    localeError: error23()
  };
}

// ../../node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
// ../../node_modules/zod/v4/locales/ko.js
var error24 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType6(issue2.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error24()
  };
}
// ../../node_modules/zod/v4/locales/lt.js
var parsedType6 = (data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
};
var parsedTypeFromType = (t, data = undefined) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
    }
    case "bigint": {
      return "sveikasis skai\u010Dius";
    }
    case "string": {
      return "eilut\u0117";
    }
    case "boolean": {
      return "login\u0117 reik\u0161m\u0117";
    }
    case "undefined":
    case "void": {
      return "neapibr\u0117\u017Eta reik\u0161m\u0117";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === undefined)
        return "ne\u017Einomas objektas";
      if (data === null)
        return "nulin\u0117 reik\u0161m\u0117";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    case "null": {
      return "nulin\u0117 reik\u0161m\u0117";
    }
  }
  return t;
};
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number2) {
  const abs = Math.abs(number2);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error25 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType6(issue2.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue2.expected)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue2.origin);
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error25()
  };
}
// ../../node_modules/zod/v4/locales/mk.js
var error26 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error26()
  };
}
// ../../node_modules/zod/v4/locales/ms.js
var error27 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error27()
  };
}
// ../../node_modules/zod/v4/locales/nl.js
var error28 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error28()
  };
}
// ../../node_modules/zod/v4/locales/no.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error29()
  };
}
// ../../node_modules/zod/v4/locales/ota.js
var error30 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error30()
  };
}
// ../../node_modules/zod/v4/locales/ps.js
var error31 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType7(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error31()
  };
}
// ../../node_modules/zod/v4/locales/pl.js
var error32 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error32()
  };
}
// ../../node_modules/zod/v4/locales/pt.js
var error33 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error33()
  };
}
// ../../node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error34 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error34()
  };
}
// ../../node_modules/zod/v4/locales/sl.js
var error35 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error35()
  };
}
// ../../node_modules/zod/v4/locales/sv.js
var error36 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error36()
  };
}
// ../../node_modules/zod/v4/locales/ta.js
var error37 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error37()
  };
}
// ../../node_modules/zod/v4/locales/th.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error38()
  };
}
// ../../node_modules/zod/v4/locales/tr.js
var parsedType7 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error39 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error39()
  };
}
// ../../node_modules/zod/v4/locales/uk.js
var error40 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default() {
  return {
    localeError: error40()
  };
}

// ../../node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
// ../../node_modules/zod/v4/locales/ur.js
var error41 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error41()
  };
}
// ../../node_modules/zod/v4/locales/vi.js
var error42 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error42()
  };
}
// ../../node_modules/zod/v4/locales/zh-CN.js
var error43 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error43()
  };
}
// ../../node_modules/zod/v4/locales/zh-TW.js
var error44 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error44()
  };
}
// ../../node_modules/zod/v4/locales/yo.js
var error45 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop\u1ECD";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default() {
  return {
    localeError: error45()
  };
}
// ../../node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var globalRegistry = /* @__PURE__ */ registry();
// ../../node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
// ../../node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a15;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.minimum = exclusiveMinimum;
                json.exclusiveMinimum = true;
              } else {
                json.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.maximum = exclusiveMaximum;
                json.exclusiveMaximum = true;
              } else {
                json.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === undefined;
              } else {
                return v.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            json.anyOf = options;
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
              if (rest) {
                json.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json.items.anyOf.push(rest);
              }
              json.minItems = prefixItems.length;
              if (!rest) {
                json.maxItems = prefixItems.length;
              }
            } else {
              json.items = prefixItems;
              if (rest) {
                json.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.enum = [val];
              } else {
                json.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== undefined)
              file.minLength = minimum;
            if (maximum !== undefined)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a15 = result.schema).default ?? (_a15.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {} else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
// ../../node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// ../../node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// ../../node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// ../../node_modules/zod/v4/classic/parse.js
var parse3 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// ../../node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks2) => {
    return inst.clone(exports_util.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }));
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: exports_regexes.domain,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol15(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  exports_util.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return exports_util.safeExtend(inst, incoming);
  };
  inst.merge = (other) => exports_util.merge(inst, other);
  inst.pick = (mask) => exports_util.pick(inst, mask);
  inst.omit = (mask) => exports_util.omit(inst, mask);
  inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = undefined;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
// ../../node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// ../../node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// ../../node_modules/zod/v4/classic/external.js
config(en_default());
// ../../node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {};
  function assertIs2(_arg) {}
  util2.assertIs = assertIs2;
  function assertNever2(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever2;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues2(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues2;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// ../../node_modules/zod/v3/ZodError.js
var ZodIssueCode2 = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class ZodError2 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error46) => {
      for (const issue2 of error46.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError2)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = Object.create(null);
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError2.create = (issues) => {
  const error46 = new ZodError2(issues);
  return error46;
};

// ../../node_modules/zod/v3/locales/en.js
var errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode2.invalid_type:
      if (issue2.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode2.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode2.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode2.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode2.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode2.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode2.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode2.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode2.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode2.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode2.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode2.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode2.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode2.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode2.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode2.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue2);
  }
  return { message };
};
var en_default2 = errorMap;

// ../../node_modules/zod/v3/errors.js
var overrideErrorMap = en_default2;
function getErrorMap2() {
  return overrideErrorMap;
}

// ../../node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap2();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default2 ? undefined : en_default2
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

// ../../node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// ../../node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error46 = new ZodError2(ctx.common.issues);
        this._error = error46;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType2 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType2(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType2(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode2.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional2.create(this, this._def);
  }
  nullable() {
    return ZodNullable2.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray2.create(this);
  }
  promise() {
    return ZodPromise2.create(this, this._def);
  }
  or(option) {
    return ZodUnion2.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection2.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault2({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind2.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind2.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch2({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind2.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly2.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT2(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return false;
  try {
    const [header] = jwt2.split(".");
    if (!header)
      return false;
    const base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base643));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString2 extends ZodType2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "date",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "time") {
        const regex = timeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "time",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "jwt") {
        if (!isValidJWT2(input.data, check2.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode2.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString2.create = (params) => {
  return new ZodString2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder2(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.not_finite,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber2({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber2.create = (params) => {
  return new ZodNumber2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt2({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt2.create = (params) => {
  return new ZodBigInt2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean2 extends ZodType2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean2.create = (params) => {
  return new ZodBoolean2({
    typeName: ZodFirstPartyTypeKind2.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate2 extends ZodType2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate2.create = (params) => {
  return new ZodDate2({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind2.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol2 extends ZodType2 {
  _parse(input) {
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol2.create = (params) => {
  return new ZodSymbol2({
    typeName: ZodFirstPartyTypeKind2.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined2 extends ZodType2 {
  _parse(input) {
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined2.create = (params) => {
  return new ZodUndefined2({
    typeName: ZodFirstPartyTypeKind2.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull2 extends ZodType2 {
  _parse(input) {
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull2.create = (params) => {
  return new ZodNull2({
    typeName: ZodFirstPartyTypeKind2.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny2.create = (params) => {
  return new ZodAny2({
    typeName: ZodFirstPartyTypeKind2.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown2.create = (params) => {
  return new ZodUnknown2({
    typeName: ZodFirstPartyTypeKind2.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever2 extends ZodType2 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever2.create = (params) => {
  return new ZodNever2({
    typeName: ZodFirstPartyTypeKind2.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid2 extends ZodType2 {
  _parse(input) {
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid2.create = (params) => {
  return new ZodVoid2({
    typeName: ZodFirstPartyTypeKind2.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray2 extends ZodType2 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray2({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray2({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray2({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray2.create = (schema, params) => {
  return new ZodArray2({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind2.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional2.create(deepPartialify(fieldSchema));
    }
    return new ZodObject2({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray2) {
    return new ZodArray2({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional2) {
    return ZodOptional2.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable2) {
    return ZodNullable2.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple2) {
    return ZodTuple2.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever2) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {} else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject2({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue2, ctx) => {
          const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject2({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject2({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind2.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject2({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional2) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject2.create = (shape, params) => {
  return new ZodObject2({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject2.strictCreate = (shape, params) => {
  return new ZodObject2({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject2.lazycreate = (shape, params) => {
  return new ZodObject2({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion2 extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError2(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError2(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion2.create = (types, params) => {
  return new ZodUnion2({
    options: types,
    typeName: ZodFirstPartyTypeKind2.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy2) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral2) {
    return [type.value];
  } else if (type instanceof ZodEnum2) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault2) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined2) {
    return [undefined];
  } else if (type instanceof ZodNull2) {
    return [null];
  } else if (type instanceof ZodOptional2) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable2) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly2) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch2) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion2 extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion2({
      typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues2(a, b) {
  const aType = getParsedType2(a);
  const bType = getParsedType2(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection2 extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues2(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection2.create = (left, right, params) => {
  return new ZodIntersection2({
    left,
    right,
    typeName: ZodFirstPartyTypeKind2.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple2 extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple2({
      ...this._def,
      rest
    });
  }
}
ZodTuple2.create = (schemas3, params) => {
  if (!Array.isArray(schemas3)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple2({
    items: schemas3,
    typeName: ZodFirstPartyTypeKind2.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord2 extends ZodType2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType2) {
      return new ZodRecord2({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind2.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord2({
      keyType: ZodString2.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind2.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap2 extends ZodType2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap2.create = (keyType, valueType, params) => {
  return new ZodMap2({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind2.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet2 extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet2({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet2({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet2.create = (valueType, params) => {
  return new ZodSet2({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind2.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error46) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_arguments,
          argumentsError: error46
        }
      });
    }
    function makeReturnsIssue(returns, error46) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_return_type,
          returnTypeError: error46
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise2) {
      const me = this;
      return OK(async function(...args) {
        const error46 = new ZodError2([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error46.addIssue(makeArgsIssue(args, e));
          throw error46;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error46.addIssue(makeReturnsIssue(result, e));
          throw error46;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction2({
      ...this._def,
      args: ZodTuple2.create(items).rest(ZodUnknown2.create())
    });
  }
  returns(returnType) {
    return new ZodFunction2({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction2({
      args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
      returns: returns || ZodUnknown2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy2 extends ZodType2 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy2.create = (getter, params) => {
  return new ZodLazy2({
    getter,
    typeName: ZodFirstPartyTypeKind2.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral2 extends ZodType2 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral2.create = (value, params) => {
  return new ZodLiteral2({
    value,
    typeName: ZodFirstPartyTypeKind2.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum2({
    values,
    typeName: ZodFirstPartyTypeKind2.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum2 extends ZodType2 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum2.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum2.create = createZodEnum;

class ZodNativeEnum extends ZodType2 {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise2 extends ZodType2 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise2.create = (schema, params) => {
  return new ZodPromise2({
    type: schema,
    typeName: ZodFirstPartyTypeKind2.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType2 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind2.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind2.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional2 extends ZodType2 {
  _parse(input) {
    const parsedType8 = this._getType(input);
    if (parsedType8 === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional2.create = (type, params) => {
  return new ZodOptional2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable2 extends ZodType2 {
  _parse(input) {
    const parsedType8 = this._getType(input);
    if (parsedType8 === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable2.create = (type, params) => {
  return new ZodNullable2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault2 extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault2.create = (type, params) => {
  return new ZodDefault2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch2 extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError2(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError2(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch2.create = (type, params) => {
  return new ZodCatch2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN2 extends ZodType2 {
  _parse(input) {
    const parsedType8 = this._getType(input);
    if (parsedType8 !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN2.create = (params) => {
  return new ZodNaN2({
    typeName: ZodFirstPartyTypeKind2.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind2.ZodPipeline
    });
  }
}

class ZodReadonly2 extends ZodType2 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly2.create = (type, params) => {
  return new ZodReadonly2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject2.lazycreate
};
var ZodFirstPartyTypeKind2;
(function(ZodFirstPartyTypeKind3) {
  ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
var stringType = ZodString2.create;
var numberType = ZodNumber2.create;
var nanType = ZodNaN2.create;
var bigIntType = ZodBigInt2.create;
var booleanType = ZodBoolean2.create;
var dateType = ZodDate2.create;
var symbolType = ZodSymbol2.create;
var undefinedType = ZodUndefined2.create;
var nullType = ZodNull2.create;
var anyType = ZodAny2.create;
var unknownType = ZodUnknown2.create;
var neverType = ZodNever2.create;
var voidType = ZodVoid2.create;
var arrayType = ZodArray2.create;
var objectType = ZodObject2.create;
var strictObjectType = ZodObject2.strictCreate;
var unionType = ZodUnion2.create;
var discriminatedUnionType = ZodDiscriminatedUnion2.create;
var intersectionType = ZodIntersection2.create;
var tupleType = ZodTuple2.create;
var recordType = ZodRecord2.create;
var mapType = ZodMap2.create;
var setType = ZodSet2.create;
var functionType = ZodFunction2.create;
var lazyType = ZodLazy2.create;
var literalType = ZodLiteral2.create;
var enumType = ZodEnum2.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise2.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional2.create;
var nullableType = ZodNullable2.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
// ../../node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders(...headers) {
  return headers.reduce((combinedHeaders, currentHeaders) => ({
    ...combinedHeaders,
    ...currentHeaders != null ? currentHeaders : {}
  }), {});
}
async function delay(delayInMs, options) {
  if (delayInMs == null) {
    return Promise.resolve();
  }
  const signal = options == null ? undefined : options.abortSignal;
  return new Promise((resolve2, reject) => {
    if (signal == null ? undefined : signal.aborted) {
      reject(createAbortError());
      return;
    }
    const timeoutId = setTimeout(() => {
      cleanup();
      resolve2();
    }, delayInMs);
    const cleanup = () => {
      clearTimeout(timeoutId);
      signal == null || signal.removeEventListener("abort", onAbort);
    };
    const onAbort = () => {
      cleanup();
      reject(createAbortError());
    };
    signal == null || signal.addEventListener("abort", onAbort);
  });
}
function createAbortError() {
  return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a15, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a15 = globalThisAny.navigator) == null ? undefined : _a15.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? undefined : _b.versions) == null ? undefined : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function removeUndefinedEntries(record2) {
  return Object.fromEntries(Object.entries(record2).filter(([_key, value]) => value != null));
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries(headers != null ? headers : {});
  const normalizedHeaders = new Headers(cleanedHeaders);
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set("user-agent", [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" "));
  return Object.fromEntries(normalizedHeaders);
}
var createIdGenerator = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0;i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
var generateId = createIdGenerator();
function getErrorMessage2(error46) {
  if (error46 == null) {
    return "unknown error";
  }
  if (typeof error46 === "string") {
    return error46;
  }
  if (error46 instanceof Error) {
    return error46.message;
  }
  return JSON.stringify(error46);
}
function isAbortError(error46) {
  return (error46 instanceof Error || error46 instanceof DOMException) && (error46.name === "AbortError" || error46.name === "ResponseAborted" || error46.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
function handleFetchError({
  error: error46,
  url: url2,
  requestBodyValues
}) {
  if (isAbortError(error46)) {
    return error46;
  }
  if (error46 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error46.message.toLowerCase())) {
    const cause = error46.cause;
    if (cause != null) {
      return new APICallError({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url2,
        requestBodyValues,
        isRetryable: true
      });
    }
  }
  return error46;
}
var VERSION = "3.0.10";
var getOriginalFetch = () => globalThis.fetch;
var getFromApi = async ({
  url: url2,
  headers = {},
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch()
}) => {
  try {
    const response = await fetch2(url2, {
      method: "GET",
      headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url: url2,
          requestBodyValues: {}
        });
      } catch (error46) {
        if (isAbortError(error46) || APICallError.isInstance(error46)) {
          throw error46;
        }
        throw new APICallError({
          message: "Failed to process error response",
          cause: error46,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: {}
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url: url2,
        requestBodyValues: {}
      });
    } catch (error46) {
      if (error46 instanceof Error) {
        if (isAbortError(error46) || APICallError.isInstance(error46)) {
          throw error46;
        }
      }
      throw new APICallError({
        message: "Failed to process successful response",
        cause: error46,
        statusCode: response.status,
        url: url2,
        responseHeaders,
        requestBodyValues: {}
      });
    }
  } catch (error46) {
    throw handleFetchError({ error: error46, url: url2, requestBodyValues: {} });
  }
};
function isUrlSupported({
  mediaType,
  url: url2,
  supportedUrls
}) {
  url2 = url2.toLowerCase();
  mediaType = mediaType.toLowerCase();
  return Object.entries(supportedUrls).map(([key, value]) => {
    const mediaType2 = key.toLowerCase();
    return mediaType2 === "*" || mediaType2 === "*/*" ? { mediaTypePrefix: "", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\*/, ""), regexes: value };
  }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url2));
}
function loadOptionalSetting({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return;
  }
  return settingValue;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse2(text) {
  const obj = JSON.parse(text);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
    return obj;
  }
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse(text) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse2(text);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function asValidator(value) {
  return isValidator(value) ? value : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema) {
  return validator(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes({
  value,
  schema
}) {
  const result = await safeValidateTypes({ value, schema });
  if (!result.success) {
    throw TypeValidationError.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes({
  value,
  schema
}) {
  const validator2 = asValidator(schema);
  try {
    if (validator2.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator2.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error46) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error46 }),
      rawValue: value
    };
  }
}
async function parseJSON({
  text,
  schema
}) {
  try {
    const value = secureJsonParse(text);
    if (schema == null) {
      return value;
    }
    return validateTypes({ value, schema });
  } catch (error46) {
    if (JSONParseError.isInstance(error46) || TypeValidationError.isInstance(error46)) {
      throw error46;
    }
    throw new JSONParseError({ text, cause: error46 });
  }
}
async function safeParseJSON({
  text,
  schema
}) {
  try {
    const value = secureJsonParse(text);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes({ value, schema });
  } catch (error46) {
    return {
      success: false,
      error: JSONParseError.isInstance(error46) ? error46 : new JSONParseError({ text, cause: error46 }),
      rawValue: undefined
    };
  }
}
function parseJsonEventStream({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream).pipeThrough(new EventSourceParserStream).pipeThrough(new TransformStream({
    async transform({ data }, controller) {
      if (data === "[DONE]") {
        return;
      }
      controller.enqueue(await safeParseJSON({ text: data, schema }));
    }
  }));
}
var getOriginalFetch2 = () => globalThis.fetch;
var postJsonToApi = async ({
  url: url2,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi({
  url: url2,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi = async ({
  url: url2,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch2()
}) => {
  try {
    const response = await fetch2(url2, {
      method: "POST",
      headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url: url2,
          requestBodyValues: body.values
        });
      } catch (error46) {
        if (isAbortError(error46) || APICallError.isInstance(error46)) {
          throw error46;
        }
        throw new APICallError({
          message: "Failed to process error response",
          cause: error46,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url: url2,
        requestBodyValues: body.values
      });
    } catch (error46) {
      if (error46 instanceof Error) {
        if (isAbortError(error46) || APICallError.isInstance(error46)) {
          throw error46;
        }
      }
      throw new APICallError({
        message: "Failed to process successful response",
        cause: error46,
        statusCode: response.status,
        url: url2,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error46) {
    throw handleFetchError({ error: error46, url: url2, requestBodyValues: body.values });
  }
};
function tool(tool2) {
  return tool2;
}
async function resolve(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url: url2, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? undefined : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError({
        message: errorToMessage(parsedError),
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? undefined : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? undefined : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler = (responseSchema) => async ({ response, url: url2, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders(response);
  if (!parsedResult.success) {
    throw new APICallError({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url: url2,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (;i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: undefined,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};
function parseAnyDef() {
  return {};
}
function parseArrayDef(def, refs) {
  var _a15, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a15 = def.type) == null ? undefined : _a15._def) && ((_c = (_b = def.type) == null ? undefined : _b._def) == null ? undefined : _c.typeName) !== ZodFirstPartyTypeKind2.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        if (check2.inclusive) {
          res.minimum = check2.value;
        } else {
          res.exclusiveMinimum = check2.value;
        }
        break;
      case "max":
        if (check2.inclusive) {
          res.maximum = check2.value;
        } else {
          res.exclusiveMaximum = check2.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check2.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef() {
  return { type: "boolean" };
}
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def);
  }
}
var integerDateParser = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        res.minimum = check2.value;
        break;
      case "max":
        res.maximum = check2.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : undefined;
}
function parseLiteralDef(def) {
  const parsedType8 = typeof def.value;
  if (parsedType8 !== "bigint" && parsedType8 !== "number" && parsedType8 !== "boolean" && parsedType8 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType8 === "bigint" ? "integer" : parsedType8,
    const: def.value
  };
}
var emojiRegex2 = undefined;
var zodPatterns = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => {
    if (emojiRegex2 === undefined) {
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex2;
  },
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`), check2.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`), check2.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check2.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check2.value, refs)), check2.message, refs);
          break;
        }
        case "ip": {
          if (check2.version !== "v6") {
            addFormat(res, "ipv4", check2.message, refs);
          }
          if (check2.version !== "v4") {
            addFormat(res, "ipv6", check2.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check2.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check2.message, refs);
          break;
        case "cidr": {
          if (check2.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);
          }
          if (check2.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check2.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check2.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check2.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check2.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check2.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal2, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal2) : literal2;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0;i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  var _a15;
  if (schema.format || ((_a15 = schema.anyOf) == null ? undefined : _a15.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern(schema, regex, message, refs) {
  var _a15;
  if (schema.pattern || ((_a15 = schema.allOf) == null ? undefined : _a15.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags(regex, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  var _a15;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0;i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a15 = source[i + 2]) == null ? undefined : _a15.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}
function parseRecordDef(def, refs) {
  var _a15, _b, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a15 = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a15 : refs.allowedAdditionalProperties
  };
  if (((_b = def.keyType) == null ? undefined : _b._def.typeName) === ZodFirstPartyTypeKind2.ZodString && ((_c = def.keyType._def.checks) == null ? undefined : _c.length)) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? undefined : _d._def.typeName) === ZodFirstPartyTypeKind2.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? undefined : _e._def.typeName) === ZodFirstPartyTypeKind2.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind2.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? undefined : _f.length)) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef();
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef(def) {
  const object2 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object2[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef() {
  return { not: parseAnyDef() };
}
function parseNullDef() {
  return {
    type: "null"
  };
}
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => (x._def.typeName in primitiveMappings) && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : undefined;
};
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef(def) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check2.inclusive) {
          res.minimum = check2.value;
        } else {
          res.exclusiveMinimum = check2.value;
        }
        break;
      case "max":
        if (check2.inclusive) {
          res.maximum = check2.value;
        } else {
          res.exclusiveMaximum = check2.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check2.value;
        break;
    }
  }
  return res;
}
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required2 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === undefined || propDef._def === undefined) {
      continue;
    }
    const propOptional = safeIsOptional(propDef);
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === undefined) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required2.push(propName);
    }
  }
  if (required2.length) {
    result.required = required2;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== undefined) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}
var parseOptionalDef = (def, refs) => {
  var _a15;
  if (refs.currentPath.toString() === ((_a15 = refs.propertyPath) == null ? undefined : _a15.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
};
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== undefined)
  };
};
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], [])
    };
  }
}
function parseUndefinedDef() {
  return {
    not: parseAnyDef()
  };
}
function parseUnknownDef() {
  return parseAnyDef();
}
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind2.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodNumber:
      return parseNumberDef(def);
    case ZodFirstPartyTypeKind2.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodBigInt:
      return parseBigintDef(def);
    case ZodFirstPartyTypeKind2.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind2.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind2.ZodNull:
      return parseNullDef();
    case ZodFirstPartyTypeKind2.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodUnion:
    case ZodFirstPartyTypeKind2.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodLiteral:
      return parseLiteralDef(def);
    case ZodFirstPartyTypeKind2.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind2.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind2.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind2.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodNaN:
    case ZodFirstPartyTypeKind2.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind2.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind2.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind2.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodFunction:
    case ZodFirstPartyTypeKind2.ZodVoid:
    case ZodFirstPartyTypeKind2.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((_) => {
        return;
      })(typeName);
  }
};
function parseDef(def, refs, forceResolution = false) {
  var _a15;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a15 = refs.override) == null ? undefined : _a15.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== undefined) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: undefined };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema2) {
    addMeta(def, refs, jsonSchema2);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
    newItem.jsonSchema = jsonSchema2;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema2;
  return jsonSchema2;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef() : undefined;
    }
  }
};
var addMeta = (def, refs, jsonSchema2) => {
  if (def.description) {
    jsonSchema2.description = def.description;
  }
  return jsonSchema2;
};
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== undefined ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: undefined,
    seen: new Map(Object.entries(_options.definitions).map(([name14, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name14],
        jsonSchema: undefined
      }
    ]))
  };
};
var zodToJsonSchema = (schema, options) => {
  var _a15;
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name22, schema2]) => {
    var _a22;
    return {
      ...acc,
      [name22]: (_a22 = parseDef(schema2._def, {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name22]
      }, true)) != null ? _a22 : parseAnyDef()
    };
  }, {}) : undefined;
  const name14 = typeof options === "string" ? options : (options == null ? undefined : options.nameStrategy) === "title" ? undefined : options == null ? undefined : options.name;
  const main = (_a15 = parseDef(schema._def, name14 === undefined ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name14]
  }, false)) != null ? _a15 : parseAnyDef();
  const title = typeof options === "object" && options.name !== undefined && options.nameStrategy === "title" ? options.name : undefined;
  if (title !== undefined) {
    main.title = title;
  }
  const combined = name14 === undefined ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name14
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name14]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var zod_to_json_schema_default = zodToJsonSchema;
function zod3Schema(zodSchema2, options) {
  var _a15;
  const useReferences = (_a15 = options == null ? undefined : options.useReferences) != null ? _a15 : false;
  return jsonSchema(zod_to_json_schema_default(zodSchema2, {
    $refStrategy: useReferences ? "root" : "none"
  }), {
    validate: async (value) => {
      const result = await zodSchema2.safeParseAsync(value);
      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
    }
  });
}
function zod4Schema(zodSchema2, options) {
  var _a15;
  const useReferences = (_a15 = options == null ? undefined : options.useReferences) != null ? _a15 : false;
  const z4JSONSchema = toJSONSchema(zodSchema2, {
    target: "draft-7",
    io: "output",
    reused: useReferences ? "ref" : "inline"
  });
  return jsonSchema(z4JSONSchema, {
    validate: async (value) => {
      const result = await safeParseAsync2(zodSchema2, value);
      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
    }
  });
}
function isZod4Schema(zodSchema2) {
  return "_zod" in zodSchema2;
}
function zodSchema(zodSchema2, options) {
  if (isZod4Schema(zodSchema2)) {
    return zod4Schema(zodSchema2, options);
  } else {
    return zod3Schema(zodSchema2, options);
  }
}
var schemaSymbol = Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema2, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: undefined,
    [validatorSymbol]: true,
    jsonSchema: jsonSchema2,
    validate
  };
}
function isSchema(value) {
  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
  return schema == null ? jsonSchema({
    properties: {},
    additionalProperties: false
  }) : isSchema(schema) ? schema : zodSchema(schema);
}
var { btoa: btoa2, atob: atob2 } = globalThis;
function convertBase64ToUint8Array(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob2(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array2) {
  let latin1string = "";
  for (let i = 0;i < array2.length; i++) {
    latin1string += String.fromCodePoint(array2[i]);
  }
  return btoa2(latin1string);
}
function withoutTrailingSlash(url2) {
  return url2 == null ? undefined : url2.replace(/\/$/, "");
}
function isAsyncIterable(obj) {
  return obj != null && typeof obj[Symbol.asyncIterator] === "function";
}
async function* executeTool({
  execute,
  input,
  options
}) {
  const result = execute(input, options);
  if (isAsyncIterable(result)) {
    let lastOutput;
    for await (const output of result) {
      lastOutput = output;
      yield { type: "preliminary", output };
    }
    yield { type: "final", output: lastOutput };
  } else {
    yield { type: "final", output: await result };
  }
}

// ../../node_modules/@ai-sdk/gateway/dist/index.mjs
var import_oidc = __toESM(require_dist11(), 1);
var import_oidc2 = __toESM(require_dist11(), 1);
var marker15 = "vercel.ai.gateway.error";
var symbol17 = Symbol.for(marker15);
var _a15;
var _b;
var GatewayError = class _GatewayError extends (_b = Error, _a15 = symbol17, _b) {
  constructor({
    message,
    statusCode = 500,
    cause
  }) {
    super(message);
    this[_a15] = true;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  static isInstance(error46) {
    return _GatewayError.hasMarker(error46);
  }
  static hasMarker(error46) {
    return typeof error46 === "object" && error46 !== null && symbol17 in error46 && error46[symbol17] === true;
  }
};
var name14 = "GatewayAuthenticationError";
var marker22 = `vercel.ai.gateway.error.${name14}`;
var symbol22 = Symbol.for(marker22);
var _a22;
var _b2;
var GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b2 = GatewayError, _a22 = symbol22, _b2) {
  constructor({
    message = "Authentication failed",
    statusCode = 401,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a22] = true;
    this.name = name14;
    this.type = "authentication_error";
  }
  static isInstance(error46) {
    return GatewayError.hasMarker(error46) && symbol22 in error46;
  }
  static createContextualError({
    apiKeyProvided,
    oidcTokenProvided,
    message = "Authentication failed",
    statusCode = 401,
    cause
  }) {
    let contextualMessage;
    if (apiKeyProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid API key provided.

The token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else if (oidcTokenProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token provided.

The token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.
- make sure your Vercel project settings have OIDC enabled
- if running locally with 'vercel dev', the token is automatically obtained and refreshed
- if running locally with your own dev server, run 'vercel env pull' to fetch the token
- in production/preview, the token is automatically obtained and refreshed

Alternative: Provide an API key via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else {
      contextualMessage = `AI Gateway authentication failed: No authentication provided.

Provide either an API key or OIDC token.

API key instructions:

The token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

OIDC token instructions:

The token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.
- make sure your Vercel project settings have OIDC enabled
- if running locally with 'vercel dev', the token is automatically obtained and refreshed
- if running locally with your own dev server, run 'vercel env pull' to fetch the token
- in production/preview, the token is automatically obtained and refreshed`;
    }
    return new _GatewayAuthenticationError({
      message: contextualMessage,
      statusCode,
      cause
    });
  }
};
var name22 = "GatewayInvalidRequestError";
var marker32 = `vercel.ai.gateway.error.${name22}`;
var symbol32 = Symbol.for(marker32);
var _a32;
var _b3;
var GatewayInvalidRequestError = class extends (_b3 = GatewayError, _a32 = symbol32, _b3) {
  constructor({
    message = "Invalid request",
    statusCode = 400,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a32] = true;
    this.name = name22;
    this.type = "invalid_request_error";
  }
  static isInstance(error46) {
    return GatewayError.hasMarker(error46) && symbol32 in error46;
  }
};
var name32 = "GatewayRateLimitError";
var marker42 = `vercel.ai.gateway.error.${name32}`;
var symbol42 = Symbol.for(marker42);
var _a42;
var _b4;
var GatewayRateLimitError = class extends (_b4 = GatewayError, _a42 = symbol42, _b4) {
  constructor({
    message = "Rate limit exceeded",
    statusCode = 429,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a42] = true;
    this.name = name32;
    this.type = "rate_limit_exceeded";
  }
  static isInstance(error46) {
    return GatewayError.hasMarker(error46) && symbol42 in error46;
  }
};
var name42 = "GatewayModelNotFoundError";
var marker52 = `vercel.ai.gateway.error.${name42}`;
var symbol52 = Symbol.for(marker52);
var modelNotFoundParamSchema = exports_external.object({
  modelId: exports_external.string()
});
var _a52;
var _b5;
var GatewayModelNotFoundError = class extends (_b5 = GatewayError, _a52 = symbol52, _b5) {
  constructor({
    message = "Model not found",
    statusCode = 404,
    modelId,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a52] = true;
    this.name = name42;
    this.type = "model_not_found";
    this.modelId = modelId;
  }
  static isInstance(error46) {
    return GatewayError.hasMarker(error46) && symbol52 in error46;
  }
};
var name52 = "GatewayInternalServerError";
var marker62 = `vercel.ai.gateway.error.${name52}`;
var symbol62 = Symbol.for(marker62);
var _a62;
var _b6;
var GatewayInternalServerError = class extends (_b6 = GatewayError, _a62 = symbol62, _b6) {
  constructor({
    message = "Internal server error",
    statusCode = 500,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a62] = true;
    this.name = name52;
    this.type = "internal_server_error";
  }
  static isInstance(error46) {
    return GatewayError.hasMarker(error46) && symbol62 in error46;
  }
};
var name62 = "GatewayResponseError";
var marker72 = `vercel.ai.gateway.error.${name62}`;
var symbol72 = Symbol.for(marker72);
var _a72;
var _b7;
var GatewayResponseError = class extends (_b7 = GatewayError, _a72 = symbol72, _b7) {
  constructor({
    message = "Invalid response from Gateway",
    statusCode = 502,
    response,
    validationError,
    cause
  } = {}) {
    super({ message, statusCode, cause });
    this[_a72] = true;
    this.name = name62;
    this.type = "response_error";
    this.response = response;
    this.validationError = validationError;
  }
  static isInstance(error46) {
    return GatewayError.hasMarker(error46) && symbol72 in error46;
  }
};
function createGatewayErrorFromResponse({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod
}) {
  const parseResult = gatewayErrorResponseSchema.safeParse(response);
  if (!parseResult.success) {
    return new GatewayResponseError({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause
    });
  }
  const validatedResponse = parseResult.data;
  const errorType = validatedResponse.error.type;
  const message = validatedResponse.error.message;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError({ message, statusCode, cause });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError({ message, statusCode, cause });
    case "model_not_found": {
      const modelResult = modelNotFoundParamSchema.safeParse(validatedResponse.error.param);
      return new GatewayModelNotFoundError({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.data.modelId : undefined,
        cause
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError({ message, statusCode, cause });
    default:
      return new GatewayInternalServerError({ message, statusCode, cause });
  }
}
var gatewayErrorResponseSchema = exports_external.object({
  error: exports_external.object({
    message: exports_external.string(),
    type: exports_external.string().nullish(),
    param: exports_external.unknown().nullish(),
    code: exports_external.union([exports_external.string(), exports_external.number()]).nullish()
  })
});
function asGatewayError(error46, authMethod) {
  var _a82;
  if (GatewayError.isInstance(error46)) {
    return error46;
  }
  if (APICallError.isInstance(error46)) {
    return createGatewayErrorFromResponse({
      response: extractApiCallResponse(error46),
      statusCode: (_a82 = error46.statusCode) != null ? _a82 : 500,
      defaultMessage: "Gateway request failed",
      cause: error46,
      authMethod
    });
  }
  return createGatewayErrorFromResponse({
    response: {},
    statusCode: 500,
    defaultMessage: error46 instanceof Error ? `Gateway request failed: ${error46.message}` : "Unknown Gateway error",
    cause: error46,
    authMethod
  });
}
function extractApiCallResponse(error46) {
  if (error46.data !== undefined) {
    return error46.data;
  }
  if (error46.responseBody != null) {
    try {
      return JSON.parse(error46.responseBody);
    } catch (e) {
      return error46.responseBody;
    }
  }
  return {};
}
var GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
function parseAuthMethod(headers) {
  const result = gatewayAuthMethodSchema.safeParse(headers[GATEWAY_AUTH_METHOD_HEADER]);
  return result.success ? result.data : undefined;
}
var gatewayAuthMethodSchema = exports_external.union([
  exports_external.literal("api-key"),
  exports_external.literal("oidc")
]);
var GatewayFetchMetadata = class {
  constructor(config2) {
    this.config = config2;
  }
  async getAvailableModels() {
    try {
      const { value } = await getFromApi({
        url: `${this.config.baseURL}/config`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler(gatewayFetchMetadataSchema),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error46) {
      throw asGatewayError(error46);
    }
  }
  async getCredits() {
    try {
      const baseUrl = new URL(this.config.baseURL);
      const { value } = await getFromApi({
        url: `${baseUrl.origin}/v1/credits`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler(gatewayCreditsSchema),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error46) {
      throw asGatewayError(error46);
    }
  }
};
var gatewayLanguageModelSpecificationSchema = exports_external.object({
  specificationVersion: exports_external.literal("v2"),
  provider: exports_external.string(),
  modelId: exports_external.string()
});
var gatewayLanguageModelPricingSchema = exports_external.object({
  input: exports_external.string(),
  output: exports_external.string(),
  input_cache_read: exports_external.string().nullish(),
  input_cache_write: exports_external.string().nullish()
}).transform(({ input, output, input_cache_read, input_cache_write }) => ({
  input,
  output,
  ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
  ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
}));
var gatewayLanguageModelEntrySchema = exports_external.object({
  id: exports_external.string(),
  name: exports_external.string(),
  description: exports_external.string().nullish(),
  pricing: gatewayLanguageModelPricingSchema.nullish(),
  specification: gatewayLanguageModelSpecificationSchema,
  modelType: exports_external.enum(["language", "embedding", "image"]).nullish()
});
var gatewayFetchMetadataSchema = exports_external.object({
  models: exports_external.array(gatewayLanguageModelEntrySchema)
});
var gatewayCreditsSchema = exports_external.object({
  balance: exports_external.string(),
  total_used: exports_external.string()
}).transform(({ balance, total_used }) => ({
  balance,
  totalUsed: total_used
}));
var GatewayLanguageModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId;
    this.config = config2;
    this.specificationVersion = "v2";
    this.supportedUrls = { "*/*": [/.*/] };
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs(options) {
    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
    return {
      args: this.maybeEncodeFileParts(optionsWithoutSignal),
      warnings: []
    };
  }
  async doGenerate(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, false), await resolve(this.config.o11yHeaders)),
        body: args,
        successfulResponseHandler: createJsonResponseHandler(exports_external.any()),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        ...responseBody,
        request: { body: args },
        response: { headers: responseHeaders, body: rawResponse },
        warnings
      };
    } catch (error46) {
      throw asGatewayError(error46, parseAuthMethod(resolvedHeaders));
    }
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const { value: response, responseHeaders } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, true), await resolve(this.config.o11yHeaders)),
        body: args,
        successfulResponseHandler: createEventSourceResponseHandler(exports_external.any()),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        stream: response.pipeThrough(new TransformStream({
          start(controller) {
            if (warnings.length > 0) {
              controller.enqueue({ type: "stream-start", warnings });
            }
          },
          transform(chunk, controller) {
            if (chunk.success) {
              const streamPart = chunk.value;
              if (streamPart.type === "raw" && !options.includeRawChunks) {
                return;
              }
              if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                streamPart.timestamp = new Date(streamPart.timestamp);
              }
              controller.enqueue(streamPart);
            } else {
              controller.error(chunk.error);
            }
          }
        })),
        request: { body: args },
        response: { headers: responseHeaders }
      };
    } catch (error46) {
      throw asGatewayError(error46, parseAuthMethod(resolvedHeaders));
    }
  }
  isFilePart(part) {
    return part && typeof part === "object" && "type" in part && part.type === "file";
  }
  maybeEncodeFileParts(options) {
    for (const message of options.prompt) {
      for (const part of message.content) {
        if (this.isFilePart(part)) {
          const filePart = part;
          if (filePart.data instanceof Uint8Array) {
            const buffer = Uint8Array.from(filePart.data);
            const base64Data = Buffer.from(buffer).toString("base64");
            filePart.data = new URL(`data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`);
          }
        }
      }
    }
    return options;
  }
  getUrl() {
    return `${this.config.baseURL}/language-model`;
  }
  getModelConfigHeaders(modelId, streaming) {
    return {
      "ai-language-model-specification-version": "2",
      "ai-language-model-id": modelId,
      "ai-language-model-streaming": String(streaming)
    };
  }
};
var GatewayEmbeddingModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId;
    this.config = config2;
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a82;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve(this.config.o11yHeaders)),
        body: {
          input: values.length === 1 ? values[0] : values,
          ...providerOptions ? { providerOptions } : {}
        },
        successfulResponseHandler: createJsonResponseHandler(gatewayEmbeddingResponseSchema),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        embeddings: responseBody.embeddings,
        usage: (_a82 = responseBody.usage) != null ? _a82 : undefined,
        providerMetadata: responseBody.providerMetadata,
        response: { headers: responseHeaders, body: rawValue }
      };
    } catch (error46) {
      throw asGatewayError(error46, parseAuthMethod(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/embedding-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-embedding-model-specification-version": "2",
      "ai-model-id": this.modelId
    };
  }
};
var gatewayEmbeddingResponseSchema = exports_external.object({
  embeddings: exports_external.array(exports_external.array(exports_external.number())),
  usage: exports_external.object({ tokens: exports_external.number() }).nullish(),
  providerMetadata: exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), exports_external.unknown())).optional()
});
async function getVercelRequestId() {
  var _a82;
  return (_a82 = import_oidc.getContext().headers) == null ? undefined : _a82["x-vercel-id"];
}
var VERSION2 = "1.0.33";
var AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
function createGatewayProvider(options = {}) {
  var _a82, _b8;
  let pendingMetadata = null;
  let metadataCache = null;
  const cacheRefreshMillis = (_a82 = options.metadataCacheRefreshMillis) != null ? _a82 : 1000 * 60 * 5;
  let lastFetchTime = 0;
  const baseURL = (_b8 = withoutTrailingSlash(options.baseURL)) != null ? _b8 : "https://ai-gateway.vercel.sh/v1/ai";
  const getHeaders = async () => {
    const auth = await getGatewayAuthToken(options);
    if (auth) {
      return withUserAgentSuffix({
        Authorization: `Bearer ${auth.token}`,
        "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
        [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,
        ...options.headers
      }, `ai-sdk/gateway/${VERSION2}`);
    }
    throw GatewayAuthenticationError.createContextualError({
      apiKeyProvided: false,
      oidcTokenProvided: false,
      statusCode: 401
    });
  };
  const createO11yHeaders = () => {
    const deploymentId = loadOptionalSetting({
      settingValue: undefined,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID"
    });
    const environment = loadOptionalSetting({
      settingValue: undefined,
      environmentVariableName: "VERCEL_ENV"
    });
    const region = loadOptionalSetting({
      settingValue: undefined,
      environmentVariableName: "VERCEL_REGION"
    });
    return async () => {
      const requestId = await getVercelRequestId();
      return {
        ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
        ...environment && { "ai-o11y-environment": environment },
        ...region && { "ai-o11y-region": region },
        ...requestId && { "ai-o11y-request-id": requestId }
      };
    };
  };
  const createLanguageModel = (modelId) => {
    return new GatewayLanguageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  const getAvailableModels = async () => {
    var _a92, _b9, _c;
    const now = (_c = (_b9 = (_a92 = options._internal) == null ? undefined : _a92.currentDate) == null ? undefined : _b9.call(_a92).getTime()) != null ? _c : Date.now();
    if (!pendingMetadata || now - lastFetchTime > cacheRefreshMillis) {
      lastFetchTime = now;
      pendingMetadata = new GatewayFetchMetadata({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getAvailableModels().then((metadata) => {
        metadataCache = metadata;
        return metadata;
      }).catch(async (error46) => {
        throw asGatewayError(error46, parseAuthMethod(await getHeaders()));
      });
    }
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  };
  const getCredits = async () => {
    return new GatewayFetchMetadata({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    }).getCredits().catch(async (error46) => {
      throw asGatewayError(error46, parseAuthMethod(await getHeaders()));
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error("The Gateway Provider model function cannot be called with the new keyword.");
    }
    return createLanguageModel(modelId);
  };
  provider.getAvailableModels = getAvailableModels;
  provider.getCredits = getCredits;
  provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  provider.languageModel = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  return provider;
}
var gateway = createGatewayProvider();
async function getGatewayAuthToken(options) {
  const apiKey = loadOptionalSetting({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY"
  });
  if (apiKey) {
    return {
      token: apiKey,
      authMethod: "api-key"
    };
  }
  try {
    const oidcToken = await import_oidc2.getVercelOidcToken();
    return {
      token: oidcToken,
      authMethod: "oidc"
    };
  } catch (e) {
    return null;
  }
}

// ../../node_modules/ai/dist/index.mjs
var import_api = __toESM(require_src2(), 1);
var import_api2 = __toESM(require_src2(), 1);
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name17 in all)
    __defProp2(target, name17, { get: all[name17], enumerable: true });
};
var name16 = "AI_NoOutputSpecifiedError";
var marker17 = `vercel.ai.error.${name16}`;
var symbol18 = Symbol.for(marker17);
var _a17;
var NoOutputSpecifiedError = class extends AISDKError {
  constructor({ message = "No output specified." } = {}) {
    super({ name: name16, message });
    this[_a17] = true;
  }
  static isInstance(error46) {
    return AISDKError.hasMarker(error46, marker17);
  }
};
_a17 = symbol18;
function formatWarning(warning) {
  const prefix = "AI SDK Warning:";
  switch (warning.type) {
    case "unsupported-setting": {
      let message = `${prefix} The "${warning.setting}" setting is not supported by this model`;
      if (warning.details) {
        message += ` - ${warning.details}`;
      }
      return message;
    }
    case "unsupported-tool": {
      const toolName = "name" in warning.tool ? warning.tool.name : "unknown tool";
      let message = `${prefix} The tool "${toolName}" is not supported by this model`;
      if (warning.details) {
        message += ` - ${warning.details}`;
      }
      return message;
    }
    case "other": {
      return `${prefix} ${warning.message}`;
    }
    default: {
      return `${prefix} ${JSON.stringify(warning, null, 2)}`;
    }
  }
}
var FIRST_WARNING_INFO_MESSAGE = "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.";
var hasLoggedBefore = false;
var logWarnings = (warnings) => {
  if (warnings.length === 0) {
    return;
  }
  const logger = globalThis.AI_SDK_LOG_WARNINGS;
  if (logger === false) {
    return;
  }
  if (typeof logger === "function") {
    logger(warnings);
    return;
  }
  if (!hasLoggedBefore) {
    hasLoggedBefore = true;
    console.info(FIRST_WARNING_INFO_MESSAGE);
  }
  for (const warning of warnings) {
    console.warn(formatWarning(warning));
  }
};
var name23 = "AI_InvalidArgumentError";
var marker23 = `vercel.ai.error.${name23}`;
var symbol23 = Symbol.for(marker23);
var _a23;
var InvalidArgumentError2 = class extends AISDKError {
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name: name23,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a23] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error46) {
    return AISDKError.hasMarker(error46, marker23);
  }
};
_a23 = symbol23;
var name33 = "AI_InvalidStreamPartError";
var marker33 = `vercel.ai.error.${name33}`;
var symbol33 = Symbol.for(marker33);
var _a33;
_a33 = symbol33;
var name43 = "AI_InvalidToolInputError";
var marker43 = `vercel.ai.error.${name43}`;
var symbol43 = Symbol.for(marker43);
var _a43;
var InvalidToolInputError = class extends AISDKError {
  constructor({
    toolInput,
    toolName,
    cause,
    message = `Invalid input for tool ${toolName}: ${getErrorMessage(cause)}`
  }) {
    super({ name: name43, message, cause });
    this[_a43] = true;
    this.toolInput = toolInput;
    this.toolName = toolName;
  }
  static isInstance(error46) {
    return AISDKError.hasMarker(error46, marker43);
  }
};
_a43 = symbol43;
var name53 = "AI_MCPClientError";
var marker53 = `vercel.ai.error.${name53}`;
var symbol53 = Symbol.for(marker53);
var _a53;
_a53 = symbol53;
var name63 = "AI_NoImageGeneratedError";
var marker63 = `vercel.ai.error.${name63}`;
var symbol63 = Symbol.for(marker63);
var _a63;
_a63 = symbol63;
var name72 = "AI_NoObjectGeneratedError";
var marker73 = `vercel.ai.error.${name72}`;
var symbol73 = Symbol.for(marker73);
var _a73;
var NoObjectGeneratedError = class extends AISDKError {
  constructor({
    message = "No object generated.",
    cause,
    text: text2,
    response,
    usage,
    finishReason
  }) {
    super({ name: name72, message, cause });
    this[_a73] = true;
    this.text = text2;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error46) {
    return AISDKError.hasMarker(error46, marker73);
  }
};
_a73 = symbol73;
var name82 = "AI_NoOutputGeneratedError";
var marker82 = `vercel.ai.error.${name82}`;
var symbol82 = Symbol.for(marker82);
var _a82;
_a82 = symbol82;
var name92 = "AI_NoSuchToolError";
var marker92 = `vercel.ai.error.${name92}`;
var symbol92 = Symbol.for(marker92);
var _a92;
var NoSuchToolError = class extends AISDKError {
  constructor({
    toolName,
    availableTools = undefined,
    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === undefined ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`
  }) {
    super({ name: name92, message });
    this[_a92] = true;
    this.toolName = toolName;
    this.availableTools = availableTools;
  }
  static isInstance(error46) {
    return AISDKError.hasMarker(error46, marker92);
  }
};
_a92 = symbol92;
var name102 = "AI_ToolCallRepairError";
var marker102 = `vercel.ai.error.${name102}`;
var symbol102 = Symbol.for(marker102);
var _a102;
var ToolCallRepairError = class extends AISDKError {
  constructor({
    cause,
    originalError,
    message = `Error repairing tool call: ${getErrorMessage(cause)}`
  }) {
    super({ name: name102, message, cause });
    this[_a102] = true;
    this.originalError = originalError;
  }
  static isInstance(error46) {
    return AISDKError.hasMarker(error46, marker102);
  }
};
_a102 = symbol102;
var UnsupportedModelVersionError = class extends AISDKError {
  constructor(options) {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
    });
    this.version = options.version;
    this.provider = options.provider;
    this.modelId = options.modelId;
  }
};
var name112 = "AI_InvalidDataContentError";
var marker112 = `vercel.ai.error.${name112}`;
var symbol112 = Symbol.for(marker112);
var _a112;
_a112 = symbol112;
var name122 = "AI_InvalidMessageRoleError";
var marker122 = `vercel.ai.error.${name122}`;
var symbol122 = Symbol.for(marker122);
var _a122;
var InvalidMessageRoleError = class extends AISDKError {
  constructor({
    role,
    message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`
  }) {
    super({ name: name122, message });
    this[_a122] = true;
    this.role = role;
  }
  static isInstance(error46) {
    return AISDKError.hasMarker(error46, marker122);
  }
};
_a122 = symbol122;
var name132 = "AI_MessageConversionError";
var marker132 = `vercel.ai.error.${name132}`;
var symbol132 = Symbol.for(marker132);
var _a132;
_a132 = symbol132;
var name142 = "AI_DownloadError";
var marker142 = `vercel.ai.error.${name142}`;
var symbol142 = Symbol.for(marker142);
var _a142;
var DownloadError = class extends AISDKError {
  constructor({
    url: url2,
    statusCode,
    statusText,
    cause,
    message = cause == null ? `Failed to download ${url2}: ${statusCode} ${statusText}` : `Failed to download ${url2}: ${cause}`
  }) {
    super({ name: name142, message, cause });
    this[_a142] = true;
    this.url = url2;
    this.statusCode = statusCode;
    this.statusText = statusText;
  }
  static isInstance(error46) {
    return AISDKError.hasMarker(error46, marker142);
  }
};
_a142 = symbol142;
var name15 = "AI_RetryError";
var marker152 = `vercel.ai.error.${name15}`;
var symbol152 = Symbol.for(marker152);
var _a152;
var RetryError = class extends AISDKError {
  constructor({
    message,
    reason,
    errors: errors3
  }) {
    super({ name: name15, message });
    this[_a152] = true;
    this.reason = reason;
    this.errors = errors3;
    this.lastError = errors3[errors3.length - 1];
  }
  static isInstance(error46) {
    return AISDKError.hasMarker(error46, marker152);
  }
};
_a152 = symbol152;
function resolveLanguageModel(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v2") {
      throw new UnsupportedModelVersionError({
        version: model.specificationVersion,
        provider: model.provider,
        modelId: model.modelId
      });
    }
    return model;
  }
  return getGlobalProvider().languageModel(model);
}
function getGlobalProvider() {
  var _a172;
  return (_a172 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a172 : gateway;
}
var imageMediaTypeSignatures = [
  {
    mediaType: "image/gif",
    bytesPrefix: [71, 73, 70]
  },
  {
    mediaType: "image/png",
    bytesPrefix: [137, 80, 78, 71]
  },
  {
    mediaType: "image/jpeg",
    bytesPrefix: [255, 216]
  },
  {
    mediaType: "image/webp",
    bytesPrefix: [
      82,
      73,
      70,
      70,
      null,
      null,
      null,
      null,
      87,
      69,
      66,
      80
    ]
  },
  {
    mediaType: "image/bmp",
    bytesPrefix: [66, 77]
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [73, 73, 42, 0]
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [77, 77, 0, 42]
  },
  {
    mediaType: "image/avif",
    bytesPrefix: [
      0,
      0,
      0,
      32,
      102,
      116,
      121,
      112,
      97,
      118,
      105,
      102
    ]
  },
  {
    mediaType: "image/heic",
    bytesPrefix: [
      0,
      0,
      0,
      32,
      102,
      116,
      121,
      112,
      104,
      101,
      105,
      99
    ]
  }
];
var stripID3 = (data) => {
  const bytes = typeof data === "string" ? convertBase64ToUint8Array(data) : data;
  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;
  return bytes.slice(id3Size + 10);
};
function stripID3TagsIfPresent(data) {
  const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && data[1] === 68 && data[2] === 51;
  return hasId3 ? stripID3(data) : data;
}
function detectMediaType({
  data,
  signatures
}) {
  const processedData = stripID3TagsIfPresent(data);
  const bytes = typeof processedData === "string" ? convertBase64ToUint8Array(processedData.substring(0, Math.min(processedData.length, 24))) : processedData;
  for (const signature of signatures) {
    if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index) => byte === null || bytes[index] === byte)) {
      return signature.mediaType;
    }
  }
  return;
}
var VERSION3 = "5.0.60";
var download = async ({ url: url2 }) => {
  var _a172;
  const urlText = url2.toString();
  try {
    const response = await fetch(urlText, {
      headers: withUserAgentSuffix({}, `ai-sdk/${VERSION3}`, getRuntimeEnvironmentUserAgent())
    });
    if (!response.ok) {
      throw new DownloadError({
        url: urlText,
        statusCode: response.status,
        statusText: response.statusText
      });
    }
    return {
      data: new Uint8Array(await response.arrayBuffer()),
      mediaType: (_a172 = response.headers.get("content-type")) != null ? _a172 : undefined
    };
  } catch (error46) {
    if (DownloadError.isInstance(error46)) {
      throw error46;
    }
    throw new DownloadError({ url: urlText, cause: error46 });
  }
};
var createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(requestedDownloads.map(async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)));
function splitDataUrl(dataUrl) {
  try {
    const [header, base64Content] = dataUrl.split(",");
    return {
      mediaType: header.split(";")[0].split(":")[1],
      base64Content
    };
  } catch (error46) {
    return {
      mediaType: undefined,
      base64Content: undefined
    };
  }
}
var dataContentSchema = exports_external.union([
  exports_external.string(),
  exports_external.instanceof(Uint8Array),
  exports_external.instanceof(ArrayBuffer),
  exports_external.custom((value) => {
    var _a172, _b8;
    return (_b8 = (_a172 = globalThis.Buffer) == null ? undefined : _a172.isBuffer(value)) != null ? _b8 : false;
  }, { message: "Must be a Buffer" })
]);
function convertToLanguageModelV2DataContent(content) {
  if (content instanceof Uint8Array) {
    return { data: content, mediaType: undefined };
  }
  if (content instanceof ArrayBuffer) {
    return { data: new Uint8Array(content), mediaType: undefined };
  }
  if (typeof content === "string") {
    try {
      content = new URL(content);
    } catch (error46) {}
  }
  if (content instanceof URL && content.protocol === "data:") {
    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(content.toString());
    if (dataUrlMediaType == null || base64Content == null) {
      throw new AISDKError({
        name: "InvalidDataContentError",
        message: `Invalid data URL format in content ${content.toString()}`
      });
    }
    return { data: base64Content, mediaType: dataUrlMediaType };
  }
  return { data: content, mediaType: undefined };
}
function convertDataContentToBase64String(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof ArrayBuffer) {
    return convertUint8ArrayToBase64(new Uint8Array(content));
  }
  return convertUint8ArrayToBase64(content);
}
async function convertToLanguageModelPrompt({
  prompt,
  supportedUrls,
  download: download2 = createDefaultDownloadFunction()
}) {
  const downloadedAssets = await downloadAssets(prompt.messages, download2, supportedUrls);
  return [
    ...prompt.system != null ? [{ role: "system", content: prompt.system }] : [],
    ...prompt.messages.map((message) => convertToLanguageModelMessage({ message, downloadedAssets }))
  ];
}
function convertToLanguageModelMessage({
  message,
  downloadedAssets
}) {
  const role = message.role;
  switch (role) {
    case "system": {
      return {
        role: "system",
        content: message.content,
        providerOptions: message.providerOptions
      };
    }
    case "user": {
      if (typeof message.content === "string") {
        return {
          role: "user",
          content: [{ type: "text", text: message.content }],
          providerOptions: message.providerOptions
        };
      }
      return {
        role: "user",
        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== "text" || part.text !== ""),
        providerOptions: message.providerOptions
      };
    }
    case "assistant": {
      if (typeof message.content === "string") {
        return {
          role: "assistant",
          content: [{ type: "text", text: message.content }],
          providerOptions: message.providerOptions
        };
      }
      return {
        role: "assistant",
        content: message.content.filter((part) => part.type !== "text" || part.text !== "" || part.providerOptions != null).map((part) => {
          const providerOptions = part.providerOptions;
          switch (part.type) {
            case "file": {
              const { data, mediaType } = convertToLanguageModelV2DataContent(part.data);
              return {
                type: "file",
                data,
                filename: part.filename,
                mediaType: mediaType != null ? mediaType : part.mediaType,
                providerOptions
              };
            }
            case "reasoning": {
              return {
                type: "reasoning",
                text: part.text,
                providerOptions
              };
            }
            case "text": {
              return {
                type: "text",
                text: part.text,
                providerOptions
              };
            }
            case "tool-call": {
              return {
                type: "tool-call",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                input: part.input,
                providerExecuted: part.providerExecuted,
                providerOptions
              };
            }
            case "tool-result": {
              return {
                type: "tool-result",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                output: part.output,
                providerOptions
              };
            }
          }
        }),
        providerOptions: message.providerOptions
      };
    }
    case "tool": {
      return {
        role: "tool",
        content: message.content.map((part) => ({
          type: "tool-result",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          output: part.output,
          providerOptions: part.providerOptions
        })),
        providerOptions: message.providerOptions
      };
    }
    default: {
      const _exhaustiveCheck = role;
      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });
    }
  }
}
async function downloadAssets(messages, download2, supportedUrls) {
  const plannedDownloads = messages.filter((message) => message.role === "user").map((message) => message.content).filter((content) => Array.isArray(content)).flat().filter((part) => part.type === "image" || part.type === "file").map((part) => {
    var _a172;
    const mediaType = (_a172 = part.mediaType) != null ? _a172 : part.type === "image" ? "image/*" : undefined;
    let data = part.type === "image" ? part.image : part.data;
    if (typeof data === "string") {
      try {
        data = new URL(data);
      } catch (ignored) {}
    }
    return { mediaType, data };
  }).filter((part) => part.data instanceof URL).map((part) => ({
    url: part.data,
    isUrlSupportedByModel: part.mediaType != null && isUrlSupported({
      url: part.data.toString(),
      mediaType: part.mediaType,
      supportedUrls
    })
  }));
  const downloadedFiles = await download2(plannedDownloads);
  return Object.fromEntries(downloadedFiles.map((file2, index) => file2 == null ? null : [
    plannedDownloads[index].url.toString(),
    { data: file2.data, mediaType: file2.mediaType }
  ]).filter((file2) => file2 != null));
}
function convertPartToLanguageModelPart(part, downloadedAssets) {
  var _a172;
  if (part.type === "text") {
    return {
      type: "text",
      text: part.text,
      providerOptions: part.providerOptions
    };
  }
  let originalData;
  const type = part.type;
  switch (type) {
    case "image":
      originalData = part.image;
      break;
    case "file":
      originalData = part.data;
      break;
    default:
      throw new Error(`Unsupported part type: ${type}`);
  }
  const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV2DataContent(originalData);
  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;
  let data = convertedData;
  if (data instanceof URL) {
    const downloadedFile = downloadedAssets[data.toString()];
    if (downloadedFile) {
      data = downloadedFile.data;
      mediaType != null || (mediaType = downloadedFile.mediaType);
    }
  }
  switch (type) {
    case "image": {
      if (data instanceof Uint8Array || typeof data === "string") {
        mediaType = (_a172 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a172 : mediaType;
      }
      return {
        type: "file",
        mediaType: mediaType != null ? mediaType : "image/*",
        filename: undefined,
        data,
        providerOptions: part.providerOptions
      };
    }
    case "file": {
      if (mediaType == null) {
        throw new Error(`Media type is missing for file part`);
      }
      return {
        type: "file",
        mediaType,
        filename: part.filename,
        data,
        providerOptions: part.providerOptions
      };
    }
  }
}
function prepareCallSettings({
  maxOutputTokens,
  temperature,
  topP,
  topK,
  presencePenalty,
  frequencyPenalty,
  seed,
  stopSequences
}) {
  if (maxOutputTokens != null) {
    if (!Number.isInteger(maxOutputTokens)) {
      throw new InvalidArgumentError2({
        parameter: "maxOutputTokens",
        value: maxOutputTokens,
        message: "maxOutputTokens must be an integer"
      });
    }
    if (maxOutputTokens < 1) {
      throw new InvalidArgumentError2({
        parameter: "maxOutputTokens",
        value: maxOutputTokens,
        message: "maxOutputTokens must be >= 1"
      });
    }
  }
  if (temperature != null) {
    if (typeof temperature !== "number") {
      throw new InvalidArgumentError2({
        parameter: "temperature",
        value: temperature,
        message: "temperature must be a number"
      });
    }
  }
  if (topP != null) {
    if (typeof topP !== "number") {
      throw new InvalidArgumentError2({
        parameter: "topP",
        value: topP,
        message: "topP must be a number"
      });
    }
  }
  if (topK != null) {
    if (typeof topK !== "number") {
      throw new InvalidArgumentError2({
        parameter: "topK",
        value: topK,
        message: "topK must be a number"
      });
    }
  }
  if (presencePenalty != null) {
    if (typeof presencePenalty !== "number") {
      throw new InvalidArgumentError2({
        parameter: "presencePenalty",
        value: presencePenalty,
        message: "presencePenalty must be a number"
      });
    }
  }
  if (frequencyPenalty != null) {
    if (typeof frequencyPenalty !== "number") {
      throw new InvalidArgumentError2({
        parameter: "frequencyPenalty",
        value: frequencyPenalty,
        message: "frequencyPenalty must be a number"
      });
    }
  }
  if (seed != null) {
    if (!Number.isInteger(seed)) {
      throw new InvalidArgumentError2({
        parameter: "seed",
        value: seed,
        message: "seed must be an integer"
      });
    }
  }
  return {
    maxOutputTokens,
    temperature,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    stopSequences,
    seed
  };
}
function isNonEmptyObject(object2) {
  return object2 != null && Object.keys(object2).length > 0;
}
function prepareToolsAndToolChoice({
  tools,
  toolChoice,
  activeTools
}) {
  if (!isNonEmptyObject(tools)) {
    return {
      tools: undefined,
      toolChoice: undefined
    };
  }
  const filteredTools = activeTools != null ? Object.entries(tools).filter(([name17]) => activeTools.includes(name17)) : Object.entries(tools);
  return {
    tools: filteredTools.map(([name17, tool3]) => {
      const toolType = tool3.type;
      switch (toolType) {
        case undefined:
        case "dynamic":
        case "function":
          return {
            type: "function",
            name: name17,
            description: tool3.description,
            inputSchema: asSchema(tool3.inputSchema).jsonSchema,
            providerOptions: tool3.providerOptions
          };
        case "provider-defined":
          return {
            type: "provider-defined",
            name: name17,
            id: tool3.id,
            args: tool3.args
          };
        default: {
          const exhaustiveCheck = toolType;
          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
        }
      }
    }),
    toolChoice: toolChoice == null ? { type: "auto" } : typeof toolChoice === "string" ? { type: toolChoice } : { type: "tool", toolName: toolChoice.toolName }
  };
}
var jsonValueSchema = exports_external.lazy(() => exports_external.union([
  exports_external.null(),
  exports_external.string(),
  exports_external.number(),
  exports_external.boolean(),
  exports_external.record(exports_external.string(), jsonValueSchema),
  exports_external.array(jsonValueSchema)
]));
var providerMetadataSchema = exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), jsonValueSchema));
var textPartSchema = exports_external.object({
  type: exports_external.literal("text"),
  text: exports_external.string(),
  providerOptions: providerMetadataSchema.optional()
});
var imagePartSchema = exports_external.object({
  type: exports_external.literal("image"),
  image: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),
  mediaType: exports_external.string().optional(),
  providerOptions: providerMetadataSchema.optional()
});
var filePartSchema = exports_external.object({
  type: exports_external.literal("file"),
  data: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),
  filename: exports_external.string().optional(),
  mediaType: exports_external.string(),
  providerOptions: providerMetadataSchema.optional()
});
var reasoningPartSchema = exports_external.object({
  type: exports_external.literal("reasoning"),
  text: exports_external.string(),
  providerOptions: providerMetadataSchema.optional()
});
var toolCallPartSchema = exports_external.object({
  type: exports_external.literal("tool-call"),
  toolCallId: exports_external.string(),
  toolName: exports_external.string(),
  input: exports_external.unknown(),
  providerOptions: providerMetadataSchema.optional(),
  providerExecuted: exports_external.boolean().optional()
});
var outputSchema = exports_external.discriminatedUnion("type", [
  exports_external.object({
    type: exports_external.literal("text"),
    value: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("json"),
    value: jsonValueSchema
  }),
  exports_external.object({
    type: exports_external.literal("error-text"),
    value: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("error-json"),
    value: jsonValueSchema
  }),
  exports_external.object({
    type: exports_external.literal("content"),
    value: exports_external.array(exports_external.union([
      exports_external.object({
        type: exports_external.literal("text"),
        text: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("media"),
        data: exports_external.string(),
        mediaType: exports_external.string()
      })
    ]))
  })
]);
var toolResultPartSchema = exports_external.object({
  type: exports_external.literal("tool-result"),
  toolCallId: exports_external.string(),
  toolName: exports_external.string(),
  output: outputSchema,
  providerOptions: providerMetadataSchema.optional()
});
var systemModelMessageSchema = exports_external.object({
  role: exports_external.literal("system"),
  content: exports_external.string(),
  providerOptions: providerMetadataSchema.optional()
});
var userModelMessageSchema = exports_external.object({
  role: exports_external.literal("user"),
  content: exports_external.union([
    exports_external.string(),
    exports_external.array(exports_external.union([textPartSchema, imagePartSchema, filePartSchema]))
  ]),
  providerOptions: providerMetadataSchema.optional()
});
var assistantModelMessageSchema = exports_external.object({
  role: exports_external.literal("assistant"),
  content: exports_external.union([
    exports_external.string(),
    exports_external.array(exports_external.union([
      textPartSchema,
      filePartSchema,
      reasoningPartSchema,
      toolCallPartSchema,
      toolResultPartSchema
    ]))
  ]),
  providerOptions: providerMetadataSchema.optional()
});
var toolModelMessageSchema = exports_external.object({
  role: exports_external.literal("tool"),
  content: exports_external.array(toolResultPartSchema),
  providerOptions: providerMetadataSchema.optional()
});
var modelMessageSchema = exports_external.union([
  systemModelMessageSchema,
  userModelMessageSchema,
  assistantModelMessageSchema,
  toolModelMessageSchema
]);
async function standardizePrompt(prompt) {
  if (prompt.prompt == null && prompt.messages == null) {
    throw new InvalidPromptError({
      prompt,
      message: "prompt or messages must be defined"
    });
  }
  if (prompt.prompt != null && prompt.messages != null) {
    throw new InvalidPromptError({
      prompt,
      message: "prompt and messages cannot be defined at the same time"
    });
  }
  if (prompt.system != null && typeof prompt.system !== "string") {
    throw new InvalidPromptError({
      prompt,
      message: "system must be a string"
    });
  }
  let messages;
  if (prompt.prompt != null && typeof prompt.prompt === "string") {
    messages = [{ role: "user", content: prompt.prompt }];
  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {
    messages = prompt.prompt;
  } else if (prompt.messages != null) {
    messages = prompt.messages;
  } else {
    throw new InvalidPromptError({
      prompt,
      message: "prompt or messages must be defined"
    });
  }
  if (messages.length === 0) {
    throw new InvalidPromptError({
      prompt,
      message: "messages must not be empty"
    });
  }
  const validationResult = await safeValidateTypes({
    value: messages,
    schema: exports_external.array(modelMessageSchema)
  });
  if (!validationResult.success) {
    throw new InvalidPromptError({
      prompt,
      message: "The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.",
      cause: validationResult.error
    });
  }
  return {
    messages,
    system: prompt.system
  };
}
function wrapGatewayError(error46) {
  if (GatewayAuthenticationError.isInstance(error46) || GatewayModelNotFoundError.isInstance(error46)) {
    return new AISDKError({
      name: "GatewayError",
      message: "Vercel AI Gateway access failed. If you want to use AI SDK providers directly, use the providers, e.g. @ai-sdk/openai, or register a different global default provider.",
      cause: error46
    });
  }
  return error46;
}
function assembleOperationName({
  operationId,
  telemetry
}) {
  return {
    "operation.name": `${operationId}${(telemetry == null ? undefined : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? undefined : telemetry.functionId,
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? undefined : telemetry.functionId
  };
}
function getBaseTelemetryAttributes({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a172;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    ...Object.entries((_a172 = telemetry == null ? undefined : telemetry.metadata) != null ? _a172 : {}).reduce((attributes, [key, value]) => {
      attributes[`ai.telemetry.metadata.${key}`] = value;
      return attributes;
    }, {}),
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== undefined) {
        attributes[`ai.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}
var noopTracer = {
  startSpan() {
    return noopSpan;
  },
  startActiveSpan(name17, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan);
    }
  }
};
var noopSpan = {
  spanContext() {
    return noopSpanContext;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer;
  }
  if (tracer) {
    return tracer;
  }
  return import_api.trace.getTracer("ai");
}
function recordSpan({
  name: name17,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(name17, { attributes }, async (span) => {
    try {
      const result = await fn(span);
      if (endWhenDone) {
        span.end();
      }
      return result;
    } catch (error46) {
      try {
        recordErrorOnSpan(span, error46);
      } finally {
        span.end();
      }
      throw error46;
    }
  });
}
function recordErrorOnSpan(span, error46) {
  if (error46 instanceof Error) {
    span.recordException({
      name: error46.name,
      message: error46.message,
      stack: error46.stack
    });
    span.setStatus({
      code: import_api2.SpanStatusCode.ERROR,
      message: error46.message
    });
  } else {
    span.setStatus({ code: import_api2.SpanStatusCode.ERROR });
  }
}
function selectTelemetryAttributes({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? undefined : telemetry.isEnabled) !== true) {
    return {};
  }
  return Object.entries(attributes).reduce((attributes2, [key, value]) => {
    if (value == null) {
      return attributes2;
    }
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? undefined : telemetry.recordInputs) === false) {
        return attributes2;
      }
      const result = value.input();
      return result == null ? attributes2 : { ...attributes2, [key]: result };
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? undefined : telemetry.recordOutputs) === false) {
        return attributes2;
      }
      const result = value.output();
      return result == null ? attributes2 : { ...attributes2, [key]: result };
    }
    return { ...attributes2, [key]: value };
  }, {});
}
function stringifyForTelemetry(prompt) {
  return JSON.stringify(prompt.map((message) => ({
    ...message,
    content: typeof message.content === "string" ? message.content : message.content.map((part) => part.type === "file" ? {
      ...part,
      data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data
    } : part)
  })));
}
function addLanguageModelUsage(usage1, usage2) {
  return {
    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),
    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),
    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),
    reasoningTokens: addTokenCounts(usage1.reasoningTokens, usage2.reasoningTokens),
    cachedInputTokens: addTokenCounts(usage1.cachedInputTokens, usage2.cachedInputTokens)
  };
}
function addTokenCounts(tokenCount1, tokenCount2) {
  return tokenCount1 == null && tokenCount2 == null ? undefined : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);
}
function asArray(value) {
  return value === undefined ? [] : Array.isArray(value) ? value : [value];
}
function getRetryDelayInMs({
  error: error46,
  exponentialBackoffDelay
}) {
  const headers = error46.responseHeaders;
  if (!headers)
    return exponentialBackoffDelay;
  let ms;
  const retryAfterMs = headers["retry-after-ms"];
  if (retryAfterMs) {
    const timeoutMs = parseFloat(retryAfterMs);
    if (!Number.isNaN(timeoutMs)) {
      ms = timeoutMs;
    }
  }
  const retryAfter = headers["retry-after"];
  if (retryAfter && ms === undefined) {
    const timeoutSeconds = parseFloat(retryAfter);
    if (!Number.isNaN(timeoutSeconds)) {
      ms = timeoutSeconds * 1000;
    } else {
      ms = Date.parse(retryAfter) - Date.now();
    }
  }
  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1000 || ms < exponentialBackoffDelay)) {
    return ms;
  }
  return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders = ({
  maxRetries = 2,
  initialDelayInMs = 2000,
  backoffFactor = 2,
  abortSignal
} = {}) => async (f) => _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor,
  abortSignal
});
async function _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs,
  backoffFactor,
  abortSignal
}, errors3 = []) {
  try {
    return await f();
  } catch (error46) {
    if (isAbortError(error46)) {
      throw error46;
    }
    if (maxRetries === 0) {
      throw error46;
    }
    const errorMessage = getErrorMessage2(error46);
    const newErrors = [...errors3, error46];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error46 instanceof Error && APICallError.isInstance(error46) && error46.isRetryable === true && tryNumber <= maxRetries) {
      await delay(getRetryDelayInMs({
        error: error46,
        exponentialBackoffDelay: delayInMs
      }), { abortSignal });
      return _retryWithExponentialBackoff(f, {
        maxRetries,
        delayInMs: backoffFactor * delayInMs,
        backoffFactor,
        abortSignal
      }, newErrors);
    }
    if (tryNumber === 1) {
      throw error46;
    }
    throw new RetryError({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function prepareRetries({
  maxRetries,
  abortSignal
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError2({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError2({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoffRespectingRetryHeaders({
      maxRetries: maxRetriesResult,
      abortSignal
    })
  };
}
function extractTextContent(content) {
  const parts = content.filter((content2) => content2.type === "text");
  if (parts.length === 0) {
    return;
  }
  return parts.map((content2) => content2.text).join("");
}
var DefaultGeneratedFile = class {
  constructor({
    data,
    mediaType
  }) {
    const isUint8Array = data instanceof Uint8Array;
    this.base64Data = isUint8Array ? undefined : data;
    this.uint8ArrayData = isUint8Array ? data : undefined;
    this.mediaType = mediaType;
  }
  get base64() {
    if (this.base64Data == null) {
      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData);
    }
    return this.base64Data;
  }
  get uint8Array() {
    if (this.uint8ArrayData == null) {
      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);
    }
    return this.uint8ArrayData;
  }
};
async function parseToolCall({
  toolCall,
  tools,
  repairToolCall,
  system,
  messages
}) {
  try {
    if (tools == null) {
      throw new NoSuchToolError({ toolName: toolCall.toolName });
    }
    try {
      return await doParseToolCall({ toolCall, tools });
    } catch (error46) {
      if (repairToolCall == null || !(NoSuchToolError.isInstance(error46) || InvalidToolInputError.isInstance(error46))) {
        throw error46;
      }
      let repairedToolCall = null;
      try {
        repairedToolCall = await repairToolCall({
          toolCall,
          tools,
          inputSchema: ({ toolName }) => {
            const { inputSchema } = tools[toolName];
            return asSchema(inputSchema).jsonSchema;
          },
          system,
          messages,
          error: error46
        });
      } catch (repairError) {
        throw new ToolCallRepairError({
          cause: repairError,
          originalError: error46
        });
      }
      if (repairedToolCall == null) {
        throw error46;
      }
      return await doParseToolCall({ toolCall: repairedToolCall, tools });
    }
  } catch (error46) {
    const parsedInput = await safeParseJSON({ text: toolCall.input });
    const input = parsedInput.success ? parsedInput.value : toolCall.input;
    return {
      type: "tool-call",
      toolCallId: toolCall.toolCallId,
      toolName: toolCall.toolName,
      input,
      dynamic: true,
      invalid: true,
      error: error46
    };
  }
}
async function doParseToolCall({
  toolCall,
  tools
}) {
  const toolName = toolCall.toolName;
  const tool3 = tools[toolName];
  if (tool3 == null) {
    throw new NoSuchToolError({
      toolName: toolCall.toolName,
      availableTools: Object.keys(tools)
    });
  }
  const schema = asSchema(tool3.inputSchema);
  const parseResult = toolCall.input.trim() === "" ? await safeValidateTypes({ value: {}, schema }) : await safeParseJSON({ text: toolCall.input, schema });
  if (parseResult.success === false) {
    throw new InvalidToolInputError({
      toolName,
      toolInput: toolCall.input,
      cause: parseResult.error
    });
  }
  return tool3.type === "dynamic" ? {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName: toolCall.toolName,
    input: parseResult.value,
    providerExecuted: toolCall.providerExecuted,
    providerMetadata: toolCall.providerMetadata,
    dynamic: true
  } : {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName,
    input: parseResult.value,
    providerExecuted: toolCall.providerExecuted,
    providerMetadata: toolCall.providerMetadata
  };
}
var DefaultStepResult = class {
  constructor({
    content,
    finishReason,
    usage,
    warnings,
    request,
    response,
    providerMetadata
  }) {
    this.content = content;
    this.finishReason = finishReason;
    this.usage = usage;
    this.warnings = warnings;
    this.request = request;
    this.response = response;
    this.providerMetadata = providerMetadata;
  }
  get text() {
    return this.content.filter((part) => part.type === "text").map((part) => part.text).join("");
  }
  get reasoning() {
    return this.content.filter((part) => part.type === "reasoning");
  }
  get reasoningText() {
    return this.reasoning.length === 0 ? undefined : this.reasoning.map((part) => part.text).join("");
  }
  get files() {
    return this.content.filter((part) => part.type === "file").map((part) => part.file);
  }
  get sources() {
    return this.content.filter((part) => part.type === "source");
  }
  get toolCalls() {
    return this.content.filter((part) => part.type === "tool-call");
  }
  get staticToolCalls() {
    return this.toolCalls.filter((toolCall) => toolCall.dynamic !== true);
  }
  get dynamicToolCalls() {
    return this.toolCalls.filter((toolCall) => toolCall.dynamic === true);
  }
  get toolResults() {
    return this.content.filter((part) => part.type === "tool-result");
  }
  get staticToolResults() {
    return this.toolResults.filter((toolResult) => toolResult.dynamic !== true);
  }
  get dynamicToolResults() {
    return this.toolResults.filter((toolResult) => toolResult.dynamic === true);
  }
};
function stepCountIs(stepCount) {
  return ({ steps }) => steps.length === stepCount;
}
async function isStopConditionMet({
  stopConditions,
  steps
}) {
  return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);
}
function createToolModelOutput({
  output,
  tool: tool3,
  errorMode
}) {
  if (errorMode === "text") {
    return { type: "error-text", value: getErrorMessage(output) };
  } else if (errorMode === "json") {
    return { type: "error-json", value: toJSONValue(output) };
  }
  if (tool3 == null ? undefined : tool3.toModelOutput) {
    return tool3.toModelOutput(output);
  }
  return typeof output === "string" ? { type: "text", value: output } : { type: "json", value: toJSONValue(output) };
}
function toJSONValue(value) {
  return value === undefined ? null : value;
}
function toResponseMessages({
  content: inputContent,
  tools
}) {
  const responseMessages = [];
  const content = inputContent.filter((part) => part.type !== "source").filter((part) => (part.type !== "tool-result" || part.providerExecuted) && (part.type !== "tool-error" || part.providerExecuted)).filter((part) => part.type !== "text" || part.text.length > 0).map((part) => {
    switch (part.type) {
      case "text":
        return {
          type: "text",
          text: part.text,
          providerOptions: part.providerMetadata
        };
      case "reasoning":
        return {
          type: "reasoning",
          text: part.text,
          providerOptions: part.providerMetadata
        };
      case "file":
        return {
          type: "file",
          data: part.file.base64,
          mediaType: part.file.mediaType,
          providerOptions: part.providerMetadata
        };
      case "tool-call":
        return {
          type: "tool-call",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          input: part.input,
          providerExecuted: part.providerExecuted,
          providerOptions: part.providerMetadata
        };
      case "tool-result":
        return {
          type: "tool-result",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          output: createToolModelOutput({
            tool: tools == null ? undefined : tools[part.toolName],
            output: part.output,
            errorMode: "none"
          }),
          providerExecuted: true,
          providerOptions: part.providerMetadata
        };
      case "tool-error":
        return {
          type: "tool-result",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          output: createToolModelOutput({
            tool: tools == null ? undefined : tools[part.toolName],
            output: part.error,
            errorMode: "json"
          }),
          providerOptions: part.providerMetadata
        };
    }
  });
  if (content.length > 0) {
    responseMessages.push({
      role: "assistant",
      content
    });
  }
  const toolResultContent = inputContent.filter((part) => part.type === "tool-result" || part.type === "tool-error").filter((part) => !part.providerExecuted).map((toolResult) => ({
    type: "tool-result",
    toolCallId: toolResult.toolCallId,
    toolName: toolResult.toolName,
    output: createToolModelOutput({
      tool: tools == null ? undefined : tools[toolResult.toolName],
      output: toolResult.type === "tool-result" ? toolResult.output : toolResult.error,
      errorMode: toolResult.type === "tool-error" ? "text" : "none"
    })
  }));
  if (toolResultContent.length > 0) {
    responseMessages.push({
      role: "tool",
      content: toolResultContent
    });
  }
  return responseMessages;
}
var originalGenerateId = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
async function generateText({
  model: modelArg,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  stopWhen = stepCountIs(1),
  experimental_output: output,
  experimental_telemetry: telemetry,
  providerOptions,
  experimental_activeTools,
  activeTools = experimental_activeTools,
  experimental_prepareStep,
  prepareStep = experimental_prepareStep,
  experimental_repairToolCall: repairToolCall,
  experimental_download: download2,
  experimental_context,
  _internal: {
    generateId: generateId3 = originalGenerateId,
    currentDate = () => /* @__PURE__ */ new Date
  } = {},
  onStepFinish,
  ...settings
}) {
  const model = resolveLanguageModel(modelArg);
  const stopConditions = asArray(stopWhen);
  const { maxRetries, retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal
  });
  const callSettings = prepareCallSettings(settings);
  const headersWithUserAgent = withUserAgentSuffix(headers != null ? headers : {}, `ai/${VERSION3}`);
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry,
    headers: headersWithUserAgent,
    settings: { ...callSettings, maxRetries }
  });
  const initialPrompt = await standardizePrompt({
    system,
    prompt,
    messages
  });
  const tracer = getTracer(telemetry);
  try {
    return await recordSpan({
      name: "ai.generateText",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({
            operationId: "ai.generateText",
            telemetry
          }),
          ...baseTelemetryAttributes,
          "ai.model.provider": model.provider,
          "ai.model.id": model.modelId,
          "ai.prompt": {
            input: () => JSON.stringify({ system, prompt, messages })
          }
        }
      }),
      tracer,
      fn: async (span) => {
        var _a172, _b8, _c, _d, _e, _f, _g;
        const callSettings2 = prepareCallSettings(settings);
        let currentModelResponse;
        let clientToolCalls = [];
        let clientToolOutputs = [];
        const responseMessages = [];
        const steps = [];
        do {
          const stepInputMessages = [
            ...initialPrompt.messages,
            ...responseMessages
          ];
          const prepareStepResult = await (prepareStep == null ? undefined : prepareStep({
            model,
            steps,
            stepNumber: steps.length,
            messages: stepInputMessages
          }));
          const promptMessages = await convertToLanguageModelPrompt({
            prompt: {
              system: (_a172 = prepareStepResult == null ? undefined : prepareStepResult.system) != null ? _a172 : initialPrompt.system,
              messages: (_b8 = prepareStepResult == null ? undefined : prepareStepResult.messages) != null ? _b8 : stepInputMessages
            },
            supportedUrls: await model.supportedUrls,
            download: download2
          });
          const stepModel = resolveLanguageModel((_c = prepareStepResult == null ? undefined : prepareStepResult.model) != null ? _c : model);
          const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({
            tools,
            toolChoice: (_d = prepareStepResult == null ? undefined : prepareStepResult.toolChoice) != null ? _d : toolChoice,
            activeTools: (_e = prepareStepResult == null ? undefined : prepareStepResult.activeTools) != null ? _e : activeTools
          });
          currentModelResponse = await retry(() => {
            var _a18;
            return recordSpan({
              name: "ai.generateText.doGenerate",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.generateText.doGenerate",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  "ai.model.provider": stepModel.provider,
                  "ai.model.id": stepModel.modelId,
                  "ai.prompt.messages": {
                    input: () => stringifyForTelemetry(promptMessages)
                  },
                  "ai.prompt.tools": {
                    input: () => stepTools == null ? undefined : stepTools.map((tool3) => JSON.stringify(tool3))
                  },
                  "ai.prompt.toolChoice": {
                    input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : undefined
                  },
                  "gen_ai.system": stepModel.provider,
                  "gen_ai.request.model": stepModel.modelId,
                  "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                  "gen_ai.request.max_tokens": settings.maxOutputTokens,
                  "gen_ai.request.presence_penalty": settings.presencePenalty,
                  "gen_ai.request.stop_sequences": settings.stopSequences,
                  "gen_ai.request.temperature": (_a18 = settings.temperature) != null ? _a18 : undefined,
                  "gen_ai.request.top_k": settings.topK,
                  "gen_ai.request.top_p": settings.topP
                }
              }),
              tracer,
              fn: async (span2) => {
                var _a19, _b22, _c2, _d2, _e2, _f2, _g2, _h;
                const result = await stepModel.doGenerate({
                  ...callSettings2,
                  tools: stepTools,
                  toolChoice: stepToolChoice,
                  responseFormat: output == null ? undefined : output.responseFormat,
                  prompt: promptMessages,
                  providerOptions,
                  abortSignal,
                  headers: headersWithUserAgent
                });
                const responseData = {
                  id: (_b22 = (_a19 = result.response) == null ? undefined : _a19.id) != null ? _b22 : generateId3(),
                  timestamp: (_d2 = (_c2 = result.response) == null ? undefined : _c2.timestamp) != null ? _d2 : currentDate(),
                  modelId: (_f2 = (_e2 = result.response) == null ? undefined : _e2.modelId) != null ? _f2 : stepModel.modelId,
                  headers: (_g2 = result.response) == null ? undefined : _g2.headers,
                  body: (_h = result.response) == null ? undefined : _h.body
                };
                span2.setAttributes(selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    "ai.response.finishReason": result.finishReason,
                    "ai.response.text": {
                      output: () => extractTextContent(result.content)
                    },
                    "ai.response.toolCalls": {
                      output: () => {
                        const toolCalls = asToolCalls(result.content);
                        return toolCalls == null ? undefined : JSON.stringify(toolCalls);
                      }
                    },
                    "ai.response.id": responseData.id,
                    "ai.response.model": responseData.modelId,
                    "ai.response.timestamp": responseData.timestamp.toISOString(),
                    "ai.response.providerMetadata": JSON.stringify(result.providerMetadata),
                    "ai.usage.promptTokens": result.usage.inputTokens,
                    "ai.usage.completionTokens": result.usage.outputTokens,
                    "gen_ai.response.finish_reasons": [result.finishReason],
                    "gen_ai.response.id": responseData.id,
                    "gen_ai.response.model": responseData.modelId,
                    "gen_ai.usage.input_tokens": result.usage.inputTokens,
                    "gen_ai.usage.output_tokens": result.usage.outputTokens
                  }
                }));
                return { ...result, response: responseData };
              }
            });
          });
          const stepToolCalls = await Promise.all(currentModelResponse.content.filter((part) => part.type === "tool-call").map((toolCall) => parseToolCall({
            toolCall,
            tools,
            repairToolCall,
            system,
            messages: stepInputMessages
          })));
          for (const toolCall of stepToolCalls) {
            if (toolCall.invalid) {
              continue;
            }
            const tool3 = tools[toolCall.toolName];
            if ((tool3 == null ? undefined : tool3.onInputAvailable) != null) {
              await tool3.onInputAvailable({
                input: toolCall.input,
                toolCallId: toolCall.toolCallId,
                messages: stepInputMessages,
                abortSignal,
                experimental_context
              });
            }
          }
          const invalidToolCalls = stepToolCalls.filter((toolCall) => toolCall.invalid && toolCall.dynamic);
          clientToolOutputs = [];
          for (const toolCall of invalidToolCalls) {
            clientToolOutputs.push({
              type: "tool-error",
              toolCallId: toolCall.toolCallId,
              toolName: toolCall.toolName,
              input: toolCall.input,
              error: getErrorMessage2(toolCall.error),
              dynamic: true
            });
          }
          clientToolCalls = stepToolCalls.filter((toolCall) => !toolCall.providerExecuted);
          if (tools != null) {
            clientToolOutputs.push(...await executeTools({
              toolCalls: clientToolCalls.filter((toolCall) => !toolCall.invalid),
              tools,
              tracer,
              telemetry,
              messages: stepInputMessages,
              abortSignal,
              experimental_context
            }));
          }
          const stepContent = asContent({
            content: currentModelResponse.content,
            toolCalls: stepToolCalls,
            toolOutputs: clientToolOutputs
          });
          responseMessages.push(...toResponseMessages({
            content: stepContent,
            tools
          }));
          const currentStepResult = new DefaultStepResult({
            content: stepContent,
            finishReason: currentModelResponse.finishReason,
            usage: currentModelResponse.usage,
            warnings: currentModelResponse.warnings,
            providerMetadata: currentModelResponse.providerMetadata,
            request: (_f = currentModelResponse.request) != null ? _f : {},
            response: {
              ...currentModelResponse.response,
              messages: structuredClone(responseMessages)
            }
          });
          logWarnings((_g = currentModelResponse.warnings) != null ? _g : []);
          steps.push(currentStepResult);
          await (onStepFinish == null ? undefined : onStepFinish(currentStepResult));
        } while (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length && !await isStopConditionMet({ stopConditions, steps }));
        span.setAttributes(selectTelemetryAttributes({
          telemetry,
          attributes: {
            "ai.response.finishReason": currentModelResponse.finishReason,
            "ai.response.text": {
              output: () => extractTextContent(currentModelResponse.content)
            },
            "ai.response.toolCalls": {
              output: () => {
                const toolCalls = asToolCalls(currentModelResponse.content);
                return toolCalls == null ? undefined : JSON.stringify(toolCalls);
              }
            },
            "ai.response.providerMetadata": JSON.stringify(currentModelResponse.providerMetadata),
            "ai.usage.promptTokens": currentModelResponse.usage.inputTokens,
            "ai.usage.completionTokens": currentModelResponse.usage.outputTokens
          }
        }));
        const lastStep = steps[steps.length - 1];
        return new DefaultGenerateTextResult({
          steps,
          resolvedOutput: await (output == null ? undefined : output.parseOutput({ text: lastStep.text }, {
            response: lastStep.response,
            usage: lastStep.usage,
            finishReason: lastStep.finishReason
          }))
        });
      }
    });
  } catch (error46) {
    throw wrapGatewayError(error46);
  }
}
async function executeTools({
  toolCalls,
  tools,
  tracer,
  telemetry,
  messages,
  abortSignal,
  experimental_context
}) {
  const toolOutputs = await Promise.all(toolCalls.map(async ({ toolCallId, toolName, input }) => {
    const tool3 = tools[toolName];
    if ((tool3 == null ? undefined : tool3.execute) == null) {
      return;
    }
    return recordSpan({
      name: "ai.toolCall",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({
            operationId: "ai.toolCall",
            telemetry
          }),
          "ai.toolCall.name": toolName,
          "ai.toolCall.id": toolCallId,
          "ai.toolCall.args": {
            output: () => JSON.stringify(input)
          }
        }
      }),
      tracer,
      fn: async (span) => {
        try {
          const stream = executeTool({
            execute: tool3.execute.bind(tool3),
            input,
            options: {
              toolCallId,
              messages,
              abortSignal,
              experimental_context
            }
          });
          let output;
          for await (const part of stream) {
            if (part.type === "final") {
              output = part.output;
            }
          }
          try {
            span.setAttributes(selectTelemetryAttributes({
              telemetry,
              attributes: {
                "ai.toolCall.result": {
                  output: () => JSON.stringify(output)
                }
              }
            }));
          } catch (ignored) {}
          return {
            type: "tool-result",
            toolCallId,
            toolName,
            input,
            output,
            dynamic: tool3.type === "dynamic"
          };
        } catch (error46) {
          recordErrorOnSpan(span, error46);
          return {
            type: "tool-error",
            toolCallId,
            toolName,
            input,
            error: error46,
            dynamic: tool3.type === "dynamic"
          };
        }
      }
    });
  }));
  return toolOutputs.filter((output) => output != null);
}
var DefaultGenerateTextResult = class {
  constructor(options) {
    this.steps = options.steps;
    this.resolvedOutput = options.resolvedOutput;
  }
  get finalStep() {
    return this.steps[this.steps.length - 1];
  }
  get content() {
    return this.finalStep.content;
  }
  get text() {
    return this.finalStep.text;
  }
  get files() {
    return this.finalStep.files;
  }
  get reasoningText() {
    return this.finalStep.reasoningText;
  }
  get reasoning() {
    return this.finalStep.reasoning;
  }
  get toolCalls() {
    return this.finalStep.toolCalls;
  }
  get staticToolCalls() {
    return this.finalStep.staticToolCalls;
  }
  get dynamicToolCalls() {
    return this.finalStep.dynamicToolCalls;
  }
  get toolResults() {
    return this.finalStep.toolResults;
  }
  get staticToolResults() {
    return this.finalStep.staticToolResults;
  }
  get dynamicToolResults() {
    return this.finalStep.dynamicToolResults;
  }
  get sources() {
    return this.finalStep.sources;
  }
  get finishReason() {
    return this.finalStep.finishReason;
  }
  get warnings() {
    return this.finalStep.warnings;
  }
  get providerMetadata() {
    return this.finalStep.providerMetadata;
  }
  get response() {
    return this.finalStep.response;
  }
  get request() {
    return this.finalStep.request;
  }
  get usage() {
    return this.finalStep.usage;
  }
  get totalUsage() {
    return this.steps.reduce((totalUsage, step) => {
      return addLanguageModelUsage(totalUsage, step.usage);
    }, {
      inputTokens: undefined,
      outputTokens: undefined,
      totalTokens: undefined,
      reasoningTokens: undefined,
      cachedInputTokens: undefined
    });
  }
  get experimental_output() {
    if (this.resolvedOutput == null) {
      throw new NoOutputSpecifiedError;
    }
    return this.resolvedOutput;
  }
};
function asToolCalls(content) {
  const parts = content.filter((part) => part.type === "tool-call");
  if (parts.length === 0) {
    return;
  }
  return parts.map((toolCall) => ({
    toolCallId: toolCall.toolCallId,
    toolName: toolCall.toolName,
    input: toolCall.input
  }));
}
function asContent({
  content,
  toolCalls,
  toolOutputs
}) {
  return [
    ...content.map((part) => {
      switch (part.type) {
        case "text":
        case "reasoning":
        case "source":
          return part;
        case "file": {
          return {
            type: "file",
            file: new DefaultGeneratedFile(part)
          };
        }
        case "tool-call": {
          return toolCalls.find((toolCall) => toolCall.toolCallId === part.toolCallId);
        }
        case "tool-result": {
          const toolCall = toolCalls.find((toolCall2) => toolCall2.toolCallId === part.toolCallId);
          if (toolCall == null) {
            throw new Error(`Tool call ${part.toolCallId} not found.`);
          }
          if (part.isError) {
            return {
              type: "tool-error",
              toolCallId: part.toolCallId,
              toolName: part.toolName,
              input: toolCall.input,
              error: part.result,
              providerExecuted: true,
              dynamic: toolCall.dynamic
            };
          }
          return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            input: toolCall.input,
            output: part.result,
            providerExecuted: true,
            dynamic: toolCall.dynamic
          };
        }
      }
    }),
    ...toolOutputs
  ];
}
var JsonToSseTransformStream = class extends TransformStream {
  constructor() {
    super({
      transform(part, controller) {
        controller.enqueue(`data: ${JSON.stringify(part)}

`);
      },
      flush(controller) {
        controller.enqueue(`data: [DONE]

`);
      }
    });
  }
};
var uiMessageChunkSchema = exports_external.union([
  exports_external.strictObject({
    type: exports_external.literal("text-start"),
    id: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("text-delta"),
    id: exports_external.string(),
    delta: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("text-end"),
    id: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("error"),
    errorText: exports_external.string()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-input-start"),
    toolCallId: exports_external.string(),
    toolName: exports_external.string(),
    providerExecuted: exports_external.boolean().optional(),
    dynamic: exports_external.boolean().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-input-delta"),
    toolCallId: exports_external.string(),
    inputTextDelta: exports_external.string()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-input-available"),
    toolCallId: exports_external.string(),
    toolName: exports_external.string(),
    input: exports_external.unknown(),
    providerExecuted: exports_external.boolean().optional(),
    providerMetadata: providerMetadataSchema.optional(),
    dynamic: exports_external.boolean().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-input-error"),
    toolCallId: exports_external.string(),
    toolName: exports_external.string(),
    input: exports_external.unknown(),
    providerExecuted: exports_external.boolean().optional(),
    providerMetadata: providerMetadataSchema.optional(),
    dynamic: exports_external.boolean().optional(),
    errorText: exports_external.string()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-output-available"),
    toolCallId: exports_external.string(),
    output: exports_external.unknown(),
    providerExecuted: exports_external.boolean().optional(),
    dynamic: exports_external.boolean().optional(),
    preliminary: exports_external.boolean().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-output-error"),
    toolCallId: exports_external.string(),
    errorText: exports_external.string(),
    providerExecuted: exports_external.boolean().optional(),
    dynamic: exports_external.boolean().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("reasoning-start"),
    id: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("reasoning-delta"),
    id: exports_external.string(),
    delta: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("reasoning-end"),
    id: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("source-url"),
    sourceId: exports_external.string(),
    url: exports_external.string(),
    title: exports_external.string().optional(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("source-document"),
    sourceId: exports_external.string(),
    mediaType: exports_external.string(),
    title: exports_external.string(),
    filename: exports_external.string().optional(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("file"),
    url: exports_external.string(),
    mediaType: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.custom((value) => typeof value === "string" && value.startsWith("data-"), { message: 'Type must start with "data-"' }),
    id: exports_external.string().optional(),
    data: exports_external.unknown(),
    transient: exports_external.boolean().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("start-step")
  }),
  exports_external.strictObject({
    type: exports_external.literal("finish-step")
  }),
  exports_external.strictObject({
    type: exports_external.literal("start"),
    messageId: exports_external.string().optional(),
    messageMetadata: exports_external.unknown().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("finish"),
    messageMetadata: exports_external.unknown().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("abort")
  }),
  exports_external.strictObject({
    type: exports_external.literal("message-metadata"),
    messageMetadata: exports_external.unknown()
  })
]);
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0;i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1;i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
async function parsePartialJson(jsonText) {
  if (jsonText === undefined) {
    return { value: undefined, state: "undefined-input" };
  }
  let result = await safeParseJSON({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON({ text: fixJson(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: undefined, state: "failed-parse" };
}
var originalGenerateId2 = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
var originalGenerateId3 = createIdGenerator({ prefix: "aiobj", size: 24 });
var originalGenerateId4 = createIdGenerator({ prefix: "aiobj", size: 24 });
var output_exports = {};
__export2(output_exports, {
  object: () => object2,
  text: () => text
});
var text = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: text2 }) {
    return { partial: text2 };
  },
  async parseOutput({ text: text2 }) {
    return text2;
  }
});
var object2 = ({
  schema: inputSchema
}) => {
  const schema = asSchema(inputSchema);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: schema.jsonSchema
    },
    async parsePartial({ text: text2 }) {
      const result = await parsePartialJson(text2);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse":
          return {
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    async parseOutput({ text: text2 }, context) {
      const parseResult = await safeParseJSON({ text: text2 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text2,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      const validationResult = await safeValidateTypes({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text2,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      return validationResult.value;
    }
  };
};
var name162 = "AI_NoSuchProviderError";
var marker16 = `vercel.ai.error.${name162}`;
var symbol16 = Symbol.for(marker16);
var _a16;
_a16 = symbol16;
var ClientOrServerImplementationSchema = exports_external.looseObject({
  name: exports_external.string(),
  version: exports_external.string()
});
var BaseParamsSchema = exports_external.looseObject({
  _meta: exports_external.optional(exports_external.object({}).loose())
});
var ResultSchema = BaseParamsSchema;
var RequestSchema = exports_external.object({
  method: exports_external.string(),
  params: exports_external.optional(BaseParamsSchema)
});
var ServerCapabilitiesSchema = exports_external.looseObject({
  experimental: exports_external.optional(exports_external.object({}).loose()),
  logging: exports_external.optional(exports_external.object({}).loose()),
  prompts: exports_external.optional(exports_external.looseObject({
    listChanged: exports_external.optional(exports_external.boolean())
  })),
  resources: exports_external.optional(exports_external.looseObject({
    subscribe: exports_external.optional(exports_external.boolean()),
    listChanged: exports_external.optional(exports_external.boolean())
  })),
  tools: exports_external.optional(exports_external.looseObject({
    listChanged: exports_external.optional(exports_external.boolean())
  }))
});
var InitializeResultSchema = ResultSchema.extend({
  protocolVersion: exports_external.string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ClientOrServerImplementationSchema,
  instructions: exports_external.optional(exports_external.string())
});
var PaginatedResultSchema = ResultSchema.extend({
  nextCursor: exports_external.optional(exports_external.string())
});
var ToolSchema = exports_external.object({
  name: exports_external.string(),
  description: exports_external.optional(exports_external.string()),
  inputSchema: exports_external.object({
    type: exports_external.literal("object"),
    properties: exports_external.optional(exports_external.object({}).loose())
  }).loose()
}).loose();
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: exports_external.array(ToolSchema)
});
var TextContentSchema = exports_external.object({
  type: exports_external.literal("text"),
  text: exports_external.string()
}).loose();
var ImageContentSchema = exports_external.object({
  type: exports_external.literal("image"),
  data: exports_external.base64(),
  mimeType: exports_external.string()
}).loose();
var ResourceContentsSchema = exports_external.object({
  uri: exports_external.string(),
  mimeType: exports_external.optional(exports_external.string())
}).loose();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: exports_external.string()
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: exports_external.base64()
});
var EmbeddedResourceSchema = exports_external.object({
  type: exports_external.literal("resource"),
  resource: exports_external.union([TextResourceContentsSchema, BlobResourceContentsSchema])
}).loose();
var CallToolResultSchema = ResultSchema.extend({
  content: exports_external.array(exports_external.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])),
  isError: exports_external.boolean().default(false).optional()
}).or(ResultSchema.extend({
  toolResult: exports_external.unknown()
}));
var JSONRPC_VERSION = "2.0";
var JSONRPCRequestSchema = exports_external.object({
  jsonrpc: exports_external.literal(JSONRPC_VERSION),
  id: exports_external.union([exports_external.string(), exports_external.number().int()])
}).merge(RequestSchema).strict();
var JSONRPCResponseSchema = exports_external.object({
  jsonrpc: exports_external.literal(JSONRPC_VERSION),
  id: exports_external.union([exports_external.string(), exports_external.number().int()]),
  result: ResultSchema
}).strict();
var JSONRPCErrorSchema = exports_external.object({
  jsonrpc: exports_external.literal(JSONRPC_VERSION),
  id: exports_external.union([exports_external.string(), exports_external.number().int()]),
  error: exports_external.object({
    code: exports_external.number().int(),
    message: exports_external.string(),
    data: exports_external.optional(exports_external.unknown())
  })
}).strict();
var JSONRPCNotificationSchema = exports_external.object({
  jsonrpc: exports_external.literal(JSONRPC_VERSION)
}).merge(exports_external.object({
  method: exports_external.string(),
  params: exports_external.optional(BaseParamsSchema)
})).strict();
var JSONRPCMessageSchema = exports_external.union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResponseSchema,
  JSONRPCErrorSchema
]);
var textUIPartSchema = exports_external.object({
  type: exports_external.literal("text"),
  text: exports_external.string(),
  state: exports_external.enum(["streaming", "done"]).optional(),
  providerMetadata: providerMetadataSchema.optional()
});
var reasoningUIPartSchema = exports_external.object({
  type: exports_external.literal("reasoning"),
  text: exports_external.string(),
  state: exports_external.enum(["streaming", "done"]).optional(),
  providerMetadata: providerMetadataSchema.optional()
});
var sourceUrlUIPartSchema = exports_external.object({
  type: exports_external.literal("source-url"),
  sourceId: exports_external.string(),
  url: exports_external.string(),
  title: exports_external.string().optional(),
  providerMetadata: providerMetadataSchema.optional()
});
var sourceDocumentUIPartSchema = exports_external.object({
  type: exports_external.literal("source-document"),
  sourceId: exports_external.string(),
  mediaType: exports_external.string(),
  title: exports_external.string(),
  filename: exports_external.string().optional(),
  providerMetadata: providerMetadataSchema.optional()
});
var fileUIPartSchema = exports_external.object({
  type: exports_external.literal("file"),
  mediaType: exports_external.string(),
  filename: exports_external.string().optional(),
  url: exports_external.string(),
  providerMetadata: providerMetadataSchema.optional()
});
var stepStartUIPartSchema = exports_external.object({
  type: exports_external.literal("step-start")
});
var dataUIPartSchema = exports_external.object({
  type: exports_external.string().startsWith("data-"),
  id: exports_external.string().optional(),
  data: exports_external.unknown()
});
var dynamicToolUIPartSchemas = [
  exports_external.object({
    type: exports_external.literal("dynamic-tool"),
    toolName: exports_external.string(),
    toolCallId: exports_external.string(),
    state: exports_external.literal("input-streaming"),
    input: exports_external.unknown().optional(),
    output: exports_external.never().optional(),
    errorText: exports_external.never().optional()
  }),
  exports_external.object({
    type: exports_external.literal("dynamic-tool"),
    toolName: exports_external.string(),
    toolCallId: exports_external.string(),
    state: exports_external.literal("input-available"),
    input: exports_external.unknown(),
    output: exports_external.never().optional(),
    errorText: exports_external.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional()
  }),
  exports_external.object({
    type: exports_external.literal("dynamic-tool"),
    toolName: exports_external.string(),
    toolCallId: exports_external.string(),
    state: exports_external.literal("output-available"),
    input: exports_external.unknown(),
    output: exports_external.unknown(),
    errorText: exports_external.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional(),
    preliminary: exports_external.boolean().optional()
  }),
  exports_external.object({
    type: exports_external.literal("dynamic-tool"),
    toolName: exports_external.string(),
    toolCallId: exports_external.string(),
    state: exports_external.literal("output-error"),
    input: exports_external.unknown(),
    output: exports_external.never().optional(),
    errorText: exports_external.string(),
    callProviderMetadata: providerMetadataSchema.optional()
  })
];
var toolUIPartSchemas = [
  exports_external.object({
    type: exports_external.string().startsWith("tool-"),
    toolCallId: exports_external.string(),
    state: exports_external.literal("input-streaming"),
    providerExecuted: exports_external.boolean().optional(),
    input: exports_external.unknown().optional(),
    output: exports_external.never().optional(),
    errorText: exports_external.never().optional()
  }),
  exports_external.object({
    type: exports_external.string().startsWith("tool-"),
    toolCallId: exports_external.string(),
    state: exports_external.literal("input-available"),
    providerExecuted: exports_external.boolean().optional(),
    input: exports_external.unknown(),
    output: exports_external.never().optional(),
    errorText: exports_external.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional()
  }),
  exports_external.object({
    type: exports_external.string().startsWith("tool-"),
    toolCallId: exports_external.string(),
    state: exports_external.literal("output-available"),
    providerExecuted: exports_external.boolean().optional(),
    input: exports_external.unknown(),
    output: exports_external.unknown(),
    errorText: exports_external.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional(),
    preliminary: exports_external.boolean().optional()
  }),
  exports_external.object({
    type: exports_external.string().startsWith("tool-"),
    toolCallId: exports_external.string(),
    state: exports_external.literal("output-error"),
    providerExecuted: exports_external.boolean().optional(),
    input: exports_external.unknown(),
    output: exports_external.never().optional(),
    errorText: exports_external.string(),
    callProviderMetadata: providerMetadataSchema.optional()
  })
];
var uiMessageSchema = exports_external.object({
  id: exports_external.string(),
  role: exports_external.enum(["system", "user", "assistant"]),
  metadata: exports_external.unknown().optional(),
  parts: exports_external.array(exports_external.union([
    textUIPartSchema,
    reasoningUIPartSchema,
    sourceUrlUIPartSchema,
    sourceDocumentUIPartSchema,
    fileUIPartSchema,
    stepStartUIPartSchema,
    dataUIPartSchema,
    ...dynamicToolUIPartSchemas,
    ...toolUIPartSchemas
  ]))
});

// src/ai/system/system.ts
var system = await Bun.file(new URL("./SYSTEM.MD", import.meta.url)).text();
// ../../node_modules/@openrouter/ai-sdk-provider/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var marker18 = "vercel.ai.error";
var symbol19 = Symbol.for(marker18);
var _a18;
var _AISDKError3 = class _AISDKError22 extends Error {
  constructor({
    name: name143,
    message,
    cause
  }) {
    super(message);
    this[_a18] = true;
    this.name = name143;
    this.cause = cause;
  }
  static isInstance(error46) {
    return _AISDKError22.hasMarker(error46, marker18);
  }
  static hasMarker(error46, marker153) {
    const markerSymbol = Symbol.for(marker153);
    return error46 != null && typeof error46 === "object" && markerSymbol in error46 && typeof error46[markerSymbol] === "boolean" && error46[markerSymbol] === true;
  }
};
_a18 = symbol19;
var AISDKError2 = _AISDKError3;
var name17 = "AI_APICallError";
var marker24 = `vercel.ai.error.${name17}`;
var symbol24 = Symbol.for(marker24);
var _a24;
var APICallError2 = class extends AISDKError2 {
  constructor({
    message,
    url: url2,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || statusCode === 409 || statusCode === 429 || statusCode >= 500),
    data
  }) {
    super({ name: name17, message, cause });
    this[_a24] = true;
    this.url = url2;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker24);
  }
};
_a24 = symbol24;
var name24 = "AI_EmptyResponseBodyError";
var marker34 = `vercel.ai.error.${name24}`;
var symbol34 = Symbol.for(marker34);
var _a34;
var EmptyResponseBodyError2 = class extends AISDKError2 {
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name24, message });
    this[_a34] = true;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker34);
  }
};
_a34 = symbol34;
function getErrorMessage3(error46) {
  if (error46 == null) {
    return "unknown error";
  }
  if (typeof error46 === "string") {
    return error46;
  }
  if (error46 instanceof Error) {
    return error46.message;
  }
  return JSON.stringify(error46);
}
var name34 = "AI_InvalidArgumentError";
var marker44 = `vercel.ai.error.${name34}`;
var symbol44 = Symbol.for(marker44);
var _a44;
var InvalidArgumentError3 = class extends AISDKError2 {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name34, message, cause });
    this[_a44] = true;
    this.argument = argument;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker44);
  }
};
_a44 = symbol44;
var name44 = "AI_InvalidPromptError";
var marker54 = `vercel.ai.error.${name44}`;
var symbol54 = Symbol.for(marker54);
var _a54;
var InvalidPromptError2 = class extends AISDKError2 {
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name44, message: `Invalid prompt: ${message}`, cause });
    this[_a54] = true;
    this.prompt = prompt;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker54);
  }
};
_a54 = symbol54;
var name54 = "AI_InvalidResponseDataError";
var marker64 = `vercel.ai.error.${name54}`;
var symbol64 = Symbol.for(marker64);
var _a64;
var InvalidResponseDataError = class extends AISDKError2 {
  constructor({
    data,
    message = `Invalid response data: ${JSON.stringify(data)}.`
  }) {
    super({ name: name54, message });
    this[_a64] = true;
    this.data = data;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker64);
  }
};
_a64 = symbol64;
var name64 = "AI_JSONParseError";
var marker74 = `vercel.ai.error.${name64}`;
var symbol74 = Symbol.for(marker74);
var _a74;
var JSONParseError2 = class extends AISDKError2 {
  constructor({ text: text2, cause }) {
    super({
      name: name64,
      message: `JSON parsing failed: Text: ${text2}.
Error message: ${getErrorMessage3(cause)}`,
      cause
    });
    this[_a74] = true;
    this.text = text2;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker74);
  }
};
_a74 = symbol74;
var name73 = "AI_LoadAPIKeyError";
var marker83 = `vercel.ai.error.${name73}`;
var symbol83 = Symbol.for(marker83);
var _a83;
var LoadAPIKeyError = class extends AISDKError2 {
  constructor({ message }) {
    super({ name: name73, message });
    this[_a83] = true;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker83);
  }
};
_a83 = symbol83;
var name83 = "AI_LoadSettingError";
var marker93 = `vercel.ai.error.${name83}`;
var symbol93 = Symbol.for(marker93);
var _a93;
_a93 = symbol93;
var name93 = "AI_NoContentGeneratedError";
var marker103 = `vercel.ai.error.${name93}`;
var symbol103 = Symbol.for(marker103);
var _a103;
var NoContentGeneratedError = class extends AISDKError2 {
  constructor({
    message = "No content generated."
  } = {}) {
    super({ name: name93, message });
    this[_a103] = true;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker103);
  }
};
_a103 = symbol103;
var name103 = "AI_NoSuchModelError";
var marker113 = `vercel.ai.error.${name103}`;
var symbol113 = Symbol.for(marker113);
var _a113;
_a113 = symbol113;
var name113 = "AI_TooManyEmbeddingValuesForCallError";
var marker123 = `vercel.ai.error.${name113}`;
var symbol123 = Symbol.for(marker123);
var _a123;
_a123 = symbol123;
var name123 = "AI_TypeValidationError";
var marker133 = `vercel.ai.error.${name123}`;
var symbol133 = Symbol.for(marker133);
var _a133;
var _TypeValidationError3 = class _TypeValidationError22 extends AISDKError2 {
  constructor({ value, cause }) {
    super({
      name: name123,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage3(cause)}`,
      cause
    });
    this[_a133] = true;
    this.value = value;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker133);
  }
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError22.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError22({ value, cause });
  }
};
_a133 = symbol133;
var TypeValidationError2 = _TypeValidationError3;
var name133 = "AI_UnsupportedFunctionalityError";
var marker143 = `vercel.ai.error.${name133}`;
var symbol143 = Symbol.for(marker143);
var _a143;
var UnsupportedFunctionalityError = class extends AISDKError2 {
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name133, message });
    this[_a143] = true;
    this.functionality = functionality;
  }
  static isInstance(error46) {
    return AISDKError2.hasMarker(error46, marker143);
  }
};
_a143 = symbol143;
var ParseError2 = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop2(_arg) {}
function createParser2(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
  const { onEvent = noop2, onError = noop2, onRetry = noop2, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines2(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\x00") ? undefined : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError2(`Invalid \`retry\` value: "${value}"`, {
          type: "invalid-retry",
          value,
          line
        }));
        break;
      default:
        onError(new ParseError2(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, { type: "unknown-field", field, value, line }));
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || undefined,
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = undefined, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = undefined, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines2(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (;searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var EventSourceParserStream2 = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser2({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error46) {
            onError === "terminate" ? controller.error(error46) : typeof onError == "function" && onError(error46);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};
var ignoreOverride2 = Symbol("Let zodToJsonSchema decide on which parser to use");
var ALPHA_NUMERIC2 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function combineHeaders2(...headers) {
  return headers.reduce((combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}), {});
}
function extractResponseHeaders2(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator2 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0;i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError3({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
var generateId2 = createIdGenerator2();
function isAbortError2(error46) {
  return (error46 instanceof Error || error46 instanceof DOMException) && (error46.name === "AbortError" || error46.name === "ResponseAborted" || error46.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES2 = ["fetch failed", "failed to fetch"];
function handleFetchError2({
  error: error46,
  url: url2,
  requestBodyValues
}) {
  if (isAbortError2(error46)) {
    return error46;
  }
  if (error46 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES2.includes(error46.message.toLowerCase())) {
    const cause = error46.cause;
    if (cause != null) {
      return new APICallError2({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url2,
        requestBodyValues,
        isRetryable: true
      });
    }
  }
  return error46;
}
function removeUndefinedEntries2(record2) {
  return Object.fromEntries(Object.entries(record2).filter(([_key, value]) => value != null));
}
function loadApiKey({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
var suspectProtoRx2 = /"__proto__"\s*:/;
var suspectConstructorRx2 = /"constructor"\s*:/;
function _parse3(text2) {
  const obj = JSON.parse(text2);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx2.test(text2) === false && suspectConstructorRx2.test(text2) === false) {
    return obj;
  }
  return filter2(obj);
}
function filter2(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse2(text2) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse3(text2);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol2 = Symbol.for("vercel.ai.validator");
function validator2(validate) {
  return { [validatorSymbol2]: true, validate };
}
function isValidator2(value) {
  return typeof value === "object" && value !== null && validatorSymbol2 in value && value[validatorSymbol2] === true && "validate" in value;
}
function asValidator2(value) {
  return isValidator2(value) ? value : standardSchemaValidator2(value);
}
function standardSchemaValidator2(standardSchema) {
  return validator2(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError2({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes2({
  value,
  schema
}) {
  const result = await safeValidateTypes2({ value, schema });
  if (!result.success) {
    throw TypeValidationError2.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes2({
  value,
  schema
}) {
  const validator22 = asValidator2(schema);
  try {
    if (validator22.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator22.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError2.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error46) {
    return {
      success: false,
      error: TypeValidationError2.wrap({ value, cause: error46 }),
      rawValue: value
    };
  }
}
async function parseJSON2({
  text: text2,
  schema
}) {
  try {
    const value = secureJsonParse2(text2);
    if (schema == null) {
      return value;
    }
    return validateTypes2({ value, schema });
  } catch (error46) {
    if (JSONParseError2.isInstance(error46) || TypeValidationError2.isInstance(error46)) {
      throw error46;
    }
    throw new JSONParseError2({ text: text2, cause: error46 });
  }
}
async function safeParseJSON2({
  text: text2,
  schema
}) {
  try {
    const value = secureJsonParse2(text2);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes2({ value, schema });
  } catch (error46) {
    return {
      success: false,
      error: JSONParseError2.isInstance(error46) ? error46 : new JSONParseError2({ text: text2, cause: error46 }),
      rawValue: undefined
    };
  }
}
function isParsableJson(input) {
  try {
    secureJsonParse2(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream2({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream).pipeThrough(new EventSourceParserStream2).pipeThrough(new TransformStream({
    async transform({ data }, controller) {
      if (data === "[DONE]") {
        return;
      }
      controller.enqueue(await safeParseJSON2({ text: data, schema }));
    }
  }));
}
var getOriginalFetch22 = () => globalThis.fetch;
var postJsonToApi2 = async ({
  url: url2,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi2({
  url: url2,
  headers: __spreadValues({
    "Content-Type": "application/json"
  }, headers),
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi2 = async ({
  url: url2,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch22()
}) => {
  try {
    const response = await fetch2(url2, {
      method: "POST",
      headers: removeUndefinedEntries2(headers),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders2(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url: url2,
          requestBodyValues: body.values
        });
      } catch (error46) {
        if (isAbortError2(error46) || APICallError2.isInstance(error46)) {
          throw error46;
        }
        throw new APICallError2({
          message: "Failed to process error response",
          cause: error46,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url: url2,
        requestBodyValues: body.values
      });
    } catch (error46) {
      if (error46 instanceof Error) {
        if (isAbortError2(error46) || APICallError2.isInstance(error46)) {
          throw error46;
        }
      }
      throw new APICallError2({
        message: "Failed to process successful response",
        cause: error46,
        statusCode: response.status,
        url: url2,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error46) {
    throw handleFetchError2({ error: error46, url: url2, requestBodyValues: body.values });
  }
};
var createJsonErrorResponseHandler2 = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url: url2, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders2(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError2({
        message: response.statusText,
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? undefined : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON2({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError2({
        message: errorToMessage(parsedError),
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? undefined : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError2({
        message: response.statusText,
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? undefined : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler2 = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders2(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError2({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream2({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler2 = (responseSchema) => async ({ response, url: url2, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON2({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders2(response);
  if (!parsedResult.success) {
    throw new APICallError2({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url: url2,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var schemaSymbol2 = Symbol.for("vercel.ai.schema");
var { btoa: btoa3, atob: atob3 } = globalThis;
function convertUint8ArrayToBase642(array2) {
  let latin1string = "";
  for (let i = 0;i < array2.length; i++) {
    latin1string += String.fromCodePoint(array2[i]);
  }
  return btoa3(latin1string);
}
function withoutTrailingSlash2(url2) {
  return url2 == null ? undefined : url2.replace(/\/$/, "");
}
function isDefinedOrNotNull(value) {
  return value !== null && value !== undefined;
}
var ReasoningFormat = /* @__PURE__ */ ((ReasoningFormat2) => {
  ReasoningFormat2["Unknown"] = "unknown";
  ReasoningFormat2["OpenAIResponsesV1"] = "openai-responses-v1";
  ReasoningFormat2["XAIResponsesV1"] = "xai-responses-v1";
  ReasoningFormat2["AnthropicClaudeV1"] = "anthropic-claude-v1";
  return ReasoningFormat2;
})(ReasoningFormat || {});
var CommonReasoningDetailSchema = exports_external.object({
  id: exports_external.string().nullish(),
  format: exports_external.nativeEnum(ReasoningFormat).nullish(),
  index: exports_external.number().optional()
});
var ReasoningDetailSummarySchema = exports_external.object({
  type: exports_external.literal("reasoning.summary"),
  summary: exports_external.string()
}).extend(CommonReasoningDetailSchema.shape);
var ReasoningDetailEncryptedSchema = exports_external.object({
  type: exports_external.literal("reasoning.encrypted"),
  data: exports_external.string()
}).extend(CommonReasoningDetailSchema.shape);
var ReasoningDetailTextSchema = exports_external.object({
  type: exports_external.literal("reasoning.text"),
  text: exports_external.string().nullish(),
  signature: exports_external.string().nullish()
}).extend(CommonReasoningDetailSchema.shape);
var ReasoningDetailUnionSchema = exports_external.union([
  ReasoningDetailSummarySchema,
  ReasoningDetailEncryptedSchema,
  ReasoningDetailTextSchema
]);
var ReasoningDetailsWithUnknownSchema = exports_external.union([
  ReasoningDetailUnionSchema,
  exports_external.unknown().transform(() => null)
]);
var ReasoningDetailArraySchema = exports_external.array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
var OutputUnionToReasoningDetailsSchema = exports_external.union([
  exports_external.object({
    delta: exports_external.object({
      reasoning_details: exports_external.array(ReasoningDetailsWithUnknownSchema)
    })
  }).transform((data) => data.delta.reasoning_details.filter(isDefinedOrNotNull)),
  exports_external.object({
    message: exports_external.object({
      reasoning_details: exports_external.array(ReasoningDetailsWithUnknownSchema)
    })
  }).transform((data) => data.message.reasoning_details.filter(isDefinedOrNotNull)),
  exports_external.object({
    text: exports_external.string(),
    reasoning_details: exports_external.array(ReasoningDetailsWithUnknownSchema)
  }).transform((data) => data.reasoning_details.filter(isDefinedOrNotNull))
]);
var OpenRouterErrorResponseSchema = exports_external.object({
  error: exports_external.object({
    code: exports_external.union([exports_external.string(), exports_external.number()]).nullable().optional().default(null),
    message: exports_external.string(),
    type: exports_external.string().nullable().optional().default(null),
    param: exports_external.any().nullable().optional().default(null)
  })
});
var openrouterFailedResponseHandler = createJsonErrorResponseHandler2({
  errorSchema: OpenRouterErrorResponseSchema,
  errorToMessage: (data) => data.error.message
});
var OpenRouterProviderMetadataSchema = exports_external.object({
  provider: exports_external.string(),
  reasoning_details: exports_external.array(ReasoningDetailUnionSchema).optional(),
  usage: exports_external.object({
    promptTokens: exports_external.number(),
    promptTokensDetails: exports_external.object({
      cachedTokens: exports_external.number()
    }).optional(),
    completionTokens: exports_external.number(),
    completionTokensDetails: exports_external.object({
      reasoningTokens: exports_external.number()
    }).optional(),
    totalTokens: exports_external.number(),
    cost: exports_external.number().optional(),
    costDetails: exports_external.object({
      upstreamInferenceCost: exports_external.number()
    })
  })
});
var OpenRouterProviderOptionsSchema = exports_external.object({
  openrouter: exports_external.object({
    reasoning_details: exports_external.array(ReasoningDetailUnionSchema).optional()
  }).optional()
}).optional();
function mapOpenRouterFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
function isUrl({
  url: url2,
  protocols
}) {
  try {
    const urlObj = new URL(url2);
    return protocols.has(urlObj.protocol);
  } catch (_) {
    return false;
  }
}
function getFileUrl({
  part,
  defaultMediaType
}) {
  var _a153, _b8;
  if (part.data instanceof Uint8Array) {
    const base643 = convertUint8ArrayToBase642(part.data);
    return `data:${(_a153 = part.mediaType) != null ? _a153 : defaultMediaType};base64,${base643}`;
  }
  const stringUrl = part.data.toString();
  if (isUrl({
    url: stringUrl,
    protocols: /* @__PURE__ */ new Set(["http:", "https:"])
  })) {
    return stringUrl;
  }
  return stringUrl.startsWith("data:") ? stringUrl : `data:${(_b8 = part.mediaType) != null ? _b8 : defaultMediaType};base64,${stringUrl}`;
}
function getMediaType(dataUrl, defaultMediaType) {
  var _a153;
  const match = dataUrl.match(/^data:([^;]+)/);
  return match ? (_a153 = match[1]) != null ? _a153 : defaultMediaType : defaultMediaType;
}
function getBase64FromDataUrl(dataUrl) {
  const match = dataUrl.match(/^data:[^;]*;base64,(.+)$/);
  return match ? match[1] : dataUrl;
}
function getCacheControl(providerMetadata) {
  var _a153, _b8, _c;
  const anthropic = providerMetadata == null ? undefined : providerMetadata.anthropic;
  const openrouter2 = providerMetadata == null ? undefined : providerMetadata.openrouter;
  return (_c = (_b8 = (_a153 = openrouter2 == null ? undefined : openrouter2.cacheControl) != null ? _a153 : openrouter2 == null ? undefined : openrouter2.cache_control) != null ? _b8 : anthropic == null ? undefined : anthropic.cacheControl) != null ? _c : anthropic == null ? undefined : anthropic.cache_control;
}
function convertToOpenRouterChatMessages(prompt) {
  var _a153, _b8, _c, _d, _e;
  const messages = [];
  for (const { role, content, providerOptions } of prompt) {
    switch (role) {
      case "system": {
        messages.push({
          role: "system",
          content,
          cache_control: getCacheControl(providerOptions)
        });
        break;
      }
      case "user": {
        if (content.length === 1 && ((_a153 = content[0]) == null ? undefined : _a153.type) === "text") {
          const cacheControl = (_b8 = getCacheControl(providerOptions)) != null ? _b8 : getCacheControl(content[0].providerOptions);
          const contentWithCacheControl = cacheControl ? [
            {
              type: "text",
              text: content[0].text,
              cache_control: cacheControl
            }
          ] : content[0].text;
          messages.push({
            role: "user",
            content: contentWithCacheControl
          });
          break;
        }
        const messageCacheControl = getCacheControl(providerOptions);
        const contentParts = content.map((part) => {
          var _a162, _b22, _c2, _d2, _e2, _f;
          const cacheControl = (_a162 = getCacheControl(part.providerOptions)) != null ? _a162 : messageCacheControl;
          switch (part.type) {
            case "text":
              return {
                type: "text",
                text: part.text,
                cache_control: cacheControl
              };
            case "file": {
              if ((_b22 = part.mediaType) == null ? undefined : _b22.startsWith("image/")) {
                const url2 = getFileUrl({
                  part,
                  defaultMediaType: "image/jpeg"
                });
                return {
                  type: "image_url",
                  image_url: {
                    url: url2
                  },
                  cache_control: cacheControl
                };
              }
              const fileName = String((_f = (_e2 = (_d2 = (_c2 = part.providerOptions) == null ? undefined : _c2.openrouter) == null ? undefined : _d2.filename) != null ? _e2 : part.filename) != null ? _f : "");
              const fileData = getFileUrl({
                part,
                defaultMediaType: "application/pdf"
              });
              if (isUrl({
                url: fileData,
                protocols: /* @__PURE__ */ new Set(["http:", "https:"])
              })) {
                return {
                  type: "file",
                  file: {
                    filename: fileName,
                    file_data: fileData
                  }
                };
              }
              return {
                type: "file",
                file: {
                  filename: fileName,
                  file_data: fileData
                },
                cache_control: cacheControl
              };
            }
            default: {
              return {
                type: "text",
                text: "",
                cache_control: cacheControl
              };
            }
          }
        });
        messages.push({
          role: "user",
          content: contentParts
        });
        break;
      }
      case "assistant": {
        let text2 = "";
        let reasoning = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              reasoning += part.text;
              break;
            }
            case "file":
              break;
            default: {
              break;
            }
          }
        }
        const parsedProviderOptions = OpenRouterProviderOptionsSchema.safeParse(providerOptions);
        const preservedReasoningDetails = parsedProviderOptions.success ? (_d = (_c = parsedProviderOptions.data) == null ? undefined : _c.openrouter) == null ? undefined : _d.reasoning_details : undefined;
        messages.push({
          role: "assistant",
          content: text2,
          tool_calls: toolCalls.length > 0 ? toolCalls : undefined,
          reasoning: reasoning || undefined,
          reasoning_details: preservedReasoningDetails && Array.isArray(preservedReasoningDetails) && preservedReasoningDetails.length > 0 ? preservedReasoningDetails : undefined,
          cache_control: getCacheControl(providerOptions)
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const content2 = getToolResultContent(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: content2,
            cache_control: (_e = getCacheControl(providerOptions)) != null ? _e : getCacheControl(toolResponse.providerOptions)
          });
        }
        break;
      }
      default: {
        break;
      }
    }
  }
  return messages;
}
function getToolResultContent(input) {
  return input.output.type === "text" ? input.output.value : JSON.stringify(input.output.value);
}
var ChatCompletionToolChoiceSchema = exports_external.union([
  exports_external.literal("auto"),
  exports_external.literal("none"),
  exports_external.literal("required"),
  exports_external.object({
    type: exports_external.literal("function"),
    function: exports_external.object({
      name: exports_external.string()
    })
  })
]);
function getChatCompletionToolChoice(toolChoice) {
  switch (toolChoice.type) {
    case "auto":
    case "none":
    case "required":
      return toolChoice.type;
    case "tool": {
      return {
        type: "function",
        function: { name: toolChoice.toolName }
      };
    }
    default: {
      throw new InvalidArgumentError3({
        argument: "toolChoice",
        message: `Invalid tool choice type: ${JSON.stringify(toolChoice)}`
      });
    }
  }
}
var ImageResponseSchema = exports_external.object({
  type: exports_external.literal("image_url"),
  image_url: exports_external.object({
    url: exports_external.string()
  })
});
var ImageResponseWithUnknownSchema = exports_external.union([
  ImageResponseSchema,
  exports_external.unknown().transform(() => null)
]);
var ImageResponseArraySchema = exports_external.array(ImageResponseWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
var OpenRouterChatCompletionBaseResponseSchema = exports_external.object({
  id: exports_external.string().optional(),
  model: exports_external.string().optional(),
  provider: exports_external.string().optional(),
  usage: exports_external.object({
    prompt_tokens: exports_external.number(),
    prompt_tokens_details: exports_external.object({
      cached_tokens: exports_external.number()
    }).nullish(),
    completion_tokens: exports_external.number(),
    completion_tokens_details: exports_external.object({
      reasoning_tokens: exports_external.number()
    }).nullish(),
    total_tokens: exports_external.number(),
    cost: exports_external.number().optional(),
    cost_details: exports_external.object({
      upstream_inference_cost: exports_external.number().nullish()
    }).nullish()
  }).nullish()
});
var OpenRouterNonStreamChatCompletionResponseSchema = exports_external.union([
  OpenRouterChatCompletionBaseResponseSchema.extend({
    choices: exports_external.array(exports_external.object({
      message: exports_external.object({
        role: exports_external.literal("assistant"),
        content: exports_external.string().nullable().optional(),
        reasoning: exports_external.string().nullable().optional(),
        reasoning_details: ReasoningDetailArraySchema.nullish(),
        images: ImageResponseArraySchema.nullish(),
        tool_calls: exports_external.array(exports_external.object({
          id: exports_external.string().optional().nullable(),
          type: exports_external.literal("function"),
          function: exports_external.object({
            name: exports_external.string(),
            arguments: exports_external.string()
          })
        })).optional(),
        annotations: exports_external.array(exports_external.union([
          exports_external.object({
            type: exports_external.literal("url_citation"),
            url_citation: exports_external.object({
              end_index: exports_external.number(),
              start_index: exports_external.number(),
              title: exports_external.string(),
              url: exports_external.string(),
              content: exports_external.string().optional()
            })
          }),
          exports_external.object({
            type: exports_external.literal("file_annotation"),
            file_annotation: exports_external.object({
              file_id: exports_external.string(),
              quote: exports_external.string().optional()
            })
          }),
          exports_external.object({
            type: exports_external.literal("file"),
            file: exports_external.object({
              hash: exports_external.string(),
              name: exports_external.string(),
              content: exports_external.array(exports_external.object({
                type: exports_external.string(),
                text: exports_external.string()
              })).optional()
            })
          })
        ])).nullish()
      }),
      index: exports_external.number().nullish(),
      logprobs: exports_external.object({
        content: exports_external.array(exports_external.object({
          token: exports_external.string(),
          logprob: exports_external.number(),
          top_logprobs: exports_external.array(exports_external.object({
            token: exports_external.string(),
            logprob: exports_external.number()
          }))
        })).nullable()
      }).nullable().optional(),
      finish_reason: exports_external.string().optional().nullable()
    }))
  }),
  OpenRouterErrorResponseSchema.extend({
    user_id: exports_external.string().optional()
  })
]);
var OpenRouterStreamChatCompletionChunkSchema = exports_external.union([
  OpenRouterChatCompletionBaseResponseSchema.extend({
    choices: exports_external.array(exports_external.object({
      delta: exports_external.object({
        role: exports_external.enum(["assistant"]).optional(),
        content: exports_external.string().nullish(),
        reasoning: exports_external.string().nullish().optional(),
        reasoning_details: ReasoningDetailArraySchema.nullish(),
        images: ImageResponseArraySchema.nullish(),
        tool_calls: exports_external.array(exports_external.object({
          index: exports_external.number().nullish(),
          id: exports_external.string().nullish(),
          type: exports_external.literal("function").optional(),
          function: exports_external.object({
            name: exports_external.string().nullish(),
            arguments: exports_external.string().nullish()
          })
        })).nullish(),
        annotations: exports_external.array(exports_external.union([
          exports_external.object({
            type: exports_external.literal("url_citation"),
            url_citation: exports_external.object({
              end_index: exports_external.number(),
              start_index: exports_external.number(),
              title: exports_external.string(),
              url: exports_external.string(),
              content: exports_external.string().optional()
            })
          }),
          exports_external.object({
            type: exports_external.literal("file_annotation"),
            file_annotation: exports_external.object({
              file_id: exports_external.string(),
              quote: exports_external.string().optional()
            })
          }),
          exports_external.object({
            type: exports_external.literal("file"),
            file: exports_external.object({
              hash: exports_external.string(),
              name: exports_external.string(),
              content: exports_external.array(exports_external.object({
                type: exports_external.string(),
                text: exports_external.string()
              })).optional()
            })
          })
        ])).nullish()
      }).nullish(),
      logprobs: exports_external.object({
        content: exports_external.array(exports_external.object({
          token: exports_external.string(),
          logprob: exports_external.number(),
          top_logprobs: exports_external.array(exports_external.object({
            token: exports_external.string(),
            logprob: exports_external.number()
          }))
        })).nullable()
      }).nullish(),
      finish_reason: exports_external.string().nullable().optional(),
      index: exports_external.number().nullish()
    }))
  }),
  OpenRouterErrorResponseSchema
]);
var OpenRouterChatLanguageModel = class {
  constructor(modelId, settings, config2) {
    this.specificationVersion = "v2";
    this.provider = "openrouter";
    this.defaultObjectGenerationMode = "tool";
    this.supportedUrls = {
      "image/*": [
        /^data:image\/[a-zA-Z]+;base64,/,
        /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
      ],
      "application/*": [/^data:application\//, /^https?:\/\/.+$/]
    };
    this.modelId = modelId;
    this.settings = settings;
    this.config = config2;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    frequencyPenalty,
    presencePenalty,
    seed,
    stopSequences,
    responseFormat,
    topK,
    tools,
    toolChoice
  }) {
    var _a153;
    const baseArgs = __spreadValues(__spreadValues({
      model: this.modelId,
      models: this.settings.models,
      logit_bias: this.settings.logitBias,
      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === "number" ? true : undefined,
      top_logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : undefined : undefined,
      user: this.settings.user,
      parallel_tool_calls: this.settings.parallelToolCalls,
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      seed,
      stop: stopSequences,
      response_format: responseFormat,
      top_k: topK,
      messages: convertToOpenRouterChatMessages(prompt),
      include_reasoning: this.settings.includeReasoning,
      reasoning: this.settings.reasoning,
      usage: this.settings.usage,
      plugins: this.settings.plugins,
      web_search_options: this.settings.web_search_options,
      provider: this.settings.provider
    }, this.config.extraBody), this.settings.extraBody);
    if ((responseFormat == null ? undefined : responseFormat.type) === "json" && responseFormat.schema != null) {
      return __spreadProps(__spreadValues({}, baseArgs), {
        response_format: {
          type: "json_schema",
          json_schema: __spreadValues({
            schema: responseFormat.schema,
            strict: true,
            name: (_a153 = responseFormat.name) != null ? _a153 : "response"
          }, responseFormat.description && {
            description: responseFormat.description
          })
        }
      });
    }
    if (tools && tools.length > 0) {
      const mappedTools = tools.filter((tool2) => tool2.type === "function").map((tool2) => ({
        type: "function",
        function: {
          name: tool2.name,
          description: tool2.description,
          parameters: tool2.inputSchema
        }
      }));
      return __spreadProps(__spreadValues({}, baseArgs), {
        tools: mappedTools,
        tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : undefined
      });
    }
    return baseArgs;
  }
  async doGenerate(options) {
    var _a153, _b8, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: responseValue, responseHeaders } = await postJsonToApi2({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders2(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler2(OpenRouterNonStreamChatCompletionResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if ("error" in responseValue) {
      throw new APICallError2({
        message: responseValue.error.message,
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        requestBodyValues: args,
        statusCode: 200,
        responseHeaders,
        data: responseValue.error
      });
    }
    const response = responseValue;
    const choice = response.choices[0];
    if (!choice) {
      throw new NoContentGeneratedError({
        message: "No choice in response"
      });
    }
    const usageInfo = response.usage ? {
      inputTokens: (_a153 = response.usage.prompt_tokens) != null ? _a153 : 0,
      outputTokens: (_b8 = response.usage.completion_tokens) != null ? _b8 : 0,
      totalTokens: ((_c = response.usage.prompt_tokens) != null ? _c : 0) + ((_d = response.usage.completion_tokens) != null ? _d : 0),
      reasoningTokens: (_f = (_e = response.usage.completion_tokens_details) == null ? undefined : _e.reasoning_tokens) != null ? _f : 0,
      cachedInputTokens: (_h = (_g = response.usage.prompt_tokens_details) == null ? undefined : _g.cached_tokens) != null ? _h : 0
    } : {
      inputTokens: 0,
      outputTokens: 0,
      totalTokens: 0,
      reasoningTokens: 0,
      cachedInputTokens: 0
    };
    const reasoningDetails = (_i = choice.message.reasoning_details) != null ? _i : [];
    const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {
      switch (detail.type) {
        case "reasoning.text": {
          if (detail.text) {
            return {
              type: "reasoning",
              text: detail.text
            };
          }
          break;
        }
        case "reasoning.summary": {
          if (detail.summary) {
            return {
              type: "reasoning",
              text: detail.summary
            };
          }
          break;
        }
        case "reasoning.encrypted": {
          if (detail.data) {
            return {
              type: "reasoning",
              text: "[REDACTED]"
            };
          }
          break;
        }
        default: {}
      }
      return null;
    }).filter((p) => p !== null) : choice.message.reasoning ? [
      {
        type: "reasoning",
        text: choice.message.reasoning
      }
    ] : [];
    const content = [];
    content.push(...reasoning);
    if (choice.message.content) {
      content.push({
        type: "text",
        text: choice.message.content
      });
    }
    if (choice.message.tool_calls) {
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: (_j = toolCall.id) != null ? _j : generateId2(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
    }
    if (choice.message.images) {
      for (const image of choice.message.images) {
        content.push({
          type: "file",
          mediaType: getMediaType(image.image_url.url, "image/jpeg"),
          data: getBase64FromDataUrl(image.image_url.url)
        });
      }
    }
    if (choice.message.annotations) {
      for (const annotation of choice.message.annotations) {
        if (annotation.type === "url_citation") {
          content.push({
            type: "source",
            sourceType: "url",
            id: annotation.url_citation.url,
            url: annotation.url_citation.url,
            title: annotation.url_citation.title,
            providerMetadata: {
              openrouter: {
                content: annotation.url_citation.content || ""
              }
            }
          });
        }
      }
    }
    return {
      content,
      finishReason: mapOpenRouterFinishReason(choice.finish_reason),
      usage: usageInfo,
      warnings: [],
      providerMetadata: {
        openrouter: OpenRouterProviderMetadataSchema.parse({
          provider: (_k = response.provider) != null ? _k : "",
          reasoning_details: (_l = choice.message.reasoning_details) != null ? _l : [],
          usage: {
            promptTokens: (_m = usageInfo.inputTokens) != null ? _m : 0,
            completionTokens: (_n = usageInfo.outputTokens) != null ? _n : 0,
            totalTokens: (_o = usageInfo.totalTokens) != null ? _o : 0,
            cost: (_p = response.usage) == null ? undefined : _p.cost,
            promptTokensDetails: {
              cachedTokens: (_s = (_r = (_q = response.usage) == null ? undefined : _q.prompt_tokens_details) == null ? undefined : _r.cached_tokens) != null ? _s : 0
            },
            completionTokensDetails: {
              reasoningTokens: (_v = (_u = (_t = response.usage) == null ? undefined : _t.completion_tokens_details) == null ? undefined : _u.reasoning_tokens) != null ? _v : 0
            },
            costDetails: {
              upstreamInferenceCost: (_y = (_x = (_w = response.usage) == null ? undefined : _w.cost_details) == null ? undefined : _x.upstream_inference_cost) != null ? _y : 0
            }
          }
        })
      },
      request: { body: args },
      response: {
        id: response.id,
        modelId: response.model,
        headers: responseHeaders
      }
    };
  }
  async doStream(options) {
    var _a153;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi2({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders2(this.config.headers(), options.headers),
      body: __spreadProps(__spreadValues({}, args), {
        stream: true,
        stream_options: this.config.compatibility === "strict" ? __spreadValues({
          include_usage: true
        }, ((_a153 = this.settings.usage) == null ? undefined : _a153.include) ? { include_usage: true } : {}) : undefined
      }),
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler2(OpenRouterStreamChatCompletionChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const toolCalls = [];
    let finishReason = "other";
    const usage = {
      inputTokens: Number.NaN,
      outputTokens: Number.NaN,
      totalTokens: Number.NaN,
      reasoningTokens: Number.NaN,
      cachedInputTokens: Number.NaN
    };
    const openrouterUsage = {};
    const accumulatedReasoningDetails = [];
    let textStarted = false;
    let reasoningStarted = false;
    let textId;
    let reasoningId;
    let openrouterResponseId;
    let provider;
    return {
      stream: response.pipeThrough(new TransformStream({
        transform(chunk, controller) {
          var _a162, _b8, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
          if (!chunk.success) {
            finishReason = "error";
            controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          const value = chunk.value;
          if ("error" in value) {
            finishReason = "error";
            controller.enqueue({ type: "error", error: value.error });
            return;
          }
          if (value.provider) {
            provider = value.provider;
          }
          if (value.id) {
            openrouterResponseId = value.id;
            controller.enqueue({
              type: "response-metadata",
              id: value.id
            });
          }
          if (value.model) {
            controller.enqueue({
              type: "response-metadata",
              modelId: value.model
            });
          }
          if (value.usage != null) {
            usage.inputTokens = value.usage.prompt_tokens;
            usage.outputTokens = value.usage.completion_tokens;
            usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
            openrouterUsage.promptTokens = value.usage.prompt_tokens;
            if (value.usage.prompt_tokens_details) {
              const cachedInputTokens = (_a162 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a162 : 0;
              usage.cachedInputTokens = cachedInputTokens;
              openrouterUsage.promptTokensDetails = {
                cachedTokens: cachedInputTokens
              };
            }
            openrouterUsage.completionTokens = value.usage.completion_tokens;
            if (value.usage.completion_tokens_details) {
              const reasoningTokens = (_b8 = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b8 : 0;
              usage.reasoningTokens = reasoningTokens;
              openrouterUsage.completionTokensDetails = {
                reasoningTokens
              };
            }
            openrouterUsage.cost = value.usage.cost;
            openrouterUsage.totalTokens = value.usage.total_tokens;
          }
          const choice = value.choices[0];
          if ((choice == null ? undefined : choice.finish_reason) != null) {
            finishReason = mapOpenRouterFinishReason(choice.finish_reason);
          }
          if ((choice == null ? undefined : choice.delta) == null) {
            return;
          }
          const delta = choice.delta;
          const emitReasoningChunk = (chunkText) => {
            if (!reasoningStarted) {
              reasoningId = openrouterResponseId || generateId2();
              controller.enqueue({
                type: "reasoning-start",
                id: reasoningId
              });
              reasoningStarted = true;
            }
            controller.enqueue({
              type: "reasoning-delta",
              delta: chunkText,
              id: reasoningId || generateId2()
            });
          };
          if (delta.reasoning_details && delta.reasoning_details.length > 0) {
            accumulatedReasoningDetails.push(...delta.reasoning_details);
            for (const detail of delta.reasoning_details) {
              switch (detail.type) {
                case "reasoning.text": {
                  if (detail.text) {
                    emitReasoningChunk(detail.text);
                  }
                  break;
                }
                case "reasoning.encrypted": {
                  if (detail.data) {
                    emitReasoningChunk("[REDACTED]");
                  }
                  break;
                }
                case "reasoning.summary": {
                  if (detail.summary) {
                    emitReasoningChunk(detail.summary);
                  }
                  break;
                }
                default: {
                  break;
                }
              }
            }
          } else if (delta.reasoning) {
            emitReasoningChunk(delta.reasoning);
          }
          if (delta.content) {
            if (reasoningStarted && !textStarted) {
              controller.enqueue({
                type: "reasoning-end",
                id: reasoningId || generateId2()
              });
              reasoningStarted = false;
            }
            if (!textStarted) {
              textId = openrouterResponseId || generateId2();
              controller.enqueue({
                type: "text-start",
                id: textId
              });
              textStarted = true;
            }
            controller.enqueue({
              type: "text-delta",
              delta: delta.content,
              id: textId || generateId2()
            });
          }
          if (delta.annotations) {
            for (const annotation of delta.annotations) {
              if (annotation.type === "url_citation") {
                controller.enqueue({
                  type: "source",
                  sourceType: "url",
                  id: annotation.url_citation.url,
                  url: annotation.url_citation.url,
                  title: annotation.url_citation.title,
                  providerMetadata: {
                    openrouter: {
                      content: annotation.url_citation.content || ""
                    }
                  }
                });
              }
            }
          }
          if (delta.tool_calls != null) {
            for (const toolCallDelta of delta.tool_calls) {
              const index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length - 1;
              if (toolCalls[index] == null) {
                if (toolCallDelta.type !== "function") {
                  throw new InvalidResponseDataError({
                    data: toolCallDelta,
                    message: `Expected 'function' type.`
                  });
                }
                if (toolCallDelta.id == null) {
                  throw new InvalidResponseDataError({
                    data: toolCallDelta,
                    message: `Expected 'id' to be a string.`
                  });
                }
                if (((_d = toolCallDelta.function) == null ? undefined : _d.name) == null) {
                  throw new InvalidResponseDataError({
                    data: toolCallDelta,
                    message: `Expected 'function.name' to be a string.`
                  });
                }
                toolCalls[index] = {
                  id: toolCallDelta.id,
                  type: "function",
                  function: {
                    name: toolCallDelta.function.name,
                    arguments: (_e = toolCallDelta.function.arguments) != null ? _e : ""
                  },
                  inputStarted: false,
                  sent: false
                };
                const toolCall2 = toolCalls[index];
                if (toolCall2 == null) {
                  throw new InvalidResponseDataError({
                    data: { index, toolCallsLength: toolCalls.length },
                    message: `Tool call at index ${index} is missing after creation.`
                  });
                }
                if (((_f = toolCall2.function) == null ? undefined : _f.name) != null && ((_g = toolCall2.function) == null ? undefined : _g.arguments) != null && isParsableJson(toolCall2.function.arguments)) {
                  toolCall2.inputStarted = true;
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCall2.id,
                    toolName: toolCall2.function.name
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall2.id,
                    delta: toolCall2.function.arguments
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall2.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: toolCall2.id,
                    toolName: toolCall2.function.name,
                    input: toolCall2.function.arguments
                  });
                  toolCall2.sent = true;
                }
                continue;
              }
              const toolCall = toolCalls[index];
              if (toolCall == null) {
                throw new InvalidResponseDataError({
                  data: {
                    index,
                    toolCallsLength: toolCalls.length,
                    toolCallDelta
                  },
                  message: `Tool call at index ${index} is missing during merge.`
                });
              }
              if (!toolCall.inputStarted) {
                toolCall.inputStarted = true;
                controller.enqueue({
                  type: "tool-input-start",
                  id: toolCall.id,
                  toolName: toolCall.function.name
                });
              }
              if (((_h = toolCallDelta.function) == null ? undefined : _h.arguments) != null) {
                toolCall.function.arguments += (_j = (_i = toolCallDelta.function) == null ? undefined : _i.arguments) != null ? _j : "";
              }
              controller.enqueue({
                type: "tool-input-delta",
                id: toolCall.id,
                delta: (_k = toolCallDelta.function.arguments) != null ? _k : ""
              });
              if (((_l = toolCall.function) == null ? undefined : _l.name) != null && ((_m = toolCall.function) == null ? undefined : _m.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: (_n = toolCall.id) != null ? _n : generateId2(),
                  toolName: toolCall.function.name,
                  input: toolCall.function.arguments
                });
                toolCall.sent = true;
              }
            }
          }
          if (delta.images != null) {
            for (const image of delta.images) {
              controller.enqueue({
                type: "file",
                mediaType: getMediaType(image.image_url.url, "image/jpeg"),
                data: getBase64FromDataUrl(image.image_url.url)
              });
            }
          }
        },
        flush(controller) {
          var _a162;
          if (finishReason === "tool-calls") {
            for (const toolCall of toolCalls) {
              if (toolCall && !toolCall.sent) {
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: (_a162 = toolCall.id) != null ? _a162 : generateId2(),
                  toolName: toolCall.function.name,
                  input: isParsableJson(toolCall.function.arguments) ? toolCall.function.arguments : "{}"
                });
                toolCall.sent = true;
              }
            }
          }
          if (reasoningStarted) {
            controller.enqueue({
              type: "reasoning-end",
              id: reasoningId || generateId2()
            });
          }
          if (textStarted) {
            controller.enqueue({
              type: "text-end",
              id: textId || generateId2()
            });
          }
          const openrouterMetadata = {
            usage: openrouterUsage
          };
          if (provider !== undefined) {
            openrouterMetadata.provider = provider;
          }
          if (accumulatedReasoningDetails.length > 0) {
            openrouterMetadata.reasoning_details = accumulatedReasoningDetails;
          }
          controller.enqueue({
            type: "finish",
            finishReason,
            usage,
            providerMetadata: {
              openrouter: openrouterMetadata
            }
          });
        }
      })),
      warnings: [],
      request: { body: args },
      response: { headers: responseHeaders }
    };
  }
};
function convertToOpenRouterCompletionPrompt({
  prompt,
  inputFormat,
  user = "user",
  assistant = "assistant"
}) {
  if (inputFormat === "prompt" && prompt.length === 1 && prompt[0] && prompt[0].role === "user" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === "text") {
    return { prompt: prompt[0].content[0].text };
  }
  let text2 = "";
  if (prompt[0] && prompt[0].role === "system") {
    text2 += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError2({
          message: `Unexpected system message in prompt: ${content}`,
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "file": {
              throw new UnsupportedFunctionalityError({
                functionality: "file attachments"
              });
            }
            default: {
              return "";
            }
          }
        }).join("");
        text2 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
            }
            case "tool-result": {
              throw new UnsupportedFunctionalityError({
                functionality: "tool-result messages"
              });
            }
            case "reasoning": {
              throw new UnsupportedFunctionalityError({
                functionality: "reasoning messages"
              });
            }
            case "file": {
              throw new UnsupportedFunctionalityError({
                functionality: "file attachments"
              });
            }
            default: {
              return "";
            }
          }
        }).join("");
        text2 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
      default: {
        break;
      }
    }
  }
  text2 += `${assistant}:
`;
  return {
    prompt: text2
  };
}
var OpenRouterCompletionChunkSchema = exports_external.union([
  exports_external.object({
    id: exports_external.string().optional(),
    model: exports_external.string().optional(),
    choices: exports_external.array(exports_external.object({
      text: exports_external.string(),
      reasoning: exports_external.string().nullish().optional(),
      reasoning_details: ReasoningDetailArraySchema.nullish(),
      finish_reason: exports_external.string().nullish(),
      index: exports_external.number().nullish(),
      logprobs: exports_external.object({
        tokens: exports_external.array(exports_external.string()),
        token_logprobs: exports_external.array(exports_external.number()),
        top_logprobs: exports_external.array(exports_external.record(exports_external.string(), exports_external.number())).nullable()
      }).nullable().optional()
    })),
    usage: exports_external.object({
      prompt_tokens: exports_external.number(),
      prompt_tokens_details: exports_external.object({
        cached_tokens: exports_external.number()
      }).nullish(),
      completion_tokens: exports_external.number(),
      completion_tokens_details: exports_external.object({
        reasoning_tokens: exports_external.number()
      }).nullish(),
      total_tokens: exports_external.number(),
      cost: exports_external.number().optional()
    }).nullish()
  }),
  OpenRouterErrorResponseSchema
]);
var OpenRouterCompletionLanguageModel = class {
  constructor(modelId, settings, config2) {
    this.specificationVersion = "v2";
    this.provider = "openrouter";
    this.supportedUrls = {
      "image/*": [
        /^data:image\/[a-zA-Z]+;base64,/,
        /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
      ],
      "text/*": [/^data:text\//, /^https?:\/\/.+$/],
      "application/*": [/^data:application\//, /^https?:\/\/.+$/]
    };
    this.defaultObjectGenerationMode = undefined;
    this.modelId = modelId;
    this.settings = settings;
    this.config = config2;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    frequencyPenalty,
    presencePenalty,
    seed,
    responseFormat,
    topK,
    stopSequences,
    tools,
    toolChoice
  }) {
    const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({
      prompt,
      inputFormat: "prompt"
    });
    if (tools == null ? undefined : tools.length) {
      throw new UnsupportedFunctionalityError({
        functionality: "tools"
      });
    }
    if (toolChoice) {
      throw new UnsupportedFunctionalityError({
        functionality: "toolChoice"
      });
    }
    return __spreadValues(__spreadValues({
      model: this.modelId,
      models: this.settings.models,
      logit_bias: this.settings.logitBias,
      logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : undefined : undefined,
      suffix: this.settings.suffix,
      user: this.settings.user,
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      seed,
      stop: stopSequences,
      response_format: responseFormat,
      top_k: topK,
      prompt: completionPrompt,
      include_reasoning: this.settings.includeReasoning,
      reasoning: this.settings.reasoning
    }, this.config.extraBody), this.settings.extraBody);
  }
  async doGenerate(options) {
    var _a153, _b8, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi2({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders2(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler2(OpenRouterCompletionChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if ("error" in response) {
      throw new APICallError2({
        message: response.error.message,
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        requestBodyValues: args,
        statusCode: 200,
        responseHeaders,
        data: response.error
      });
    }
    const choice = response.choices[0];
    if (!choice) {
      throw new NoContentGeneratedError({
        message: "No choice in OpenRouter completion response"
      });
    }
    return {
      content: [
        {
          type: "text",
          text: (_a153 = choice.text) != null ? _a153 : ""
        }
      ],
      finishReason: mapOpenRouterFinishReason(choice.finish_reason),
      usage: {
        inputTokens: (_c = (_b8 = response.usage) == null ? undefined : _b8.prompt_tokens) != null ? _c : 0,
        outputTokens: (_e = (_d = response.usage) == null ? undefined : _d.completion_tokens) != null ? _e : 0,
        totalTokens: ((_g = (_f = response.usage) == null ? undefined : _f.prompt_tokens) != null ? _g : 0) + ((_i = (_h = response.usage) == null ? undefined : _h.completion_tokens) != null ? _i : 0),
        reasoningTokens: (_l = (_k = (_j = response.usage) == null ? undefined : _j.completion_tokens_details) == null ? undefined : _k.reasoning_tokens) != null ? _l : 0,
        cachedInputTokens: (_o = (_n = (_m = response.usage) == null ? undefined : _m.prompt_tokens_details) == null ? undefined : _n.cached_tokens) != null ? _o : 0
      },
      warnings: [],
      response: {
        headers: responseHeaders
      }
    };
  }
  async doStream(options) {
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi2({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders2(this.config.headers(), options.headers),
      body: __spreadProps(__spreadValues({}, args), {
        stream: true,
        stream_options: this.config.compatibility === "strict" ? { include_usage: true } : undefined
      }),
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler2(OpenRouterCompletionChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "other";
    const usage = {
      inputTokens: Number.NaN,
      outputTokens: Number.NaN,
      totalTokens: Number.NaN,
      reasoningTokens: Number.NaN,
      cachedInputTokens: Number.NaN
    };
    const openrouterUsage = {};
    return {
      stream: response.pipeThrough(new TransformStream({
        transform(chunk, controller) {
          var _a153, _b8;
          if (!chunk.success) {
            finishReason = "error";
            controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          const value = chunk.value;
          if ("error" in value) {
            finishReason = "error";
            controller.enqueue({ type: "error", error: value.error });
            return;
          }
          if (value.usage != null) {
            usage.inputTokens = value.usage.prompt_tokens;
            usage.outputTokens = value.usage.completion_tokens;
            usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
            openrouterUsage.promptTokens = value.usage.prompt_tokens;
            if (value.usage.prompt_tokens_details) {
              const cachedInputTokens = (_a153 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a153 : 0;
              usage.cachedInputTokens = cachedInputTokens;
              openrouterUsage.promptTokensDetails = {
                cachedTokens: cachedInputTokens
              };
            }
            openrouterUsage.completionTokens = value.usage.completion_tokens;
            if (value.usage.completion_tokens_details) {
              const reasoningTokens = (_b8 = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b8 : 0;
              usage.reasoningTokens = reasoningTokens;
              openrouterUsage.completionTokensDetails = {
                reasoningTokens
              };
            }
            openrouterUsage.cost = value.usage.cost;
            openrouterUsage.totalTokens = value.usage.total_tokens;
          }
          const choice = value.choices[0];
          if ((choice == null ? undefined : choice.finish_reason) != null) {
            finishReason = mapOpenRouterFinishReason(choice.finish_reason);
          }
          if ((choice == null ? undefined : choice.text) != null) {
            controller.enqueue({
              type: "text-delta",
              delta: choice.text,
              id: generateId2()
            });
          }
        },
        flush(controller) {
          controller.enqueue({
            type: "finish",
            finishReason,
            usage,
            providerMetadata: {
              openrouter: {
                usage: openrouterUsage
              }
            }
          });
        }
      })),
      response: {
        headers: responseHeaders
      }
    };
  }
};
function removeUndefinedEntries22(record2) {
  return Object.fromEntries(Object.entries(record2).filter(([, value]) => value !== null));
}
function withUserAgentSuffix2(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries22(headers != null ? headers : {});
  const currentUserAgentHeader = cleanedHeaders["user-agent"] || "";
  const newUserAgent = [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ");
  return __spreadProps(__spreadValues({}, cleanedHeaders), {
    "user-agent": newUserAgent
  });
}
var VERSION4 = "1.2.2";
function createOpenRouter(options = {}) {
  var _a153, _b8, _c;
  const baseURL = (_b8 = withoutTrailingSlash2((_a153 = options.baseURL) != null ? _a153 : options.baseUrl)) != null ? _b8 : "https://openrouter.ai/api/v1";
  const compatibility = (_c = options.compatibility) != null ? _c : "compatible";
  const getHeaders = () => withUserAgentSuffix2(__spreadValues({
    Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "OPENROUTER_API_KEY",
      description: "OpenRouter"
    })}`
  }, options.headers), `ai-sdk/openrouter/${VERSION4}`);
  const createChatModel = (modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {
    provider: "openrouter.chat",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createCompletionModel = (modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {
    provider: "openrouter.completion",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createLanguageModel = (modelId, settings) => {
    if (new.target) {
      throw new Error("The OpenRouter model function cannot be called with the new keyword.");
    }
    if (modelId === "openai/gpt-3.5-turbo-instruct") {
      return createCompletionModel(modelId, settings);
    }
    return createChatModel(modelId, settings);
  };
  const provider = (modelId, settings) => createLanguageModel(modelId, settings);
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  return provider;
}
var openrouter = createOpenRouter({
  compatibility: "strict"
});

// src/ai/providers/openrouter.ts
var apiKey = process.env.OPENROUTER_API_KEY;
if (!apiKey) {
  throw new Error("Missing OPENROUTER_API_KEY environment variable. Set it to your OpenRouter API key.");
}
var openrouter2 = createOpenRouter({
  apiKey
});

// ../../node_modules/pg/esm/index.mjs
var import_lib = __toESM(require_lib2(), 1);
var Client2 = import_lib.default.Client;
var Pool = import_lib.default.Pool;
var Connection = import_lib.default.Connection;
var types = import_lib.default.types;
var Query = import_lib.default.Query;
var DatabaseError = import_lib.default.DatabaseError;
var escapeIdentifier = import_lib.default.escapeIdentifier;
var escapeLiteral = import_lib.default.escapeLiteral;
var Result = import_lib.default.Result;
var TypeOverrides = import_lib.default.TypeOverrides;
var defaults = import_lib.default.defaults;

// src/database/client.ts
var dbConfig = {
  host: "localhost",
  port: 5432,
  database: "aigis",
  user: "postgres",
  password: "postgres",
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000
};
var pool = new Pool(dbConfig);
pool.on("error", (err) => {
  console.error("Unexpected database pool error:", err);
});
async function initDatabase() {
  const client = await pool.connect();
  try {
    await client.query("CREATE EXTENSION IF NOT EXISTS vector");
    await client.query(`
			CREATE TABLE IF NOT EXISTS messages (
				id SERIAL PRIMARY KEY,
				message_id VARCHAR(255) UNIQUE NOT NULL,
				channel_id VARCHAR(255) NOT NULL,
				guild_id VARCHAR(255),
				author_id VARCHAR(255) NOT NULL,
				author_name VARCHAR(255) NOT NULL,
				content TEXT NOT NULL,
				embedding vector(1536),
				created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
				is_bot BOOLEAN DEFAULT FALSE
			)
		`);
    await client.query(`
			CREATE INDEX IF NOT EXISTS idx_messages_channel_created
			ON messages(channel_id, created_at DESC)
		`);
    await client.query(`
			CREATE INDEX IF NOT EXISTS idx_messages_embedding
			ON messages USING ivfflat (embedding vector_cosine_ops)
			WITH (lists = 100)
		`);
    console.log("Database initialized successfully");
  } catch (error46) {
    console.error("Database initialization error:", error46);
    throw error46;
  } finally {
    client.release();
  }
}

// src/ai/embeddings/embeddings.ts
var OPENROUTER_API_BASE = process.env.OPENROUTER_API_BASE ?? "https://openrouter.ai/api/v1";
var OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
var DEFAULT_EMBEDDING_MODEL = process.env.OPENROUTER_EMBEDDING_MODEL ?? "openai/text-embedding-3-small";
var EXPECTED_EMBEDDING_DIMENSIONS = process.env.EMBEDDING_VECTOR_DIMENSION ? Number(process.env.EMBEDDING_VECTOR_DIMENSION) : undefined;
if (EXPECTED_EMBEDDING_DIMENSIONS !== undefined && Number.isNaN(EXPECTED_EMBEDDING_DIMENSIONS)) {
  throw new Error("EMBEDDING_VECTOR_DIMENSION environment variable must be a valid number.");
}
if (!OPENROUTER_API_KEY) {
  throw new Error("Missing OPENROUTER_API_KEY environment variable. Set it to your OpenRouter API key.");
}
async function requestOpenRouterEmbeddings(inputs, modelId) {
  const response = await fetch(`${OPENROUTER_API_BASE}/embeddings`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${OPENROUTER_API_KEY}`
    },
    body: JSON.stringify({
      input: inputs,
      model: modelId
    })
  });
  if (!response.ok) {
    const errorBody = await response.text();
    throw new Error(`Failed to fetch embeddings from OpenRouter: ${response.status} ${response.statusText} - ${errorBody}`);
  }
  const json2 = await response.json();
  if (!json2.data || json2.data.length === 0) {
    throw new Error("OpenRouter embeddings response did not contain data.");
  }
  return json2.data.map((item) => item.embedding);
}
async function generateEmbedding(text2) {
  const embeddings = await requestOpenRouterEmbeddings([text2], DEFAULT_EMBEDDING_MODEL);
  const embedding = embeddings[0];
  if (!embedding) {
    throw new Error("OpenRouter did not return an embedding for the input.");
  }
  if (EXPECTED_EMBEDDING_DIMENSIONS !== undefined && embedding.length !== EXPECTED_EMBEDDING_DIMENSIONS) {
    throw new Error(`Embedding dimension mismatch. Expected ${EXPECTED_EMBEDDING_DIMENSIONS} but received ${embedding.length}. Update OPENROUTER_EMBEDDING_MODEL or EMBEDDING_VECTOR_DIMENSION to match your schema.`);
  }
  return embedding;
}

// src/database/repositories/messageRepository.ts
class MessageRepository {
  async storeMessage(messageId, channelId, guildId, authorId, authorName, content, isBot = false) {
    try {
      await pool.query(`INSERT INTO messages
				(message_id, channel_id, guild_id, author_id, author_name, content, is_bot)
				VALUES ($1, $2, $3, $4, $5, $6, $7)
				ON CONFLICT (message_id) DO NOTHING`, [messageId, channelId, guildId, authorId, authorName, content, isBot]);
      generateEmbedding(content).then((embedding) => {
        return pool.query(`UPDATE messages SET embedding = $1::vector WHERE message_id = $2`, [JSON.stringify(embedding), messageId]);
      }).catch((err) => {
        console.error(`Failed to generate embedding for message ${messageId}:`, err);
      });
    } catch (error46) {
      console.error("Error storing message:", error46);
      throw error46;
    }
  }
  async getRecentMessages(channelId, limit = 10) {
    const result = await pool.query(`SELECT id, message_id, channel_id, guild_id, author_id,
				author_name, content, created_at, is_bot
				FROM messages
				WHERE channel_id = $1
				ORDER BY created_at DESC
				LIMIT $2`, [channelId, limit]);
    return result.rows.map((row) => ({
      id: row.id,
      messageId: row.message_id,
      channelId: row.channel_id,
      guildId: row.guild_id,
      authorId: row.author_id,
      authorName: row.author_name,
      content: row.content,
      createdAt: row.created_at,
      isBot: row.is_bot
    }));
  }
  async searchSimilarMessages(query, channelId, limit = 5, similarityThreshold = 0.7) {
    const queryEmbedding = await generateEmbedding(query);
    const result = await pool.query(`SELECT id, message_id, channel_id, guild_id, author_id,
				author_name, content, created_at, is_bot,
				1 - (embedding <=> $1::vector) as similarity
				FROM messages
				WHERE channel_id = $2
				AND 1 - (embedding <=> $1::vector) > $3
				AND embedding IS NOT NULL
				ORDER BY embedding <=> $1::vector
				LIMIT $4`, [JSON.stringify(queryEmbedding), channelId, similarityThreshold, limit]);
    return result.rows.map((row) => ({
      id: row.id,
      messageId: row.message_id,
      channelId: row.channel_id,
      guildId: row.guild_id,
      authorId: row.author_id,
      authorName: row.author_name,
      content: row.content,
      createdAt: row.created_at,
      isBot: row.is_bot,
      similarity: row.similarity
    }));
  }
  async getMessagesBetweenUserMessages(userId, channelId, currentMessageId, limit = 200) {
    try {
      const currentMessageResult = await pool.query(`SELECT created_at FROM messages WHERE message_id = $1`, [currentMessageId]);
      if (currentMessageResult.rows.length === 0) {
        return [];
      }
      const currentMessageTime = currentMessageResult.rows[0].created_at;
      const previousMessageResult = await pool.query(`SELECT created_at FROM messages
         WHERE author_id = $1
         AND channel_id = $2
         AND created_at < $3
         ORDER BY created_at DESC
         LIMIT 1`, [userId, channelId, currentMessageTime]);
      if (previousMessageResult.rows.length === 0) {
        return [];
      }
      const previousMessageTime = previousMessageResult.rows[0].created_at;
      const result = await pool.query(`SELECT id, message_id, channel_id, guild_id, author_id,
         author_name, content, created_at, is_bot
         FROM messages
         WHERE channel_id = $1
         AND created_at > $2
         AND created_at < $3
         ORDER BY created_at ASC
         LIMIT $4`, [channelId, previousMessageTime, currentMessageTime, limit]);
      return result.rows.map((row) => ({
        id: row.id,
        messageId: row.message_id,
        channelId: row.channel_id,
        guildId: row.guild_id,
        authorId: row.author_id,
        authorName: row.author_name,
        content: row.content,
        createdAt: row.created_at,
        isBot: row.is_bot
      }));
    } catch (error46) {
      console.error("Error getting messages between user messages:", error46);
      throw error46;
    }
  }
}

// src/ai/tools/weatherTool.ts
var weatherTool = tool({
  description: "Get the weather in a location (in Fahrenheit)",
  inputSchema: exports_external.object({
    location: exports_external.string().describe("The location to get the weather for")
  }),
  execute: async ({ location }) => {
    const temperature = 72 + Math.floor(Math.random() * 21) - 10;
    return { location, temperature };
  }
});

// src/ai/tools/convertFahrenheitToCelsiusTool.ts
var convertFahrenheitToCelsiusTool = tool({
  description: "Convert temperature from Fahrenheit to Celsius",
  inputSchema: exports_external.object({
    temperature: exports_external.number().describe("Temperature in Fahrenheit")
  }),
  execute: async ({ temperature }) => {
    const celsius = Math.round((temperature - 32) * (5 / 9));
    return { celsius };
  }
});

// src/ai/tools/ragSearchTool.ts
var messageRepo = new MessageRepository;
function createRagSearchTool(channelId) {
  return tool({
    description: "Search the message history for relevant context when you need more information about past conversations or specific topics discussed in this channel",
    inputSchema: exports_external.object({
      query: exports_external.string().describe("The search query to find relevant past messages")
    }),
    execute: async ({ query }) => {
      const similarMessages = await messageRepo.searchSimilarMessages(query, channelId, 5, 0.7);
      if (similarMessages.length === 0) {
        return {
          found: false,
          message: "No relevant historical context found."
        };
      }
      const formattedResults = similarMessages.map((msg) => ({
        author: msg.authorName,
        content: msg.content,
        timestamp: msg.createdAt.toISOString(),
        similarity: msg.similarity?.toFixed(2)
      }));
      return {
        found: true,
        results: formattedResults,
        count: similarMessages.length
      };
    }
  });
}

// src/services/circuitBreaker/circuitBreaker.ts
class CircuitBreaker {
  failureThreshold;
  recoveryTimeout;
  successThreshold;
  failures;
  state;
  lastFailureTime;
  successes;
  constructor(failureThreshold, recoveryTimeout, successThreshold) {
    this.failureThreshold = failureThreshold;
    this.recoveryTimeout = recoveryTimeout;
    this.successThreshold = successThreshold;
    this.failures = 0;
    this.state = "CLOSED";
    this.lastFailureTime = null;
    this.successes = 0;
  }
  moveToState(newState) {
    this.state = newState;
    if (newState === "CLOSED") {
      this.failures = 0;
      this.successes = 0;
    }
  }
  async call(action) {
    if (this.state === "OPEN") {
      if (this.lastFailureTime && Date.now() - this.lastFailureTime > this.recoveryTimeout) {
        this.moveToState("HALF_OPEN");
      } else {
        throw new Error("Circuit is open");
      }
    }
    try {
      const result = await action();
      if (this.state === "HALF_OPEN") {
        this.successes++;
        if (this.successes >= this.successThreshold) {
          this.moveToState("CLOSED");
        }
      } else if (this.state === "CLOSED") {
        this.failures = 0;
      }
      return result;
    } catch (error46) {
      this.failures++;
      if (this.failures >= this.failureThreshold) {
        this.moveToState("OPEN");
        this.lastFailureTime = Date.now();
      }
      throw error46;
    }
  }
}
var circuitBreaker_default = CircuitBreaker;

// src/ai/tools/quoteTool.ts
var quoteApiCircuitBreaker = new circuitBreaker_default(3, 30000, 2);
var quoteTool = tool({
  description: "Get an inspirational quote from an external API",
  inputSchema: exports_external.object({
    category: exports_external.string().optional().describe("Optional category for the quote (e.g., inspirational, motivational)")
  }),
  execute: async ({ category }) => {
    try {
      const result = await quoteApiCircuitBreaker.call(async () => {
        const response = await fetch("https://api.quotable.io/random", {
          signal: AbortSignal.timeout(5000)
        });
        if (!response.ok) {
          throw new Error(`API returned status ${response.status}`);
        }
        const data = await response.json();
        return {
          quote: data.content,
          author: data.author,
          category: category || "general"
        };
      });
      return result;
    } catch (error46) {
      if (error46 instanceof Error && error46.message === "Circuit is open") {
        return {
          error: "Quote service is temporarily unavailable. Please try again later.",
          quote: "The circuit breaker is protecting the system from cascading failures.",
          author: "Circuit Breaker Pattern"
        };
      }
      return {
        error: "Failed to fetch quote from API",
        quote: "In the face of adversity, resilience is our greatest strength.",
        author: "Fallback Quote"
      };
    }
  }
});

// src/ai/tools/messageSummaryTool.ts
function createMessageSummaryTool(userId, channelId, currentMessageId, messageRepo2) {
  return tool({
    description: "Get all messages that were sent in this channel between the user's current message and their previous message. Use this when the user asks what they missed, wants a summary of recent activity, or wants to catch up on the conversation while they were away.",
    inputSchema: exports_external.object({}),
    execute: async () => {
      const messagesBetween = await messageRepo2.getMessagesBetweenUserMessages(userId, channelId, currentMessageId, 200);
      if (messagesBetween.length === 0) {
        return {
          found: false,
          message: "No messages found between your last two messages. Either this is your first message in this channel, or no one has sent any messages since your last message."
        };
      }
      const formattedMessages = messagesBetween.map((msg) => ({
        author: msg.authorName,
        content: msg.content,
        timestamp: msg.createdAt.toISOString(),
        isBot: msg.isBot
      }));
      return {
        found: true,
        messageCount: messagesBetween.length,
        messages: formattedMessages,
        summary: `Found ${messagesBetween.length} message(s) between your last two messages. Please provide an intelligent summary of the key topics, important points, and overall context of what happened while the user was away.`
      };
    }
  });
}

// src/ai/agent/agent.ts
var messageRepo2 = new MessageRepository;
async function runAgent(prompt, context, channelId, userId, currentMessageId, model) {
  const result = await generateText({
    model: openrouter2.chat(model),
    system,
    prompt: `${context}

Current message: ${prompt}`,
    tools: {
      weather: weatherTool,
      convertFahrenheitToCelsius: convertFahrenheitToCelsiusTool,
      ragSearch: createRagSearchTool(channelId),
      quote: quoteTool,
      messageSummary: createMessageSummaryTool(userId, channelId, currentMessageId, messageRepo2)
    },
    toolChoice: "auto",
    stopWhen: stepCountIs(10)
  });
  return result.text;
}

// src/discord/bot.ts
var config2 = {
  discordToken: process.env.DISCORD_TOKEN,
  aiModel: process.env.AI_MODEL
};
var messageRepo3 = new MessageRepository;
var client = new import_discord2.Client({
  intents: [
    import_discord2.GatewayIntentBits.Guilds,
    import_discord2.GatewayIntentBits.GuildMessages,
    import_discord2.GatewayIntentBits.MessageContent
  ]
});
client.once(import_discord2.Events.ClientReady, async (c) => {
  console.log(`Ready! Logged in as ${c.user.tag}`);
  await initDatabase();
  console.log("Database ready");
});
function stripBotMention(content, botId) {
  return content.replace(new RegExp(`<@!?${botId}>`, "g"), "");
}
async function buildContext(channelId, limit = 10) {
  const recentMessages = await messageRepo3.getRecentMessages(channelId, limit);
  if (recentMessages.length === 0) {
    return "No recent conversation history.";
  }
  const contextLines = [];
  for (let i = recentMessages.length - 1;i >= 0; i--) {
    const msg = recentMessages[i];
    contextLines.push(`[${msg.createdAt.toISOString()}] ${msg.authorName}: ${msg.content}`);
  }
  return `Recent conversation history:
${contextLines.join(`
`)}`;
}
client.on(import_discord2.Events.MessageCreate, async (message) => {
  const startTime = Date.now();
  try {
    if (message.author.bot)
      return;
    if (!client.user)
      return;
    if (!message.mentions.has(client.user))
      return;
    const prompt = stripBotMention(message.content, client.user.id).trim();
    if (!prompt) {
      await message.reply({
        content: "Please provide a prompt.",
        allowedMentions: { repliedUser: false }
      });
      return;
    }
    console.log(`[INCOMING] ${message.author.username}: ${prompt}`);
    await messageRepo3.storeMessage(message.id, message.channelId, message.guildId, message.author.id, message.author.username, message.content, false);
    if (!message.channel.isTextBased())
      return;
    await message.channel.sendTyping();
    const context = await buildContext(message.channelId, 10);
    const reply = await runAgent(prompt, context, message.channelId, message.author.id, message.id, config2.aiModel);
    await messageRepo3.storeMessage(`${message.id}-reply`, message.channelId, message.guildId, client.user.id, client.user.username, reply, true);
    await EmbedResponse.sendLongResponse(message, reply, {
      title: "AI Response \uD83E\uDD16",
      includeContext: true
    });
    const processingTime = Date.now() - startTime;
    console.log(`[OUTGOING] Response sent in ${processingTime}ms`);
    console.log(`[OUTGOING] Content: ${reply.substring(0, 100)}${reply.length > 100 ? "..." : ""}`);
  } catch (err) {
    console.error("Error handling mention with embed:", err);
    try {
      await EmbedResponse.sendError(message, "Sorry, something went wrong.");
    } catch {}
  }
});
client.login(config2.discordToken);
